# Messaging Architecture (MV3 + Extension SPA + C# WASM Background Worker)

This document defines the **port-based messaging architecture** for a Chrome Manifest V3 (MV3) extension where:

* **Content Scripts (CS)** run in web pages
* **Extension SPA** runs as an **extension page** (popup, side panel, or extension tab)
* **Background Worker (BW)** is implemented in **C# WebAssembly (WASM)** instead of JavaScript/TypeScript

The design provides:

* Reliable **lifecycle detection** (cleanup when SPA or tabs close)
* **Multi-tab and multi-frame isolation**
* Deterministic **routing and session management**
* Robustness against **MV3 service worker suspension/restart**

---

## 1. High-Level Goals

1. **Direct SPA ↔ BW communication**
   The SPA is an extension page and connects directly to the Background Worker using `chrome.runtime.connect()`. There is **no SPA ↔ Content Script messaging**.

2. **Per-tab isolation**
   Each tab (and optionally each frame) is treated as its own session.

3. **Lifecycle awareness**
   The BW must be able to detect when:

   * A popup/side panel closes
   * A tab closes or navigates
   * A content script is destroyed

4. **MV3 compatibility**
   The BW may be suspended and restarted by Chrome. The system must recover cleanly via re-handshake.

---

## 2. Contexts

### Content Script (CS)

* Injected into matching web pages
* One instance per tab + frame
* Opens a **long-lived port** to the Background Worker

### Extension SPA (App)

* Runs as:

  * Popup
  * Side panel
  * Extension tab
* Opens a **long-lived port** to the Background Worker
* Explicitly attaches itself to a specific tab session

### Background Worker (BW)

* Implemented in **C# WASM**
* Hosts the authoritative **session registry and router**
* Listens for port connections from CS and App
* Routes messages between them
* Cleans up state on disconnect or tab removal

> Note: Code examples in this document may appear in TypeScript-like pseudocode for clarity, but the **actual BW implementation is in C# WASM** and must map these concepts to its runtime and bindings.

---

## 3. Ports and Naming

### Port Names

Port names **do not need to be unique**. Each `chrome.runtime.connect()` call creates a unique Port object.

Use **fixed, human-readable names**:

| Context        | Port Name |
| -------------- | --------- |
| Content Script | `"cs"`    |
| Extension SPA  | `"app"`   |

### Uniqueness

Uniqueness is handled at the **application level**, not by port names:

* Content Scripts are identified by:

  * `tabId`
  * `frameId`
* SPA instances are identified by:

  * A randomly generated `instanceId`

---

## 4. Message Contract

All communication uses a **single, strongly typed envelope**.

This contract must be implemented in:

* TypeScript (CS + SPA)
* C# (BW WASM)

### Envelope Definition

```ts
export type ContextKind = 'content-script' | 'extension-spa';

export type Envelope =
  | { t: 'HELLO'; context: ContextKind; instanceId: string; tabId?: number; frameId?: number }
  | { t: 'READY'; sessionId: string }
  | { t: 'ATTACH_TAB'; tabId: number; frameId?: number }
  | { t: 'DETACH_TAB' }
  | { t: 'EVENT'; sessionId: string; name: string; data?: any }
  | { t: 'RPC_REQ'; sessionId: string; id: string; method: string; params?: any }
  | { t: 'RPC_RES'; sessionId: string; id: string; ok: boolean; result?: any; error?: string };
```

### Rules

1. Every port **must send `HELLO` immediately after connecting**
2. BW responds with `READY { sessionId }`
3. SPA must send `ATTACH_TAB` before sending any routed messages
4. All routed messages include a `sessionId`

---

## 5. Session Model (BW)

The Background Worker maintains an in-memory session registry.

### Identifiers

* **Tab Key** = `tabId:frameId`
* **SessionId** = random UUID generated by BW

### Session Structure (Logical Model)

```text
Session
├─ sessionId
├─ tabId
├─ frameId
├─ contentScriptPort
├─ attachedSpaPorts[]
├─ createdAt
└─ state (optional, minimal, ephemeral)
```

### Maps (Conceptual)

```text
TabKey → Session
SPA InstanceId → Attached Session
Port → Session
```

In C# WASM, this should be implemented using dictionaries keyed by:

* `string tabKey = $"{tabId}:{frameId}"`
* `Guid sessionId`

---

## 6. Connection Lifecycle

### 6.1 Content Script Startup

1. Generate `instanceId = UUID`
2. `connect({ name: "cs" })`
3. Send:

```json
{ "t": "HELLO", "context": "content-script", "instanceId": "..." }
```

4. BW:

   * Reads `tabId` and `frameId` from `port.sender`
   * Creates or reuses a session
   * Responds:

```json
{ "t": "READY", "sessionId": "..." }
```

---

### 6.2 SPA Startup

1. Generate `instanceId = UUID`
2. `connect({ name: "app" })`
3. Send:

```json
{ "t": "HELLO", "context": "extension-spa", "instanceId": "..." }
```

4. Query active tab:

```ts
const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
```

5. Attach to tab:

```json
{ "t": "ATTACH_TAB", "tabId": 123, "frameId": 0 }
```

6. BW binds SPA port to the session for that tab

---

## 7. Routing Rules

### SPA → CS

1. SPA sends `RPC_REQ` or `EVENT`
2. BW looks up session by SPA attachment
3. BW forwards message to session’s CS port

### CS → SPA

1. CS sends `RPC_REQ` or `EVENT`
2. BW routes to all SPA ports attached to that session

   * Typically only one (popup or side panel)

---

## 8. Cleanup and Lifecycle Handling

### Port Disconnect

When `port.onDisconnect` fires:

* If CS port:

  * Remove CS from session
  * If no SPA attached → destroy session

* If SPA port:

  * Detach SPA from session
  * Session remains alive as long as CS exists

### Tab Closed

BW must listen to:

```ts
chrome.tabs.onRemoved
```

On removal:

* Destroy all sessions for that `tabId`
* Disconnect attached SPA ports

This guarantees cleanup even if disconnect events are delayed.

---

## 9. Multi-Tab Behavior

Each tab gets its own session:

```text
Tab 1 → Session A
Tab 2 → Session B
```

SPA explicitly chooses which tab to control via `ATTACH_TAB`.

Optional UI pattern:

* Dropdown listing open tabs
* User can switch sessions dynamically

---

## 10. MV3 Service Worker Suspension Strategy

### Recommendation

**Stateless BW + deterministic re-handshake**

### Why

* MV3 may suspend or restart the worker at any time
* In-memory state is not reliable

### Pattern

1. All contexts reconnect and resend `HELLO`
2. SPA resends `ATTACH_TAB`
3. BW reconstructs session map from active ports

### Persistence (Optional)

If needed:

* Use `chrome.storage.session` for ephemeral state
* Use `chrome.storage.local` only for durable, minimal configuration

Avoid persisting full session state.

---

## 11. C# WASM Implementation Notes

### Port Bindings

Your C# WASM layer must expose bindings equivalent to:

* `chrome.runtime.onConnect`
* `port.postMessage`
* `port.onMessage`
* `port.onDisconnect`
* `chrome.tabs.onRemoved`

### Data Structures

Recommended C# structures:

```csharp
Dictionary<string, Session> SessionsByTabKey;
Dictionary<Guid, SpaConnection> SpaByInstance;
Dictionary<object, Guid> PortToSession;
```

Where:

* `string tabKey = $"{tabId}:{frameId}"`
* `Guid` is `sessionId`

### Threading Model

Ensure all routing and dictionary access is serialized through:

* A single-threaded event loop
  OR
* Proper locking (if your WASM runtime is multi-threaded)

---

## 12. Manifest Requirements

```json
{
  "permissions": ["tabs"],
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["contentScript.js"]
    }
  ]
}
```

> The SPA requires `tabs` permission to query and attach to the active tab.

---

## 13. Testing Checklist

### Single Tab

* Open SPA
* Verify session created
* Send RPC from SPA → CS
* Receive response

### Multiple Tabs

* Open two tabs
* Inject CS in both
* Attach SPA to tab A
* Verify only tab A receives messages

### Lifecycle

* Close popup → SPA port disconnects → session remains
* Close tab → CS port disconnects → session destroyed

### Restart

* Reload extension
* Open tab and SPA
* Verify HELLO/ATTACH_TAB rebuilds sessions

---

## 14. Summary

This architecture provides:

* Clean separation of concerns
* Strong lifecycle handling
* Multi-tab correctness
* MV3 resilience
* A clear mapping between JavaScript ports and a **C# WASM-based Background Worker router**

It is suitable for high-assurance identity wallets, cryptographic workflows, and advanced multi-context coordination in modern Chrome extensions.
