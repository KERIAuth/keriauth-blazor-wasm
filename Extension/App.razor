@using Extension.Components
@using Extension.Layouts
@using Extension.Models.Messages.AppBw
@using Extension.Services
@using Extension.Services.JsBindings
@using Extension.Utilities
@using WebExtensions.Net.Runtime
@inject NavigationManager navManager
@inject ILogger<App> logger
@inject IAppBwMessagingService appBwMessagingService
@inject AppCache appCache
@inject HttpClient http
@inject IJsRuntimeAdapter jsRuntimeAdapter

@implements IDisposable

@code {
    // Fields
    private bool _isInitialized;

    // Properties
    // InitialUri captures the URI from which the app was loaded. This is used by Index.razor for popup routing (e.g., ?popupType=selectAuthorize).
    public static Uri? InitialUri { get; set; }

    /// <summary>
    /// The context type from which the app was loaded (e.g., TAB, POPUP, SIDEPANEL).
    /// Set during OnInitializedAsync from globalThis.__EXT_CONTEXT__.type.
    /// Defaults to null if the context is not set or cannot be mapped.
    /// </summary>
    public static ContextType? AppContext { get; private set; }

    public static bool IsInPopup => AppContext is not null ? AppContext == ContextType.POPUP : false;
    public static bool IsInSidePanel => AppContext is not null ? AppContext == ContextType.SIDEPANEL : false;
    public static bool IsInTab => !(IsInPopup || IsInSidePanel);

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation("OnInitializedAsync");

        // Read the extension context from globalThis.__EXT_CONTEXT__ set in the HTML page
        await ReadAppContextAsync();

        // Initialize AppCache - this internally waits for BackgroundWorker to complete
        // initialization before reading storage values, ensuring storage defaults exist
        // and expired sessions are cleared.
        await appCache.EnsureInitializedAsync();

        // Subscribe to AppCache for reactivity (StateHasChanged on changes).
        // Navigation logic is handled by Index.razor which serves as the routing hub.
        // await this.SubscribeToAppCache(appCache);

        await VerifyTermsAndPrivacyDigests();

        // Subscribe to and handle messages from background worker via messaging service
        /*
        appBwMessagingService.Subscribe(
            onNext: (message) =>
            {
                logger.LogWarning("App from BW/MessagingService: type={type}, requestId={requestId}", message.Type, message.RequestId);
                // Handle specific message types if needed
                // For now, just log
            },
            onError: (error) =>
            {
                logger.LogError(error, "Error from BW messaging service");
            },
            onCompleted: () =>
            {
                logger.LogInformation("BW messaging service completed");
            }
        );
        */

        // Capture initial URI from which the app was loaded. This may contain query parameters we need.
        InitialUri = navManager.ToAbsoluteUri(navManager.Uri);
        logger.LogInformation("InitialUri: {u}", InitialUri.ToString());

        // Extract tabId from query string if present, otherwise use null
        var query = System.Web.HttpUtility.ParseQueryString(InitialUri.Query);
        var tabIdParam = query["tabId"];
        // Initialize messaging service with BackgroundWorker
        await appBwMessagingService.Initialize(tabIdParam ?? "");

        // If we're on a page that requires auth (unlocked), but we're no longer authenticated, navigate to index.html with force reload for redirection, e.g. to UnlockPage
        // This scenario may occur if user exited Chrome while on an unlocked page, then after session expiration time, re-launched Chrome that re-opens page requiring authorization, such as Dashboard.html.
        if (!appCache.IsAuthenticated && !(AppConfig.PagesNotRequiringAuth.Contains("/" + navManager.ToBaseRelativePath(navManager.Uri))))
        {
            logger.LogInformation("Navigating to IndexPage with force reload since no longer authenticated");
            // TODO P1: Consider to initialUri, which may be dependent on context (tab, popup, sidepanel)
            navManager.NavigateTo(AppConfig.RouteToIndex, true);
            return;
        }

        // Once the above is in place, the UI and other components that may rely on above state is ready to proceed
        _isInitialized = true;
        logger.LogInformation("OnInitializedAsync complete");
    }

    // Verify that the Terms and Privacy HTML files match expected hash digests. If not, developer needs to update expected digests in AppConfig.
    private async Task VerifyTermsAndPrivacyDigests()
    {
        const string termsUrlPath = "content/terms.html";
        const string privacyUrlPath = "content/privacy.html";
        var termsMarkup = new MarkupString(NormalizeContent(await http.GetStringAsync(termsUrlPath)));
        var privacyMarkup = new MarkupString(NormalizeContent(await http.GetStringAsync(privacyUrlPath)));
        int termsDigest = DeterministicHash.ComputeHash(termsMarkup.Value);
        int privacyDigest = DeterministicHash.ComputeHash(privacyMarkup.Value);
        if (termsDigest != AppConfig.ExpectedTermsDigest)
        {
            logger.LogError($"termsHash {termsDigest} does not match expected {AppConfig.ExpectedTermsDigest}");
        }
        if (privacyDigest != AppConfig.ExpectedPrivacyDigest)
        {
            logger.LogError($"privacyHash {privacyDigest} does not match expected {AppConfig.ExpectedPrivacyDigest}");
        }
    }

    /// <summary>
    /// Reads the extension context from globalThis.__EXT_CONTEXT__ set in the HTML page.
    /// Sets AppContext to the mapped ContextType enum value (TAB, POPUP, SIDEPANEL) or null if not set/unknown.
    /// </summary>
    private async Task ReadAppContextAsync()
    {
        try
        {
            var globalThis = new GlobalThisBinding(jsRuntimeAdapter);
            var hasCtx = await globalThis.HasAsync("__EXT_CONTEXT__");
            if (hasCtx)
            {
                var ctx = await globalThis.GetAsync<ExtContext>("__EXT_CONTEXT__");
                AppContext = MapStringToContextType(ctx?.Type);
                logger.LogInformation("AppContext: {ctx}", AppContext?.ToString() ?? "null");
            }
            else
            {
                logger.LogWarning("globalThis.__EXT_CONTEXT__ not found, AppContext will be null");
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to read AppContext from globalThis.__EXT_CONTEXT__");
        }
    }

    /// <summary>
    /// Maps the string context type from HTML to the WebExtensions.Net.Runtime.ContextType enum.
    /// </summary>
    private static ContextType? MapStringToContextType(string? contextString)
    {
        return contextString?.ToUpperInvariant() switch
        {
            "TAB" => ContextType.TAB,
            "POPUP" => ContextType.POPUP,
            "SIDEPANEL" => ContextType.SIDEPANEL,
            "OPTIONS" => ContextType.TAB, // OPTIONS page runs in a tab context
            _ => null
        };
    }

    // Normalize content to ensure consistent hashing across machines with different Git line ending settings
    private static string NormalizeContent(string content)
    {
        if (string.IsNullOrEmpty(content))
        {
            return content;
        }
        // Remove BOM if present, normalize CRLF to LF
        return content.TrimStart('\uFEFF').Replace("\r\n", "\n");
    }

    public void Dispose()
    {
        this.UnsubscribeFromAppCache();
        GC.SuppressFinalize(this);
    }
}

@if (!_isInitialized)
{
    // TODO P3 Comment in/out for debugging startup time
    @*
    *@
    <MudThemeProvider />
    <MudContainer Class="d-flex align-center justify-center" Style="height: 100vh;">
        <MudProgressCircular Indeterminate="true" />
    </MudContainer>

}
else
{
    <Router AppAssembly="@typeof(Program).Assembly">
        <Found Context="routeData">
            <PageTitle>@AppConfig.ProductName</PageTitle>
            <RouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)" />
        </Found>
        <NotFound>
            <PageTitle>@AppConfig.ProductName</PageTitle>
            <LayoutView>
                <h1>Page not found</h1>
                <p role="alert">Sorry, there's nothing at this address</p>
            </LayoutView>
        </NotFound>
    </Router>
}
