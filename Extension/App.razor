@using Extension.Components
@using Extension.Layouts
@using Extension.Models.Messages.AppBw
@using Extension.Services
@using Extension.Utilities
@inject NavigationManager navManager
@inject ILogger<App> logger
@inject IAppBwMessagingService appBwMessagingService
@inject AppCache appCache
@inject HttpClient http

@implements IDisposable

@code {
    // Fields
    private bool _isInitialized;

    // Properties
    // InitialUri captures the URI from which the app was loaded. This is used by Index.razor for popup routing (e.g., ?popupType=selectAuthorize).
    public static Uri? InitialUri { get; set; }

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation("OnInitializedAsync");

        // Initialize AppCache - this internally waits for BackgroundWorker to complete
        // initialization before reading storage values, ensuring storage defaults exist
        // and expired sessions are cleared.
        await appCache.EnsureInitializedAsync();

        // Subscribe to AppCache for reactivity (StateHasChanged on changes).
        // Navigation logic is handled by Index.razor which serves as the routing hub.
        // await this.SubscribeToAppCache(appCache);

        await VerifyTermsAndPrivacyDigests();

        // Subscribe to and handle messages from background worker via messaging service
        /*
        appBwMessagingService.Subscribe(
            onNext: (message) =>
            {
                logger.LogWarning("App from BW/MessagingService: type={type}, requestId={requestId}", message.Type, message.RequestId);
                // Handle specific message types if needed
                // For now, just log
            },
            onError: (error) =>
            {
                logger.LogError(error, "Error from BW messaging service");
            },
            onCompleted: () =>
            {
                logger.LogInformation("BW messaging service completed");
            }
        );
        */

        // Capture initial URI from which the app was loaded. This may contain query parameters we need.
        InitialUri = navManager.ToAbsoluteUri(navManager.Uri);
        logger.LogInformation("InitialUri: {u}", InitialUri.ToString());

        // Extract tabId from query string if present, otherwise use null
        var query = System.Web.HttpUtility.ParseQueryString(InitialUri.Query);
        var tabIdParam = query["tabId"];
        // Initialize messaging service with BackgroundWorker
        await appBwMessagingService.Initialize(tabIdParam ?? "");

        // If we're on a page that requires auth (unlocked), but we're no longer authenticated, navigate to index.html with force reload for redirection, e.g. to UnlockPage
        // This scenario may occur if user exited Chrome while on an unlocked page, then after session expiration time, re-launched Chrome that re-opens page requiring authorization, such as Dashboard.html.
        if (!appCache.IsAuthenticated && !(AppConfig.PagesNotRequiringAuth.Contains("/" + navManager.ToBaseRelativePath(navManager.Uri))))
        {
            logger.LogInformation("Navigating to IndexPage with force reload since no longer authenticated");
            navManager.NavigateTo(AppConfig.RouteToIndex, true);
            return;
        }

        // Once the above is in place, the UI and other components that may rely on above state is ready to proceed
        _isInitialized = true;
        logger.LogInformation("OnInitializedAsync complete");
    }

    // Verify that the Terms and Privacy HTML files match expected hash digests. If not, developer needs to update expected digests in AppConfig.
    private async Task VerifyTermsAndPrivacyDigests()
    {
        const string termsUrlPath = "content/terms.html";
        const string privacyUrlPath = "content/privacy.html";
        var termsMarkup = new MarkupString(NormalizeContent(await http.GetStringAsync(termsUrlPath)));
        var privacyMarkup = new MarkupString(NormalizeContent(await http.GetStringAsync(privacyUrlPath)));
        int termsDigest = DeterministicHash.ComputeHash(termsMarkup.Value);
        int privacyDigest = DeterministicHash.ComputeHash(privacyMarkup.Value);
        if (termsDigest != AppConfig.ExpectedTermsDigest)
        {
            logger.LogError($"termsHash {termsDigest} does not match expected {AppConfig.ExpectedTermsDigest}");
        }
        if (privacyDigest != AppConfig.ExpectedPrivacyDigest)
        {
            logger.LogError($"privacyHash {privacyDigest} does not match expected {AppConfig.ExpectedPrivacyDigest}");
        }
    }

    // Normalize content to ensure consistent hashing across machines with different Git line ending settings
    private static string NormalizeContent(string content)
    {
        if (string.IsNullOrEmpty(content))
        {
            return content;
        }
        // Remove BOM if present, normalize CRLF to LF
        return content.TrimStart('\uFEFF').Replace("\r\n", "\n");
    }

    public void Dispose()
    {
        this.UnsubscribeFromAppCache();
        GC.SuppressFinalize(this);
    }
}

@if (!_isInitialized)
{
    // TODO P3 Comment in/out for debugging startup time
    @*
    *@
    <MudThemeProvider />
    <MudContainer Class="d-flex align-center justify-center" Style="height: 100vh;">
        <MudProgressCircular Indeterminate="true" />
    </MudContainer>

}
else
{
    <Router AppAssembly="@typeof(Program).Assembly">
        <Found Context="routeData">
            <PageTitle>@AppConfig.ProductName</PageTitle>
            <RouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)" />
        </Found>
        <NotFound>
            <PageTitle>@AppConfig.ProductName</PageTitle>
            <LayoutView>
                <h1>Page not found</h1>
                <p role="alert">Sorry, there's nothing at this address.</p>
            </LayoutView>
        </NotFound>
    </Router>
}
