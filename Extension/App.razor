@using Extension.Layouts
@using Extension.Models
@using Extension.Models.Messages.AppBw
@using Extension.Pages
@using System.Runtime.InteropServices.JavaScript
@using Extension.Utilities
@inject NavigationManager navManager
@inject IJSRuntime jsRuntime
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject ILogger<App> logger
@inject IAppBwMessagingService appBwMessagingService
@inject AppCache appCache
@inject HttpClient http

@implements IDisposable

@code {
    // Properties
    public static Uri? InitialUri { get; set; }
    // public static Preferences Prefs { get; set; } = new Preferences();

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation("OnInitializedAsync");

        // Ensure AppCache is initialized with initial fetch of essential storage records
        // This replaces the previous WaitForAppCache polling approach.
        // BackgroundWorker.InitializeStorageDefaultsAsync() creates skeleton records on install/startup,
        // and AppCache.EnsureInitializedAsync() fetches them into cache before we proceed.
        await appCache.EnsureInitializedAsync();

        await this.SubscribeToAppCache(appCache, RedirectIfNeeded);

        await VerifyTermsAndPrivacyDigests();

        // Subscribe to and handle messages from background worker via messaging service
        appBwMessagingService.Subscribe(
            onNext: (message) =>
            {
                logger.LogWarning("App from BW/MessagingService: type={type}, requestId={requestId}", message.Type, message.RequestId);
                // Handle specific message types if needed
                // For now, just log
            },
            onError: (error) =>
            {
                logger.LogError(error, "Error from BW messaging service");
            },
            onCompleted: () =>
            {
                logger.LogInformation("BW messaging service completed");
            }
        );

        // Initialize messaging with background worker
        // Extract tabId from query string if present, otherwise use null
        InitialUri = navManager.ToAbsoluteUri(navManager.Uri);
        var query = System.Web.HttpUtility.ParseQueryString(InitialUri.Query);
        var tabIdParam = query["tabId"];
        await appBwMessagingService.Initialize(tabIdParam ?? "");

        await RedirectIfNeeded();
        logger.LogInformation("OnInitializedAsync complete");
    }

    // NavigateIfNeeded navigates to newUrl only if not already on that page
    void NavigateIfNeeded(string newUrl)
    {
        // logger.LogWarning("navManager.Uri: {u}", navManager.Uri);

        navManager.NavigateTo(newUrl);
        return;
    }

    async Task RedirectIfNeeded()
    {
        logger.LogInformation("RedirectIfNeeded");
        // logger.LogInformation("{x}", a.MyPreferences);
        // logger.LogInformation("{x}", a.MyOnboardState);
        // logger.LogInformation("{x}", a.MyKeriaConnectConfig);
        // logger.LogInformation("{x}", a.MyKeriaConnectionInfo);
        // logger.LogInformation("{x}", a.MyPasscodeModel);
        // logger.LogInformation("{x}", a.MySessionExpiration);

        if (!appCache.MyOnboardState.IsWelcomed)
        {
            NavigateIfNeeded(RouteToWelcome);
            return;
        }
        if (!appCache.IsInstallAcknowledged)
        {
            NavigateIfNeeded(RouteToNewRelease);
            return;
        }
        if (!appCache.IsTosAgreed)
        {
            NavigateIfNeeded(RouteToTerms);
            return;
        }
        if (!appCache.IsPrivacyAgreed)
        {
            NavigateIfNeeded(RouteToPrivacy);
            return;
        }
        // Passing above conditions must equate to IsProductOnboarded
        if (!appCache.IsProductOnboarded)
        {
            logger.LogError("RedirectIfNeeded: Not ProductOnboarded");
            return;
        }
        // logger.LogWarning($"RedirectIfNeeded?: NotRequiringAuth: {string.Join(", ",AppConfig.PagesNotRequiringAuth)} this one: {navManager.ToBaseRelativePath(navManager.Uri)}");
        // Check if on a page not requiring authentication
        if (AppConfig.PagesNotRequiringAuth.Contains("/" + navManager.ToBaseRelativePath(navManager.Uri)))
        {
            // Redirect not needed; okay to stay on this page
            // logger.LogInformation($"RedirectIfNeeded: on unauthenticated page, so no re-route. {navManager.ToBaseRelativePath(navManager.Uri)}");
            return;
        }
        if (!appCache.IsConfigured)
        {
            NavigateIfNeeded(RouteToConfigure);
            return;
        }
        // Passing the above conditions must equate to IsInitialized
        if (!appCache.IsInitialized)
        {
            logger.LogError("RedirectIfNeeded: Not Initialized");
            return;
        }
        if (!appCache.IsSessionUnlocked)
        {
            NavigateIfNeeded(RouteToUnlock);
            return;
        }
        if (!appCache.IsAuthenticated)
        {
            logger.LogError("RedirectIfNeeded: Not Authenticated");
            return;
        }
        if (!appCache.IsIdentifierFetched)
        {
            NavigateIfNeeded(RouteToConnecting);
            return;
        }
        // Passing the above conditions must equate to IsConnectedToKeria
        if (!appCache.IsConnectedToKeria)
        {
            logger.LogError("RedirectIfNeeded: Not ConnectedToKeria");
            return;
        }
        // logger.LogInformation("RedirectIfNeeded: No re-route conditions detected.");
        // TODO P1: consider navigating to Dashboard or other page
        // NavigateIfNeeded(RouteToDashboard);
        // if there's a query parameter for a specific page, navigate there
        if (InitialUri?.Query is not null)
        {
            logger.LogInformation("RedirectIfNeeded: InitialUri.Query: {q}", InitialUri.Query);
            var query = System.Web.HttpUtility.ParseQueryString(InitialUri.Query);
            logger.LogInformation("RedirectIfNeeded: query string: {q}", query.ToString());
            if (query["page"] != null)
            {
                var pageParam = query["popupType"] switch
                {
                    "selectAuthorize" => AppConfig.RouteToRequestSignIn,
                    "signRequest" => AppConfig.RouteToRequestSignHeaders,
                    _ => throw new Exception("unexpected popupType query param value")
                };
                logger.LogWarning("RedirectIfNeeded: navigating to page param: {p}", pageParam);
                // NavigateIfNeeded(pageParam!);
                return;
            }
        }
        
        
        
        
    }

    // Verify that the Terms and Privacy HTML files match expected hash digests. If not, developer needs to update expected digests in AppConfig.
    private async Task VerifyTermsAndPrivacyDigests()
    {
        const string termsUrlPath = "content/terms.html";
        const string privacyUrlPath = "content/privacy.html";
        var termsMarkup = new MarkupString(NormalizeContent(await http.GetStringAsync(termsUrlPath)));
        var privacyMarkup = new MarkupString(NormalizeContent(await http.GetStringAsync(privacyUrlPath)));
        int termsDigest = DeterministicHash.ComputeHash(termsMarkup.Value);
        int privacyDigest = DeterministicHash.ComputeHash(privacyMarkup.Value);
        if (termsDigest != AppConfig.ExpectedTermsDigest)
        {
            logger.LogError($"termsHash {termsDigest} does not match expected {AppConfig.ExpectedTermsDigest}");
        }
        if (privacyDigest != AppConfig.ExpectedPrivacyDigest)
        {
            logger.LogError($"privacyHash {privacyDigest} does not match expected {AppConfig.ExpectedPrivacyDigest}");
        }
    }

    // Normalize content to ensure consistent hashing across machines with different Git line ending settings
    private static string NormalizeContent(string content)
    {
        if (string.IsNullOrEmpty(content))
        {
            return content;
        }
        // Remove BOM if present, normalize CRLF to LF
        return content.TrimStart('\uFEFF').Replace("\r\n", "\n");
    }

    public void Dispose()
    {
        this.UnsubscribeFromAppCache();
        GC.SuppressFinalize(this);
    }
}

<Router AppAssembly="@typeof(Program).Assembly">
    <Found Context="routeData">
        <PageTitle>@AppConfig.ProductName</PageTitle>
        <RouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)" />
    </Found>
    <NotFound>
        <PageTitle>@AppConfig.ProductName</PageTitle>
        <LayoutView>
            <h1>Page not found</h1>
            <p role="alert">Sorry, there's nothing at this address.</p>
        </LayoutView>
    </NotFound>
</Router>
