@using Extension.Layouts
@using Extension.Models.Messages.AppBw
@using Extension.Models.Storage
@using Extension.Services.Storage
@using Extension.Pages
@using System.Runtime.InteropServices.JavaScript
@using Extension.Utilities
@inject NavigationManager navManager
@inject IJSRuntime jsRuntime
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject ILogger<App> logger
@inject IStorageService storageService
@inject IAppBwMessagingService appBwMessagingService
@inject AppCache appCache
@inject HttpClient http

@inherits AppCacheReactiveComponentBase // AppCacheReactiveComponentBase will invoke StateHasChanged() on AppCache changes

@code {
    // fields
    // session storage observers
    // private StorageObserver<KeriaConnectionInfo>? keriaConnectionInfoStorageObserver;
    // private StorageObserver<SessionExpiration>? sessionExpirationStorageObserver;
    // private StorageObserver<PasscodeModel>? passcodeModelStorageObserver;
    // local storage observers
    // private StorageObserver<OnboardState>? onboardStateStorageObserver;
    // private StorageObserver<Preferences>? preferencesStorageObserver;
    // private StorageObserver<KeriaConnectConfig>? keriaConnectConfigStorageObserver;

    // properties
    public static Uri? InitialUri { get; set; }
    // properties intended to cascade down to child components (layouts, pages) via [CascadingParameter] attribution
    public static Preferences Prefs { get; set; } = new Preferences();
    // OBSOLETE: InactivityTimeoutCache removed - use appCache.MyPasscodeModel.SessionExpirationUtc instead
    // public SessionExpiration? InactivityTimeoutCache { get; set; }

    // reactive properties

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation($"OnInitializedAsync");

        await VerifyTermsAndPrivacyDigests(); 

        /*
        // Create several storage observers with callbacks to keep local properties in sync with storage changes
        // Note that AppCacheReactiveComponentBase will invoke StateHasChanged() on AppCache changes
        // 1.
        preferencesStorageObserver = new StorageObserver<Preferences>(
            storageService,
            StorageArea.Local,
            onNext: _ => { },
            // onNext: async (Preferences value) => StateHasChanged(),
            onError: async (Exception error) => logger.LogError("HandleErrorPreferences: " + error.Message),
            logger: logger
        );

        // 2.
        sessionExpirationStorageObserver = new StorageObserver<SessionExpiration>(
            storageService,
            StorageArea.Session,
            // TODO P1 remove?
            onNext: async (SessionExpiration updatedValue) =>
            {
                InactivityTimeoutCache = updatedValue;
                logger.LogInformation("SessionExpiration value updated: SessionExpirationUtc={SessionExpirationUtc} UtcNow={s}",
                    InactivityTimeoutCache.SessionExpirationUtc, DateTime.UtcNow);
                StateHasChanged();
                // TODO P1: in case this has been deleted, handle that case
                logger.LogWarning("SessionExpiration value updated?: SessionExpirationUtc={SessionExpirationUtc} UtcNow={s}", appCache.MySessionExpiration.SessionExpirationUtc, DateTime.UtcNow);
                await RedirectIfNeeded();
            },
            onCompleted: async () =>
            {
                logger.LogInformation("SessionExpiration observation completed");
            },
            onError: async (Exception error) =>
            {
                logger.LogError("SessionExpiration observation error: " + error.Message);
            },
            logger: logger
        );

        // 3.
        keriaConnectionInfoStorageObserver = new StorageObserver<KeriaConnectionInfo>(
            storageService,
            StorageArea.Session,
            // TODO P1 remove
            onNext: (updatedValue) =>
            {
                logger.LogInformation("TBD value updated: {v}", updatedValue.ToString());
                StateHasChanged();
            },
            onError: async (Exception error) =>
            {
                logger.LogError("TBD observation error: " + error.Message);
            },
            logger: logger
        );

        // 4.
        passcodeModelStorageObserver = new StorageObserver<PasscodeModel>(
            storageService,
            StorageArea.Session,
            // TODO P1 remove
            onNext: (updatedValue) =>
            {
                logger.LogInformation("TBD value updated: {v}", updatedValue.ToString());
                StateHasChanged();
            },
            onError: async (Exception error) =>
            {
                logger.LogError("TBD observation error: " + error.Message);
            },
            logger: logger
        );

        // 5.
        onboardStateStorageObserver = new StorageObserver<OnboardState>(
           storageService,
           StorageArea.Local,
           // TODO P1 remove
           onNext: (updatedValue) =>
           {
               logger.LogInformation("TBD value updated: {v}", updatedValue.ToString());
               StateHasChanged();
           },
           onError: async (Exception error) =>
           {
               logger.LogError("TBD observation error: " + error.Message);
           },
           logger: logger
        );

        // 6.
        keriaConnectConfigStorageObserver = new StorageObserver<KeriaConnectConfig>(
            storageService,
            StorageArea.Local,
            // TODO P1 remove
            onNext: (updatedValue) =>
            {
                logger.LogInformation("TBD value updated: {v}", updatedValue.ToString());
                StateHasChanged();
            },
            onError: async (Exception error) =>
            {
                logger.LogError("TBD observation error: " + error.Message);
            },
            logger: logger
        );
        // 7. TODO P2 add WebsiteConfigList observer if needed
        // 8. TODO P2 add AuthenticatorList observer if needed
        */

        // Subscribe to and handle messages from background worker via messaging service
        appBwMessagingService.Subscribe(
            onNext: (message) =>
            {
                logger.LogWarning("App from BW/MessagingService: type={type}, requestId={requestId}", message.Type, message.RequestId);
                // Handle specific message types if needed
                // For now, just log
            },
            onError: (error) =>
            {
                logger.LogError(error, "Error from BW messaging service");
            },
            onCompleted: () =>
            {
                logger.LogInformation("BW messaging service completed");
            }
        );

        // Initialize messaging with background worker
        // Extract tabId from query string if present, otherwise use null
        InitialUri = navManager.ToAbsoluteUri(navManager.Uri);
        // logger.LogWarning("InitialUri: {u}", InitialUri.ToString());
        // logger.LogWarning("OnInitializedAsync LocalPath: {p}", InitialUri.LocalPath);
        // logger.LogWarning("OnInitializedAsync AbsolutePath: {p}", InitialUri.AbsolutePath);
        var query = System.Web.HttpUtility.ParseQueryString(InitialUri.Query);
        var tabIdParam = query["tabId"];
        await appBwMessagingService.Initialize(tabIdParam ?? "");

        // Reset sessionExpiration by showing initial user activity
        // var message = new AppBwUserActivityMessage();
        // await appBwMessagingService.SendToBackgroundWorkerAsync(message);

        await RedirectIfNeeded();
        return;
    }

    /*
    [JSInvokableAttribute("LockApp")]
    public static async Task LockApp()
    {
        // Note that other side-effects will be reactive. See IObserver<StateService>
        if (staticStorageService is null || staticLogger is null)
        {
            throw new Exception("unexpected null staticStorageService");
            }
        var res = await staticStorageService.Clear(StorageArea.Session);
        return;
        }
        */

    // NavigateIfNeeded navigates to newUrl only if not already on that page. In a browser refresh, this may be a build-generated copy of index.html (named FooPage.html) versus the routed path
    void NavigateIfNeeded(string newUrl)
    {
        // logger.LogWarning("navManager.Uri: {u}", navManager.Uri);

        navManager.NavigateTo(newUrl);
        return;
    }

    async Task RedirectIfNeeded()
    {
        logger.LogInformation("RedirectIfNeeded");
        // logger.LogInformation("{x}", a.MyPreferences);
        // logger.LogInformation("{x}", a.MyOnboardState);
        // logger.LogInformation("{x}", a.MyKeriaConnectConfig);
        // logger.LogInformation("{x}", a.MyKeriaConnectionInfo);
        // logger.LogInformation("{x}", a.MyPasscodeModel);
        // logger.LogInformation("{x}", a.MySessionExpiration);

        if (!appCache.MyOnboardState.IsWelcomed)
        {
            NavigateIfNeeded(RouteToWelcome);
            return;
        }
        if (!appCache.IsInstallAcknowledged)
        {
            NavigateIfNeeded(RouteToNewRelease);
            return;
        }
        if (!appCache.IsTosAgreed)
        {
            NavigateIfNeeded(RouteToTerms);
            return;
        }
        if (!appCache.IsPrivacyAgreed)
        {
            NavigateIfNeeded(RouteToPrivacy);
            return;
        }
        // Passing above conditions must equate to IsProductOnboarded
        if (!appCache.IsProductOnboarded)
        {
            logger.LogError("RedirectIfNeeded: Not ProductOnboarded");
            return;
        }
        // logger.LogWarning($"RedirectIfNeeded?: NotRequiringAuth: {string.Join(", ",AppConfig.PagesNotRequiringAuth)} this one: {navManager.ToBaseRelativePath(navManager.Uri)}");
        // Check if on a page not requiring authentication
        if (AppConfig.PagesNotRequiringAuth.Contains("/" + navManager.ToBaseRelativePath(navManager.Uri)))
        {
            // Redirect not needed; okay to stay on this page
            // logger.LogInformation($"RedirectIfNeeded: on unauthenticated page, so no re-route. {navManager.ToBaseRelativePath(navManager.Uri)}");
            return;
        }
        if (!appCache.IsConfigured)
        {
            NavigateIfNeeded(RouteToConfigure);
            return;
        }
        // Passing the above conditions must equate to IsInitialized
        if (!appCache.IsInitialized)
        {
            logger.LogError("RedirectIfNeeded: Not Initialized");
            return;
        }
        if (!appCache.IsSessionUnlocked)
        {
            NavigateIfNeeded(RouteToUnlock);
            return;
        }
        if (!appCache.IsAuthenticated)
        {
            logger.LogError("RedirectIfNeeded: Not Authenticated");
            return;
        }
        if (!appCache.IsIdentifierFetched)
        {
            NavigateIfNeeded(RouteToConnecting);
            return;
        }
        // Passing the above conditions must equate to IsConnectedToKeria
        if (!appCache.IsConnectedToKeria)
        {
            logger.LogError("RedirectIfNeeded: Not ConnectedToKeria");
            return;
        }
        // logger.LogInformation("RedirectIfNeeded: No re-route conditions detected.");
        NavigateIfNeeded(RouteToDashboard);
    }

    // Verify that the Terms and Privacy HTML files match expected hash digests. If not, developer needs to update expected digests in AppConfig.
    private async Task VerifyTermsAndPrivacyDigests()
    {
        const string termsUrlPath = "content/terms.html";
        const string privacyUrlPath = "content/privacy.html";
        var termsMarkup = new MarkupString(await http.GetStringAsync(termsUrlPath));
        var privacyMarkup = new MarkupString(await http.GetStringAsync(privacyUrlPath));
        int termsDigest = DeterministicHash.ComputeHash(termsMarkup.Value);
        int privacyDigest = DeterministicHash.ComputeHash(privacyMarkup.Value);
        if (termsDigest != AppConfig.ExpectedTermsDigest)
        {
            logger.LogError($"termsHash {termsDigest} does not match expected {AppConfig.ExpectedTermsDigest}");
        }
        if (privacyDigest != AppConfig.ExpectedPrivacyDigest)
        {
            logger.LogError($"privacyHash {privacyDigest} does not match expected {AppConfig.ExpectedPrivacyDigest}");
        }
    }
}

<Router AppAssembly="@typeof(Program).Assembly">
    <Found Context="routeData">
        <PageTitle>@AppConfig.ProductName</PageTitle>
        <RouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)" />
    </Found>
    <NotFound>
        <PageTitle>@AppConfig.ProductName</PageTitle>
        <LayoutView>
            <h1>Page not found</h1>
            <p role="alert">Sorry, there's nothing at this address.</p>
        </LayoutView>
    </NotFound>
</Router>
