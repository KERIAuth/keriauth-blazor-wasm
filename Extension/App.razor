@using Extension.Models
@using Extension.Models.Messages.AppBw
@using Extension.Models.Storage
@using Extension.Services
@using Extension.Services.JsBindings
@using Extension.Services.Port
@using Extension.Services.Storage
@using Extension.Utilities
@using WebExtensions.Net.Runtime
@inject NavigationManager navManager
@inject ILogger<App> logger
@inject IAppPortService appPortService
@inject AppCache appCache
@inject HttpClient http
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject IStorageService storageService

@implements IAsyncDisposable

@code {
    // Fields
    private bool _isInitialized;

    // Properties
    // InitialUri captures the URI from which the app was loaded. This is used by Index.razor for popup routing (e.g., ?popupType=selectAuthorize).
    public static Uri? InitialUri { get; set; }

    /// <summary>
    /// State for the passkey creation offer flow during initial setup.
    /// Set by ConfigurePage after successful KERIA connection, checked by Index.razor for routing.
    /// </summary>
    public static OfferCreatePasskeyState OfferCreatePasskeyState { get; set; } = OfferCreatePasskeyState.NotOffered;

    /// <summary>
    /// The context type from which the app was loaded (e.g., TAB, POPUP, SIDEPANEL).
    /// Set during OnInitializedAsync from globalThis.__EXT_CONTEXT__.type.
    /// Defaults to null if the context is not set or cannot be mapped.
    /// </summary>
    public static ContextType? AppContext { get; private set; }

    public static bool IsInPopup => AppContext is not null ? AppContext == ContextType.POPUP : false;
    public static bool IsInSidePanel => AppContext is not null ? AppContext == ContextType.SIDEPANEL : false;
    public static bool IsInTab => !(IsInPopup || IsInSidePanel);

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation("OnInitializedAsync");

        // Read the extension context from globalThis.__EXT_CONTEXT__ set in the index HTML page
        await ReadAppContextAsync();

        // Initialize AppCache - this internally waits for BackgroundWorker to complete
        // initialization before reading storage values, ensuring storage defaults exist
        // and expired sessions are cleared.
        await appCache.EnsureInitializedAsync();

        // Clear KeriaConnectionInfo on App startup to force reconnection via ConnectingPage.
        // On page reload, the JavaScript signify client state is lost even though session storage persists.
        // Clearing KeriaConnectionInfo ensures IsIdentifierFetched returns false, which routes through
        // ConnectingPage to properly reconnect the signify client.
        await storageService.RemoveItem<KeriaConnectionInfo>(StorageArea.Session);
        appCache.ClearKeriaConnectionInfo(); // Sync update so Index.razor sees cleared state immediately
        logger.LogInformation("Cleared KeriaConnectionInfo to ensure signify client reconnection");

        // Subscribe to AppCache for reactivity (StateHasChanged on changes).
        // Navigation logic is handled by Index.razor which serves as the routing hub.
        // await this.SubscribeToAppCache(appCache);

        await VerifyTermsAndPrivacyDigests();

        // TODO P2 is tabId or any query param needed? If not, remove this logic.
        // Capture initial URI from which the app was loaded. This may contain query parameters we need.
        InitialUri = navManager.ToAbsoluteUri(navManager.Uri);
        logger.LogInformation("InitialUri: {u}", InitialUri.ToString());

        // Connect to BackgroundWorker via port-based messaging
        // This replaces the legacy sendMessage-based appBwMessagingService.Initialize()
        await appPortService.ConnectAsync();
        logger.LogInformation("Connected to BackgroundWorker via port, portSessionId={PortSessionId}, originTabId={OriginTabId}",
            appPortService.PortSessionId, appPortService.OriginTabId);

        // If we're on a page that requires being authenticated (unlocked), but we're no longer authenticated, navigate to index.html with force reload for redirection, e.g. to UnlockPage
        if (!appCache.IsAuthenticated && Routes.PathRequiresAuth("/" + navManager.ToBaseRelativePath(navManager.Uri)))
        {
            // This situation may occur if user exited Chrome while on an unlocked page, then after session expiration time, re-launched Chrome that re-opens page requiring authorization, such as Dashboard.html.
            // Navigate to InitialUri (e.g. index.html, indexInPopup.html, indexInSidePanel ...) with forced reload since we are in an unknown App load state.
            navManager.NavigateTo(InitialUri.AbsolutePath, true);
            return;
        }

        // Once the above is in place, the UI and other components that may rely on above state is ready to proceed
        _isInitialized = true;
        logger.LogInformation("OnInitializedAsync complete");
    }

    public static int CurrentTermsDigest;
    public static int CurrentPrivacyDigest;

    // Verify that the Terms and Privacy HTML files match expected hash digests. If not, developer needs to update expected digests in AppConfig.
    private async Task VerifyTermsAndPrivacyDigests()
    {
        const string termsUrlPath = "content/terms.html";
        const string privacyUrlPath = "content/privacy.html";
        var termsMarkup = new MarkupString(NormalizeContent(await http.GetStringAsync(termsUrlPath)));
        var privacyMarkup = new MarkupString(NormalizeContent(await http.GetStringAsync(privacyUrlPath)));
        CurrentTermsDigest = DeterministicHash.ComputeHash(termsMarkup.Value);
        CurrentPrivacyDigest = DeterministicHash.ComputeHash(privacyMarkup.Value);
        if (CurrentTermsDigest != AppConfig.ExpectedTermsDigest)
        {
            logger.LogError($"CurrentTermsDigest {CurrentTermsDigest} does not match expected {AppConfig.ExpectedTermsDigest}.  Needs updating!");
            await Task.Delay(10000); // Pause to ensure developer sees the error in logs);
        }
        if (CurrentPrivacyDigest != AppConfig.ExpectedPrivacyDigest)
        {
            logger.LogError($"CurrentPrivacyDigest {CurrentPrivacyDigest} does not match expected {AppConfig.ExpectedPrivacyDigest}  Needs updating!");
            await Task.Delay(10000); // Pause to ensure developer sees the error in logs);
        }
    }


    /// <summary>
    /// Reads the extension context from globalThis.__EXT_CONTEXT__ set in the HTML page.
    /// Sets AppContext to the mapped ContextType enum value (TAB, POPUP, SIDEPANEL) or null if not set/unknown.
    /// </summary>
    private async Task ReadAppContextAsync()
    {
        try
        {
            var globalThis = new GlobalThisBinding(jsRuntimeAdapter);
            var hasCtx = await globalThis.HasAsync("__EXT_CONTEXT__");
            if (hasCtx)
            {
                var ctx = await globalThis.GetAsync<ExtContext>("__EXT_CONTEXT__");
                AppContext = MapStringToContextType(ctx?.Type);
                logger.LogInformation("AppContext: {ctx}", AppContext?.ToString() ?? "null");
            }
            else
            {
                logger.LogWarning("globalThis.__EXT_CONTEXT__ not found, AppContext will be null");
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to read AppContext from globalThis.__EXT_CONTEXT__");
        }
    }

    /// <summary>
    /// Maps the string context type from HTML to the WebExtensions.Net.Runtime.ContextType enum.
    /// </summary>
    private static ContextType? MapStringToContextType(string? contextString)
    {
        return contextString?.ToUpperInvariant() switch
        {
            "TAB" => ContextType.TAB,
            "POPUP" => ContextType.POPUP,
            "SIDEPANEL" => ContextType.SIDEPANEL,
            "OPTIONS" => ContextType.TAB, // OPTIONS page runs in a tab context
            _ => null
        };
    }

    // Normalize content to ensure consistent hashing across machines with different Git line ending settings
    private static string NormalizeContent(string content)
    {
        if (string.IsNullOrEmpty(content))
        {
            return content;
        }
        // Remove BOM if present, normalize CRLF to LF
        return content.TrimStart('\uFEFF').Replace("\r\n", "\n");
    }

    public async ValueTask DisposeAsync()
    {
        this.UnsubscribeFromAppCache();
        await appPortService.DisposeAsync();
        GC.SuppressFinalize(this);
    }
}

@if (!_isInitialized)
{
    // TODO P3 Comment in/out for debugging startup time
    @*
    *@
    <MudThemeProvider />
    <MudContainer Class="d-flex align-center justify-center" Style="height: 100vh;">
        <MudProgressCircular Indeterminate="true" />
    </MudContainer>

}
else
{
    <Router AppAssembly="@typeof(Program).Assembly">
        <Found Context="routeData">
            <PageTitle>@AppConfig.ProductName</PageTitle>
            <RouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)" />
        </Found>
        <NotFound>
            <PageTitle>@AppConfig.ProductName</PageTitle>
            <LayoutView>
                <h1>Page not found</h1>
                <p role="alert">Sorry, there's nothing at this address</p>
            </LayoutView>
        </NotFound>
    </Router>
}
