@inherits LayoutComponentBase
@using Extension.Services.Storage

@using Extension.Pages
@using System.Reactive.Linq

@inject HttpClient http
@inject IJSRuntime js
@inject NavigationManager navManager
@inject IStorageService storageService
@inject ISnackbar snackbar
@inject ILogger<BaseLayout> logger
@inject ISignifyClientService signifyClientService
@inject AppCache appCache
@inject IUserActivityService userActivityService

@implements IAsyncDisposable

<!-- Note that @Body and other body content will be provided by specialized layouts inheriting from this BaseLayout -->
@code {
    protected Timer? appBarRefreshTimer;

    // Session timeout properties - available to all layouts
    protected TimeSpan SessionDurationRemaining => appCache.MyPasscodeModel.SessionExpirationUtc - DateTime.UtcNow;

    // When session is unlocked and about to expire, provide countdown Text that alternates between two color Styles
    protected (string Text, string Style) TimeoutText => (
            appCache.IsAuthenticated &&
            (int)SessionDurationRemaining.TotalSeconds < AppConfig.DisplaySessionExpirationAtSecondsRemaining &&
            (int)SessionDurationRemaining.TotalSeconds >= 1)
            ? (DateTime.UtcNow.Second % 2) == 0 ? ($"Timeout in {SessionDurationRemaining.Seconds:D}", "color:var(--mud-palette-warning);")
              : ($"Timeout in {SessionDurationRemaining.Seconds:D}", "color:var(--mud-palette-primary);")
            : ("", "");

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        // Subscribe to AppCache changes - will trigger StateHasChanged when state updates
        await this.SubscribeToAppCache(appCache, HandleAppCacheChanged);

        CreateAppBarRefreshTimer();

        // Start user activity detection if session is unlocked
        if (appCache.IsSessionUnlocked) {
            await userActivityService.StartListeningAsync();
        }
    }

    protected virtual async Task HandleAppCacheChanged()
    {
        // If we're on a page that requires auth (unlocked), and we're no longer authenticated, navigate to IndexPage for redirection, e.g. to UnlockPage
        if (!appCache.IsAuthenticated) {
            if (!(AppConfig.PagesNotRequiringAuth.Contains("/" + navManager.ToBaseRelativePath(navManager.Uri))))
            {
                logger.LogInformation("HandleAppCacheChanged: Navigating to IndexPage since no longer authenticated");
                navManager.NavigateTo(AppConfig.RouteToIndex);
                return;
            }
        }

        // Start/stop user activity detection based on session state
        if (appCache.IsSessionUnlocked && !userActivityService.IsListening) {
            await userActivityService.StartListeningAsync();
        }
        else if (!appCache.IsSessionUnlocked && userActivityService.IsListening) {
            userActivityService.StopListening();
        }

        StateHasChanged();
    }

    protected void CreateAppBarRefreshTimer()
    {
        appBarRefreshTimer = new Timer(
            callback: (_) =>
            {
                // Periodically trigger a UI update of layout components only when helpful and necessary,
                // such as showing a timeout countdown when session is about to expire.
                // Note: the actual session expiration handling is done elsewhere. Search for various places of storage.clear of session storage.
                if (appCache.IsSessionNotExpired &&
                    (appCache.MyPasscodeModel.SessionExpirationUtc - DateTime.UtcNow).Seconds < AppConfig.DisplaySessionExpirationAtSecondsRemaining)
                {
                    // logger.LogInformation("RestartOrExtendAppBarUpdateTime");
                    InvokeAsync(StateHasChanged);
                }
            },
            state: null,
            dueTime: TimeSpan.FromSeconds(1),
            period: TimeSpan.FromSeconds(1));
    }

    public virtual async ValueTask DisposeAsync()
    {
        this.UnsubscribeFromAppCache();
        appBarRefreshTimer?.Dispose();
        userActivityService.StopListening();
        GC.SuppressFinalize(this);
    }
}
