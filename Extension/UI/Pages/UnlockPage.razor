@page "/Unlock.html"
@layout Layouts.MainLayout
@using Extension.Services
@using Extension.Services.Storage
@using Extension.Models.Storage
@using Extension.Utilities

@using Microsoft.AspNetCore.Components.WebAssembly.Hosting
@using static System.Net.WebRequestMethods

@inject IStorageService storageService
@inject ILogger<UnlockPage> logger
@inject HttpClient http
@inject NavigationManager navManager
@inject IJSRuntime js
@inject ISignifyClientService signifyClientService
@inject ISnackbar snackbar
@inject IWebExtensionsApi webExtensionsApi
@inject IWebauthnService webauthnService
@inject AppCache appCache // Non-reactive here unless/until SubscribeToAppCache() is added in OnInitializedAsync
@inject SessionManager sessionManager

@code {
    // fields
    MudForm? form;
    string[] errors = { };
    PasscodeFormModel unlockPasscodeModel = new PasscodeFormModel();
    MudTextField<string>? passcodeField;
    MudButton? unlockWithPasskeyButton;
    string openWalletError = string.Empty;
    // KeriaConnectConfig keriaConnectConfig = new();
    private string taglineText = taglineAlternatives[0];
    private static string[] taglineAlternatives =
    {
// authentic
"authentically yours",
"authentic authority",
"serious about authenticity",

// secure
"secure by design",
"security first",
"secure and authentic",
"secure your digital self",
"secure interactions",
"secure and verifiable",

// keys
"your keys for your identity",
"keys at the edge",

// proof
"you have the proof",
"the power to prove",
"provable identity",
"proof beyond borders",
"challenge me",

// credentials
"credentialed",

// provenance
"provenance matters",
"credentials rooted in trust",

// architecture
"zero trust architecture",
"decentralized keys & trustworthy credentials",

// org
"organizational identity",

// trust
"trustworty interactions",
"trusted & verifiable",
"trusted digital identity",
"trustworthy and secure",

// verifiable
"verifiable by design",
"verifiable credentials",
"verifiable and trustworthy",
"verifiable and secure",

// identity
"identity without borders"
};

    // properties
    StoredPasskeys StoredPasskeys { get; set; } = new StoredPasskeys();
    bool isValid { get; set; }

    // reactive properties
    string NumberPasskeysLabel => StoredPasskeys.Passkeys.Count switch
    {
        0 => "No passkeys created",
        1 => "1 passkey available",
        _ => $"{StoredPasskeys.Passkeys.Count} passkeys available"
    };
    bool CanUsePasskey => StoredPasskeys.Passkeys.Any();
    bool IsPasskeyUsePreferred => appCache.MyPreferences.IsPasskeyUsePreferred;
    bool ShouldUsePasskey => CanUsePasskey && IsPasskeyUsePreferred;
    string TimeoutDuration => appCache.MyPreferences.InactivityTimeoutMinutes switch
    {
        0.5f => "30 seconds",
        1 => "1 minute",
        _ => $"{appCache.MyPreferences.InactivityTimeoutMinutes} minutes"
    };
    string TimeoutNotice => "locked after " + TimeoutDuration + " of inactivity";


    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation("OnInitializedAsync");

        await this.SubscribeToAppCache(appCache, async () => await InvokeAsync(StateHasChanged));

        // pick a random tagline
        var rnd = new Random();
        taglineText = taglineAlternatives[rnd.Next(taglineAlternatives.Length)];
    }

    protected override async Task OnParametersSetAsync()
    {
        // logger.LogInformation("OnParametersSetAsync");
        var getPasskeysResult = await webauthnService.GetStoredPasskeysAsync();
        if (getPasskeysResult.IsSuccess)
        {
            StoredPasskeys = getPasskeysResult.Value;
        }
    }

    protected override async Task OnAfterRenderAsync(bool isFirstRender)
    {
        // logger.LogInformation("OnAfterRenderAsync");
        if (ShouldUsePasskey)
        {
            if (unlockWithPasskeyButton is not null)
            {
                await unlockWithPasskeyButton.FocusAsync();
            }
        }
        else if (passcodeField is not null)
        {
            await passcodeField.FocusAsync();
        }
    }

    async Task SetIsPasskeyUsePreferred(bool isPasskeyUsePreferred)
    {
        throwIfNotConfigured();
        await storageService.SetItem<Preferences>(appCache.MyPreferences with
        {
            IsPasskeyUsePreferred = isPasskeyUsePreferred
        }, StorageArea.Local);
        if (isPasskeyUsePreferred)
        {
            await UnlockWithPasskey();
        }
    }

    async Task SelectAllText(Microsoft.AspNetCore.Components.Web.FocusEventArgs _)
    {
        // await Task.Delay(100); // minor delay to ensure the focus event completes
        if (passcodeField is not null)
            await passcodeField.SelectAsync();
    }

    async Task HandleKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter")
        {
            await HandleUnlock();
        }
    }

    async Task UnlockWithPasskey()
    {
        throwIfNotConfigured();
        var passcodeRes = await webauthnService.AuthenticateAndDecryptPasscodeAsync();
        if (passcodeRes.IsFailed)
        {
            snackbar.Add("Passkey verification unsuccessful or canceled", Severity.Warning);
            return;
        }
        await UnlockWithPasscode(passcodeRes.Value);
        return;
    }

    async Task HandleUnlock()
    {
        throwIfNotConfigured();
        if (unlockPasscodeModel.Passcode is not null)
            await UnlockWithPasscode(unlockPasscodeModel.Passcode);
    }

    class PasscodeFormModel
    {
        [Required]
        [StringLength(21, ErrorMessage = "Passcode must be 21 characters", MinimumLength = 21)]
        [DataType(DataType.Password)]
        public string Passcode { get; set; } = "";
    }

    void throwIfNotConfigured()
    {
        if (!appCache.IsConfigured)
        {
            throw new InvalidOperationException("KERI Auth is not configured");
        }
    }

    async Task UnlockWithPasscode(string password)
    {
        throwIfNotConfigured();
        logger.LogInformation("UnlockWithPasscode...");

        // precondition: the app must be in expected config state to unlock
        if (!appCache.IsKeriaConfigValidated)
        {
            throw new InvalidOperationException("KERI Auth configuration is not validated");
        }
        // clear anything left over in session storage from previous session (but preserve BwReadyState)
        await sessionManager.ClearKeriaSessionRecordsAsync();

        openWalletError = String.Empty;

        if (string.IsNullOrEmpty(password) || password.Length != 21)
        {
            snackbar.Add("Invalid passcode. Should be 21 characters.", Severity.Error);
            return;
        }

        if (DeterministicHash.ComputeHash(password) == appCache.MyKeriaConnectConfig.PasscodeHash)
        {
            // Store passcode and session expiry time in session storage atomically
            {
                var sessionExpiry = DateTime.UtcNow.AddMinutes(appCache.MyPreferences.InactivityTimeoutMinutes);
                var storeResult = await storageService.SetItem<PasscodeModel>(
                new PasscodeModel
                {
                    Passcode = password,
                    SessionExpirationUtc = sessionExpiry
                },
                StorageArea.Session
                );
                if (storeResult.IsFailed)
                {
                    logger.LogError("Failed to store passcode: {Errors}", string.Join(", ", storeResult.Errors));
                    snackbar.Add("Failed to store session credentials", Severity.Error);
                    return;
                }
                await appCache.WaitForAppCache([() => appCache.MyPasscodeModel.Passcode == password]);
                // Note: SessionManager will detect PasscodeModel change and schedule alarm
            }

            // logger.LogWarning("returned from Authenticate. pausing...");
            if (appCache.MyKeriaConnectConfig.AdminUrl is null)
            {
                throw new IndexOutOfRangeException("KERI Agent AdminUrl is not configured");
            }
            // expect navigation to ConnectingPage via Index
            navManager.NavigateTo(Routes.PathFor<Index>());
            return;
        }
        else
        {
            openWalletError = "KERI Auth was not configured with this passcode on this browser profile.";
            snackbar.Add(openWalletError, Severity.Error);
            await passcodeField!.Clear();
            await passcodeField!.SelectAsync();
            return;
        }
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    <div class="d-flex gap-3 bt-main" style="justify-content:center;">
        <MudStack Class="d-flex justify-center pa-0" Style="text-align:center; flex-direction: column;">
            <MudStack Style="flex: 1; display:flex; justify-content: center; align-items: center;">
                <MudImage Style="align-self:center;" Fluid="true" Width="190" Class="mx-11" Src="/images/humans_1.png">
                </MudImage>
                <MudText Typo="Typo.h5">
                    <span style="font-weight:bold; font-variant: small-caps; font-size:larger;">Keri Auth</span>
                    <br />
                    <span style="font-style:italic; font-size:initial;">@taglineText</span>
                </MudText>
            </MudStack>
            <MudStack Style="justify-content: end; min-height:3.429rem; flex-shrink: 0; align-self: stretch;" Class="gap-0">
                @if (ShouldUsePasskey)
                {
                    <MudText>
                        @NumberPasskeysLabel
                    </MudText>
                }
                else // passcode
                {
                    <MudForm @ref="form" @bind-IsValid="@isValid" @bind-Errors="@errors" Style="height: 5.714rem;">
                        <MudTextField Label="Passcode" @ref="passcodeField" OnKeyDown="@HandleKeyDown"
                                      InputType="InputType.Password" @bind-Value="@unlockPasscodeModel.Passcode" HelperText="&nbsp;"
                                      ErrorText="&nbsp;" For="@(() => unlockPasscodeModel.Passcode)" Immediate="true"
                                      @onfocus="SelectAllText" />
                    </MudForm>
                }
                <MudText Class="pt-3" Style="color: var(--mud-palette-action-disabled);">@TimeoutNotice</MudText>
            </MudStack>
        </MudStack>
    </div>

    <MudStack Row="true" class="bt-button-tray">
        <MudSpacer />
        @if (ShouldUsePasskey)
        {
            <MudButton Variant="Variant.Filled" Class="bt-button-wrap" Color="Color.Secondary"
                       OnClick="async () => await SetIsPasskeyUsePreferred(false)">
                Use passcode
            </MudButton>
            <MudButton @ref="unlockWithPasskeyButton" Disabled="!CanUsePasskey" Class="bt-button-wrap"
                       Variant="Variant.Filled" Color="Color.Primary" OnClick="async () => await UnlockWithPasskey()">
                Unlock
            </MudButton>
        }
        else
        {
            @if (CanUsePasskey)
            {
                <MudButton Class="bt-button-wrap" Variant="Variant.Filled" Color="Color.Secondary"
                           OnClick="() => SetIsPasskeyUsePreferred(true)">
                    Use Passkey
                </MudButton>
            }
            <MudButton Disabled="@(!isValid || unlockPasscodeModel.Passcode.Length != 21)" Class="bt-button-wrap"
                       Variant="Variant.Filled" Color="Color.Primary" OnClick="async () => await HandleUnlock()">
                Unlock
            </MudButton>
        }
    </MudStack>
</div>
