@page "/Unlock.html"
@layout Layouts.MainLayout
@using Extension.Models
@using Extension.Services
@using Extension.Services.Storage
@using Extension.Models.Storage
@using Extension.Utilities
@using Extension.Helper

@using Microsoft.AspNetCore.Components.WebAssembly.Hosting
@using static System.Net.WebRequestMethods

@inject IStorageService storageService
@inject ILogger<UnlockPage> logger
@inject HttpClient http
@inject NavigationManager navManager
@inject IJSRuntime js
@inject ISnackbar snackbar
@inject IWebExtensionsApi webExtensionsApi
@inject IWebauthnService webauthnService
@inject AppCache appCache // Non-reactive here unless/until SubscribeToAppCache() is added in OnInitializedAsync
@inject SessionManager sessionManager

@code {
    // fields
    MudForm? form;
    string[] errors = { };
    PasscodeFormModel unlockPasscodeModel = new PasscodeFormModel();
    MudTextField<string>? passcodeField;
    MudTextField<string>? recoveryWordField;
    MudButton? unlockWithPasskeyButton;
    MudButton? recoveryUnlockButton;
    string openWalletError = string.Empty;
    // KeriaConnectConfig keriaConnectConfig = new();
    private string taglineText = taglineAlternatives[0];

    // Recovery phrase state
    private bool _isRecoveryMode = false;
    private string _currentWordInput = "";
    private List<string> _enteredWords = new();
    private bool _recoveryPhraseValid = false;
    private string _recoveryError = "";
    private const int RequiredWordCount = 18;

    // KERIA config selection
    private const string ManageKeriaConfigsValue = "__MANAGE__";
    private string _selectedKeriaConfigDigest = "";
    private List<(string Digest, string Alias)> _availableKeriaConfigItems = new();
    private Uri? _initialUri;
    private static string[] taglineAlternatives =
    {
// authentic
"authentically yours",
"authentic authority",
"serious about authenticity",

// secure
"secure by design",
"security first",
"secure and authentic",
"secure your digital self",
"secure interactions",
"secure and verifiable",

// keys
"your keys for your identity",
"keys at the edge",

// proof
"you have the proof",
"the power to prove",
"provable identity",
"proof beyond borders",
"challenge me",

// credentials
"credentialed",

// provenance
"provenance matters",
"credentials rooted in trust",

// architecture
"zero trust architecture",
"decentralized keys & trustworthy credentials",

// org
"organizational identity",

// trust
"trustworty interactions",
"trusted & verifiable",
"trusted digital identity",
"trustworthy and secure",

// verifiable
"verifiable by design",
"verifiable credentials",
"verifiable and trustworthy",
"verifiable and secure",

// identity
"identity without borders"
};

    // properties
    StoredPasskeys StoredPasskeys { get; set; } = new StoredPasskeys();
    bool isValid { get; set; }
    int _relevantPasskeyCount = 0; // Cached count of passkeys matching selected KERIA config

    // reactive properties
    string NumberPasskeysLabel => _relevantPasskeyCount switch
    {
        0 => "No passkeys registered",
        1 => "1 passkey registered",
        _ => $"{_relevantPasskeyCount} passkeys registered"
    };
    bool CanUsePasskey => _relevantPasskeyCount > 0;
    bool IsPasskeyUsePreferred => appCache.MyPreferences.IsPasskeyUsePreferred;
    bool ShouldUsePasskey => CanUsePasskey && IsPasskeyUsePreferred;
    string TimeoutDuration => appCache.MyPreferences.InactivityTimeoutMinutes switch
    {
        0.5f => "30 seconds",
        1 => "1 minute",
        _ => $"{appCache.MyPreferences.InactivityTimeoutMinutes} minutes"
    };
    string TimeoutNotice => "locked after " + TimeoutDuration + " of inactivity";

    // Recovery phrase reactive properties
    IEnumerable<string> MatchingWords => string.IsNullOrEmpty(_currentWordInput) || _currentWordInput.Length < 3
        ? Enumerable.Empty<string>()
        : Bip39EnglishWordList.Words
            .Where(w => w.StartsWith(_currentWordInput.ToLowerInvariant()))
            .Take(6);
    bool HasMatchingWords => MatchingWords.Any();
    bool CanUndo => _enteredWords.Count > 0;
    bool IsRecoveryComplete => _enteredWords.Count == RequiredWordCount;

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation("OnInitializedAsync");

        // Capture initial URI for restart after config change
        _initialUri = new Uri(navManager.Uri);

        await this.SubscribeToAppCache(appCache);

        // Wait for required appCache data to be loaded from storage before proceeding
        var dataLoaded = await appCache.WaitForAppCache([
            () => appCache.MyPreferences.IsStored,
            () => appCache.MyKeriaConnectConfigs.IsStored
        ]);
        if (!dataLoaded) {
            logger.LogError("Required appCache data failed to load within timeout");
            throw new InvalidOperationException("Required data did not load in time");
        }

        // Initialize KERIA config list - compute digests once at init time to avoid re-computation on each render
        var configs = appCache.GetAvailableKeriaConfigs();
        _availableKeriaConfigItems = configs
            .Select(c => {
                var digestResult = KeriaConnectionDigestHelper.Compute(c);
                return (Digest: digestResult.IsSuccess ? digestResult.Value : "", Alias: c.Alias ?? "(unnamed)");
            })
            .Where(item => !string.IsNullOrEmpty(item.Digest))
            .ToList();
        _selectedKeriaConfigDigest = appCache.MyPreferences.KeriaPreference.SelectedKeriaConnectionDigest ?? "";

        // pick a random tagline
        var rnd = new Random();
        taglineText = taglineAlternatives[rnd.Next(taglineAlternatives.Length)];
    }

    private bool _isChangingConfig = false;

    private async Task OnKeriaConfigDigestChanged(string digest)
    {
        if (_isChangingConfig) return; // Prevent re-entry during config change

        if (digest == ManageKeriaConfigsValue)
        {
            navManager.NavigateTo(Routes.PathFor<ManageKeriAgentServicesPage>());
            return;
        }

        if (_selectedKeriaConfigDigest != digest)
        {
            _isChangingConfig = true;
            _selectedKeriaConfigDigest = digest;
            UpdateRelevantPasskeyCount(); // Update passkey count for new selection

            var prefs = appCache.MyPreferences;
            var newKeriaPreference = prefs.KeriaPreference with {
                SelectedKeriaConnectionDigest = digest
            };
            await storageService.SetItem<Preferences>(prefs with {
                KeriaPreference = newKeriaPreference
            });

            snackbar.Add("Configuration changed. App will restart in 3 seconds.", Severity.Warning);
            await Task.Delay(3000);
            navManager.NavigateTo(_initialUri?.AbsolutePath ?? "/index.html", true);
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // logger.LogInformation("OnParametersSetAsync");
        var getPasskeysResult = await webauthnService.GetStoredPasskeysAsync();
        if (getPasskeysResult.IsSuccess)
        {
            StoredPasskeys = getPasskeysResult.Value;
            UpdateRelevantPasskeyCount();
        }
    }

    /// <summary>
    /// Updates the cached count of passkeys matching the currently selected KERIA connection.
    /// Called when passkeys are loaded or when the selected KERIA config changes.
    /// </summary>
    private void UpdateRelevantPasskeyCount()
    {
        _relevantPasskeyCount = StoredPasskeys.Passkeys
            .Count(p => p.KeriaConnectionDigest == _selectedKeriaConfigDigest);
    }

    protected override async Task OnAfterRenderAsync(bool isFirstRender)
    {
        // logger.LogInformation("OnAfterRenderAsync");
        if (_isRecoveryMode)
        {
            if (_recoveryPhraseValid && recoveryUnlockButton is not null)
            {
                await recoveryUnlockButton.FocusAsync();
            }
            else if (recoveryWordField is not null && !IsRecoveryComplete)
            {
                await recoveryWordField.FocusAsync();
            }
        }
        else if (ShouldUsePasskey)
        {
            if (unlockWithPasskeyButton is not null)
            {
                await unlockWithPasskeyButton.FocusAsync();
            }
        }
        else if (passcodeField is not null)
        {
            await passcodeField.FocusAsync();
        }
    }

    async Task SetIsPasskeyUsePreferred(bool isPasskeyUsePreferred)
    {
        throwIfNotConfigured();
        await storageService.SetItem<Preferences>(appCache.MyPreferences with
        {
            IsPasskeyUsePreferred = isPasskeyUsePreferred
        }, StorageArea.Local);
        if (isPasskeyUsePreferred)
        {
            await UnlockWithPasskey();
        }
    }

    async Task SelectAllText(Microsoft.AspNetCore.Components.Web.FocusEventArgs _)
    {
        // await Task.Delay(100); // minor delay to ensure the focus event completes
        if (passcodeField is not null)
            await passcodeField.SelectAsync();
    }

    async Task HandleKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter")
        {
            await HandleUnlock();
        }
    }

    async Task UnlockWithPasskey()
    {
        throwIfNotConfigured();
        var passcodeRes = await webauthnService.AuthenticateAndDecryptPasscodeAsync();
        if (passcodeRes.IsFailed)
        {
            snackbar.Add("Passkey verification unsuccessful or canceled", Severity.Warning);
            return;
        }
        await UnlockWithPasscode(passcodeRes.Value);
        return;
    }

    async Task HandleUnlock()
    {
        throwIfNotConfigured();
        if (unlockPasscodeModel.Passcode is not null)
            await UnlockWithPasscode(unlockPasscodeModel.Passcode);
    }

    class PasscodeFormModel
    {
        [Required]
        [StringLength(21, ErrorMessage = "Passcode must be 21 characters", MinimumLength = 21)]
        [DataType(DataType.Password)]
        public string Passcode { get; set; } = "";
    }

    void throwIfNotConfigured()
    {
        if (!appCache.IsConfigured)
        {
            throw new InvalidOperationException("KERI Auth is not configured");
        }
    }

    async Task UnlockWithPasscode(string password)
    {
        throwIfNotConfigured();
        logger.LogInformation("UnlockWithPasscode...");

        // precondition: the app must be in expected config state to unlock
        if (!appCache.IsKeriaConfigValidated)
        {
            throw new InvalidOperationException("KERI Auth configuration is not validated");
        }
        // clear anything left over in session storage from previous session (but preserve BwReadyState)
        await sessionManager.ClearKeriaSessionRecordsAsync();

        openWalletError = String.Empty;

        if (string.IsNullOrEmpty(password) || password.Length != 21)
        {
            snackbar.Add("Invalid passcode. Should be 21 characters.", Severity.Error);
            return;
        }

        if (DeterministicHash.ComputeHash(password) == appCache.MyKeriaConnectConfig.PasscodeHash)
        {
            // Store passcode and session expiry time in session storage atomically
            {
                var sessionExpiry = DateTime.UtcNow.AddMinutes(appCache.MyPreferences.InactivityTimeoutMinutes);
                var storeResult = await storageService.SetItem<PasscodeModel>(
                new PasscodeModel
                {
                    Passcode = password,
                    SessionExpirationUtc = sessionExpiry
                },
                StorageArea.Session
                );
                if (storeResult.IsFailed)
                {
                    logger.LogError("Failed to store passcode: {Errors}", string.Join(", ", storeResult.Errors));
                    snackbar.Add("Failed to store session credentials", Severity.Error);
                    return;
                }
                await appCache.WaitForAppCache([() => appCache.MyPasscodeModel.Passcode == password]);
                // Note: SessionManager will detect PasscodeModel change and schedule alarm
            }

            // logger.LogWarning("returned from Authenticate. pausing...");
            if (appCache.MyKeriaConnectConfig.AdminUrl is null)
            {
                throw new IndexOutOfRangeException("KERIA AdminUrl is not configured");
            }
            // expect navigation to ConnectingPage via Index
            navManager.NavigateTo(Routes.PathFor<Index>());
            return;
        }
        else
        {
            openWalletError = "KERI Auth was not configured with this passcode on this browser profile.";
            snackbar.Add(openWalletError, Severity.Error);
            await passcodeField!.Clear();
            await passcodeField!.SelectAsync();
            return;
        }
    }

    // Recovery phrase methods
    void EnterRecoveryMode()
    {
        _isRecoveryMode = true;
        _enteredWords.Clear();
        _currentWordInput = "";
        _recoveryPhraseValid = false;
        _recoveryError = "";
        StateHasChanged();
    }

    void ExitRecoveryMode()
    {
        _isRecoveryMode = false;
        _enteredWords.Clear();
        _currentWordInput = "";
        _recoveryPhraseValid = false;
        _recoveryError = "";
        StateHasChanged();
    }

    void OnWordInputChanged(string value)
    {
        _currentWordInput = value;

        // Check for pasted multi-word phrase
        if (!string.IsNullOrEmpty(value) && value.Contains(' '))
        {
            HandlePastedPhrase(value);
            return;
        }

        StateHasChanged();
    }

    void HandlePastedPhrase(string pastedText)
    {
        var words = pastedText
            .ToLowerInvariant()
            .Split(new[] { ' ', '\t', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)
            .Where(w => Bip39EnglishWordList.Words.Contains(w))
            .Take(RequiredWordCount)
            .ToList();

        if (words.Count > 0)
        {
            // Replace all existing words with pasted words
            _enteredWords = words;
            _currentWordInput = "";
            ValidateRecoveryPhrase();
        }
    }

    async Task HandleRecoveryWordKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter" && !string.IsNullOrWhiteSpace(_currentWordInput))
        {
            var word = _currentWordInput.ToLowerInvariant().Trim();
            if (Bip39EnglishWordList.Words.Contains(word))
            {
                AddWord(word);
            }
            else if (MatchingWords.Count() == 1)
            {
                // Auto-complete if only one match
                AddWord(MatchingWords.First());
            }
        }
    }

    void AddWord(string word)
    {
        if (_enteredWords.Count >= RequiredWordCount) return;

        _enteredWords.Add(word);
        _currentWordInput = "";
        ValidateRecoveryPhrase();
    }

    void UndoLastWord()
    {
        if (_enteredWords.Count > 0)
        {
            _enteredWords.RemoveAt(_enteredWords.Count - 1);
            _recoveryPhraseValid = false;
            _recoveryError = "";
            StateHasChanged();
        }
    }

    void ValidateRecoveryPhrase()
    {
        _recoveryError = "";
        _recoveryPhraseValid = false;

        if (_enteredWords.Count != RequiredWordCount)
        {
            return;
        }

        try
        {
            // Convert mnemonic to passcode
            var passcode = Bip39MnemonicConverter.ConvertMnemonicToPasscode(_enteredWords.ToArray());

            // Check hash against stored config
            var computedHash = DeterministicHash.ComputeHash(passcode);
            if (computedHash == appCache.MyKeriaConnectConfig.PasscodeHash)
            {
                _recoveryPhraseValid = true;
                _recoveryError = "";
            }
            else
            {
                _recoveryPhraseValid = false;
                _recoveryError = "Cannot unlock with this recovery phrase per the stored configuration.";
            }
        }
        catch (ArgumentException ex)
        {
            _recoveryPhraseValid = false;
            _recoveryError = $"Invalid recovery phrase: {ex.Message}";
        }
    }

    async Task HandleRecoveryUnlock()
    {
        if (!_recoveryPhraseValid || _enteredWords.Count != RequiredWordCount)
        {
            return;
        }

        try
        {
            var passcode = Bip39MnemonicConverter.ConvertMnemonicToPasscode(_enteredWords.ToArray());
            await UnlockWithPasscode(passcode);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to unlock with recovery phrase");
            snackbar.Add("Failed to unlock with recovery phrase", Severity.Error);
        }
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    @if (_isRecoveryMode)
    {
        <!-- Recovery Phrase Mode -->
        <MudStack Class="bt-main">
            <div class="bt-main-inside-scroll">
                <MudText Class="bt-page-title">Unlock with Recovery Phrase</MudText>

                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-2">
                    Enter your 18-word recovery phrase to unlock. Type at least 3 characters to see suggestions.
                </MudText>

                <!-- Word input with Undo button -->
                <MudStack Row="true" AlignItems="AlignItems.Center" Class="mt-4">
                    <MudTextField @ref="recoveryWordField"
                                  Label="@($"Word {_enteredWords.Count + 1} of {RequiredWordCount}")"
                                  Value="_currentWordInput"
                                  ValueChanged="@((string v) => OnWordInputChanged(v))"
                                  OnKeyDown="HandleRecoveryWordKeyDown"
                                  Immediate="true"
                                  Disabled="@IsRecoveryComplete"
                                  Style="flex: 1;"
                                  Placeholder="Type a word..." />
                    <MudTooltip Text="Undo last word">
                        <MudIconButton Icon="@Icons.Material.Filled.Undo"
                                       Color="Color.Secondary"
                                       Disabled="@(!CanUndo)"
                                       OnClick="UndoLastWord" />
                    </MudTooltip>
                </MudStack>

                <!-- Word suggestions -->
                @if (HasMatchingWords && !IsRecoveryComplete)
                {
                    <MudStack Row="true" Class="mt-2" Style="flex-wrap: wrap; gap: 0.5rem;">
                        @foreach (var word in MatchingWords)
                        {
                            <MudChip T="string" Color="Color.Primary" Variant="Variant.Outlined"
                                     OnClick="() => AddWord(word)"
                                     Style="cursor: pointer;">
                                @word
                            </MudChip>
                        }
                    </MudStack>
                }

                <!-- Entered words grid -->
                @if (_enteredWords.Any())
                {
                    <MudPaper Class="mt-4 pa-3" Elevation="1">
                        <MudGrid Spacing="2">
                            @for (int i = 0; i < _enteredWords.Count; i++)
                            {
                                var wordNumber = i + 1;
                                var word = _enteredWords[i];
                                <MudItem xs="4">
                                    <MudChip T="string" Color="Color.Default" Variant="Variant.Outlined"
                                             Style="width: 100%; justify-content: flex-start; font-family: monospace;">
                                        <span style="color: var(--mud-palette-text-secondary); min-width: 1.5rem; display: inline-block;">@wordNumber.</span>
                                        @word
                                    </MudChip>
                                </MudItem>
                            }
                        </MudGrid>
                    </MudPaper>
                }

                <!-- Validation status -->
                @if (IsRecoveryComplete)
                {
                    @if (_recoveryPhraseValid)
                    {
                        <MudAlert Severity="Severity.Success" Class="mt-3" Dense="true">
                            <MudStack Row="true" AlignItems="AlignItems.Center">
                                <MudIcon Icon="@Icons.Material.Filled.CheckCircle" />
                                <MudText>Recovery phrase verified. Click Unlock to continue.</MudText>
                            </MudStack>
                        </MudAlert>
                    }
                    else if (!string.IsNullOrEmpty(_recoveryError))
                    {
                        <MudAlert Severity="Severity.Error" Class="mt-3" Dense="true">
                            <MudStack Row="true" AlignItems="AlignItems.Center">
                                <MudIcon Icon="@Icons.Material.Filled.Cancel" />
                                <MudText>@_recoveryError</MudText>
                            </MudStack>
                        </MudAlert>
                    }
                }
            </div>
        </MudStack>

        <MudStack Row="true" class="bt-button-tray">
            <MudButton Variant="Variant.Text" Color="Color.Secondary" OnClick="ExitRecoveryMode">
                Cancel
            </MudButton>
            <MudSpacer />
            <MudButton @ref="recoveryUnlockButton"
                       Variant="Variant.Filled" Color="Color.Primary"
                       Disabled="@(!_recoveryPhraseValid)"
                       OnClick="HandleRecoveryUnlock">
                Unlock
            </MudButton>
        </MudStack>
    }
    else
    {
        <!-- Normal Unlock Mode -->
        <div class="d-flex gap-3 bt-main" style="justify-content:center;">
            <MudStack Class="d-flex justify-center pa-0" Style="text-align:center; flex-direction: column;">
                <MudStack Style="flex: 1; display:flex; justify-content: center; align-items: center;">
                    <MudImage Style="align-self:center;" Fluid="true" Width="190" Class="mx-11" Src="/images/humans_1.png">
                    </MudImage>
                    <MudText Typo="Typo.h5">
                        <span style="font-weight:bold; font-variant: small-caps; font-size:larger;">Keri Auth</span>
                        <br />
                        <span style="font-style:italic; font-size:initial;">@taglineText</span>
                    </MudText>
                </MudStack>
                @if (appCache.MyPreferences.IsMultiKeriaConfigEnabled && appCache.MyPreferences.IsMultiKeriaOnUnlock && _availableKeriaConfigItems.Count > 0)
                {
                    <MudStack Style="justify-content: center; align-items: center;" Class="pt-3">
                        <MudSelect T="string"
                                   Label="KERIA Cloud Service"
                                   Value="@_selectedKeriaConfigDigest"
                                   ValueChanged="OnKeriaConfigDigestChanged"
                                   Variant="Variant.Outlined"
                                   Style="max-width: 18rem;">
                            @foreach (var item in _availableKeriaConfigItems)
                            {
                                <MudSelectItem Value="@item.Digest">@item.Alias</MudSelectItem>
                            }
                            <MudSelectItem Value="@ManageKeriaConfigsValue">Add/Remove KERIA Cloud Service</MudSelectItem>
                        </MudSelect>
                    </MudStack>
                }
                <MudStack Style="justify-content: end; min-height:3.429rem; flex-shrink: 0; align-self: stretch;" Class="gap-0">
                    @if (ShouldUsePasskey)
                    {
                        <MudText>
                            @NumberPasskeysLabel
                        </MudText>
                    }
                    else // passcode
                    {
                        <MudForm @ref="form" @bind-IsValid="@isValid" @bind-Errors="@errors" Style="height: 5.714rem;">
                            <MudTextField Label="Passcode" @ref="passcodeField" OnKeyDown="@HandleKeyDown"
                                          InputType="InputType.Password" @bind-Value="@unlockPasscodeModel.Passcode" HelperText="&nbsp;"
                                          ErrorText="&nbsp;" For="@(() => unlockPasscodeModel.Passcode)" Immediate="true"
                                          @onfocus="SelectAllText" />
                        </MudForm>
                    }
                    <MudText Class="pt-3" Style="color: var(--mud-palette-action-disabled);">@TimeoutNotice</MudText>
                </MudStack>
            </MudStack>
        </div>

        <MudStack Row="true" class="bt-button-tray">
            <MudButton Variant="Variant.Text" Color="Color.Secondary" OnClick="EnterRecoveryMode">
                Recover
            </MudButton>
            <MudSpacer />
            @if (ShouldUsePasskey)
            {
                <MudButton Variant="Variant.Filled" Class="bt-button-wrap" Color="Color.Secondary"
                           OnClick="async () => await SetIsPasskeyUsePreferred(false)">
                    Use Passcode
                </MudButton>
                <MudButton @ref="unlockWithPasskeyButton" Disabled="!CanUsePasskey" Class="bt-button-wrap"
                           Variant="Variant.Filled" Color="Color.Primary" OnClick="async () => await UnlockWithPasskey()">
                    Unlock with Passkey
                </MudButton>
            }
            else
            {
                @if (CanUsePasskey)
                {
                    <MudButton Class="bt-button-wrap" Variant="Variant.Filled" Color="Color.Secondary"
                               OnClick="() => SetIsPasskeyUsePreferred(true)">
                        Use Passkey
                    </MudButton>
                }
                <MudButton Disabled="@(!isValid || unlockPasscodeModel.Passcode.Length != 21)" Class="bt-button-wrap"
                           Variant="Variant.Filled" Color="Color.Primary" OnClick="async () => await HandleUnlock()">
                    Unlock
                </MudButton>
            }
        </MudStack>
    }
</div>
