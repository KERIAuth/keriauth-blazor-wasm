@page "/index.html"
@page "/indexInTab.html"
@page "/indexInPopup.html"
@page "/indexInSidePanel.html"
@using Extension.Models
@using Extension.Models.Messages.BwApp
@using Extension.Models.Messages.BwApp.Requests
@using static Extension.AppConfig

@* IndexPage (from Blazor.BrowserExtension) provides base page functionality *@
@inherits IndexPage
@layout MainLayout

@inject AppCache appCache  // Reactive: subscribes in OnInitializedAsync via SubscribeToAppCache()
@inject NavigationManager navManager
@inject ILogger<IndexPage> logger

@* 
   // TODO P2: remove this loading indicator if it is always quick.
   Intentionally empty visible content to reduce flickering during navigation.
   This page serves as the routing hub - other pages navigate here when done with their step,
   and RedirectIfNeeded() determines the next appropriate page based on app state.

    <MudContainer id="@this.GetType().Name" Class="bt-body-page" Style="background-color:red;">
        <MudText>Index.razor</MudText>
        <MudPaper Elevation="0" Style="width:100vw; height: 90vh; background-color:transparent; align-items:center; justify-content: center; display:flex;">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
        </MudPaper>
    </MudContainer>
*@

@implements IDisposable
@code {
    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation("OnInitializedAsync Index.razor");
        await base.OnInitializedAsync();
        // Subscribe to AppCache changes - will trigger RedirectIfNeeded when state updates
        // TODO P2: perf: adjust optional WaitForAppCache timeout params if needed
        await appCache.WaitForAppCache([() => appCache.IsReady]); 
        await this.SubscribeToAppCache(appCache, RedirectIfNeeded);
        await RedirectIfNeeded();
    }

    // NavigateIfNeeded navigates to newUrl only if not already on that page
    void NavigateIfNeeded(string newUrl)
    {
        if (navManager.Uri.Contains(newUrl))
        {
            return;
        }
        navManager.NavigateTo(newUrl);
    }

    // RedirectIfNeeded checks AppCache state and navigates to appropriate page,
    // ensuring the app progresses through onboarding, configuration, authentication, etc.
    async Task RedirectIfNeeded()
    {
        logger.LogInformation("RedirectIfNeeded");

        // Get pending request early for use throughout the routing logic
        var pendingRequest = appCache.NextPendingBwAppRequest;

        if (!appCache.MyOnboardState.IsWelcomed)
        {
            NavigateIfNeeded(Routes.PathFor<WelcomePage>());
            return;
        }

        // Check for update notification request before IsInstallAcknowledged check
        // This ensures user sees update info even if they haven't acknowledged previous install
        if (pendingRequest?.Type == BwAppMessageType.Values.RequestNotifyUserOfUpdate)
        {
            var updatePayload = pendingRequest.GetPayload<RequestNotifyUserOfUpdatePayload>();
            logger.LogInformation(
                "RedirectIfNeeded: Update notification request detected, requestId={RequestId}, version={Version}",
                pendingRequest.RequestId,
                updatePayload?.CurrentVersion ?? "unknown");

            NavigateIfNeeded(Routes.PathFor<NewReleasePage>());
            return;
        }

        // TODO P2 consider this check with the one above for RequestNotifyUserOfUpdate
        if (!appCache.IsInstallAcknowledged)
        {
            NavigateIfNeeded(Routes.PathFor<NewReleasePage>());
            return;
        }
        if (!appCache.IsCurrentTosAndPrivacyAgreed)
        {
            NavigateIfNeeded(Routes.PathFor<TermsPage>());
            return;
        }
        // Passing above conditions must equate to IsProductOnboarded
        if (!appCache.IsProductOnboarded)
        {
            logger.LogError("RedirectIfNeeded: Not ProductOnboarded");
            return;
        }
        if (!appCache.IsConfigured)
        {
            NavigateIfNeeded(Routes.PathFor<ConfigurePage>());
            return;
        }
        // Passing the above conditions must equate to IsInitialized
        if (!appCache.IsInitialized)
        {
            logger.LogError("RedirectIfNeeded: Not Initialized");
            return;
        }
        if (!appCache.IsSessionUnlocked)
        {
            NavigateIfNeeded(Routes.PathFor<UnlockPage>());
            return;
        }
        if (!appCache.IsAuthenticated)
        {
            logger.LogError("RedirectIfNeeded: Not Authenticated");
            return;
        }
        if (!appCache.IsIdentifierFetched)
        {
            NavigateIfNeeded(Routes.PathFor<ConnectingPage>());
            return;
        }
        // Passing the above conditions must equate to IsConnectedToKeria
        if (!appCache.IsConnectedToKeria)
        {
            logger.LogError("RedirectIfNeeded: Not ConnectedToKeria");
            return;
        }

        // Check for passkey creation offer flow (after first-time KERIA connection)
        if (App.OfferCreatePasskeyState == OfferCreatePasskeyState.Yes)
        {
            logger.LogInformation("RedirectIfNeeded: User accepted passkey offer, navigating to AddPasskey");
            App.OfferCreatePasskeyState = OfferCreatePasskeyState.InProcess;
            NavigateIfNeeded(Routes.PathFor<AddPasskeyPage>());
            return;
        }

        if (!appCache.ShowedGettingStarted)
        {
            NavigateIfNeeded(Routes.PathFor<GettingStartedPage>());
            return;
        }

        // Check for pending BW→App requests that require App UI interaction
        if (pendingRequest is not null)
        {
            var contextFilter = new ContextFilter() { ContextTypes = [ContextType.POPUP, ContextType.TAB, ContextType.SIDEPANEL] };
            var contexts = await WebExtensions.Runtime.GetContexts(contextFilter);
            var willRedirectDialog = contexts.Any(c => c.ContextType == ContextType.POPUP || c.ContextType == ContextType.SIDEPANEL);

            string? route = null;

            switch (pendingRequest.Type, willRedirectDialog)
            {
                case (BwAppMessageType.Values.RequestSelectAuthorize, true):
                    route = Routes.PathFor<RequestSignInPage>();
                    break;
                case (BwAppMessageType.Values.RequestSignHeaders, true):
                    route = Routes.PathFor<RequestSignHeadersPage>();
                    break;
                case (BwAppMessageType.Values.RequestNotifyUserOfUpdate, _):
                    route = Routes.PathFor<Index>();
                    break;
                case (BwAppMessageType.Values.RequestSignData, true):
                    route = Routes.PathFor<RequestSignDataPage>();
                    break;
                case (BwAppMessageType.Values.RequestCreateCredential, true):
                    route = Routes.PathFor<RequestCreateCredentialPage>();
                    break;
                default:
                    logger.LogInformation("RedirectIfNeeded: Unknown pending request type: {Type}, requestId={RequestId}", pendingRequest.Type, pendingRequest.RequestId);
                    route = Routes.PathFor<RequestUnknownPage>();
                    break;
            }

            if (route is not null)
            {
                logger.LogInformation(
                    "RedirectIfNeeded: Pending BW→App request detected, type={Type}, requestId={RequestId}, navigating to {Route}",
                    pendingRequest.Type, pendingRequest.RequestId, route);
                NavigateIfNeeded(route);
                return;
            }
        }

        // Fully authenticated and connected - navigate to Dashboard
        // logger.LogInformation("RedirectIfNeeded: No re-route conditions detected, navigating to Dashboard");
        NavigateIfNeeded(Routes.PathFor<DashboardPage>());
    }

    public void Dispose()
    {
        this.UnsubscribeFromAppCache();
        GC.SuppressFinalize(this);
    }
}
