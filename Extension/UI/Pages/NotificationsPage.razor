@page "/Notifications.html"
@using Extension.Models.Messages.AppBw
@using Extension.Services.SignifyService.Models
@using Extension.Services.Port
@using Extension.UI.Components
@inherits AuthenticatedPageBase
@implements IDisposable

@inject ILogger<NotificationsPage> logger
@inject IJSRuntime js
@inject ISnackbar snackbar
@inject AppCache appCache
@inject IAppBwPortService appBwPortService

@code {
    bool IsProcessing { get; set; }

    List<Notification> AllNotifications => appCache?.MyNotifications?.Items?
        .OrderByDescending(n => n.DateTime)
        .ToList() ?? [];

    int UnreadCount => AllNotifications.Count(n => !n.IsRead);

    // Filtering state
    string? FilterRoute { get; set; }
    bool? FilterReadStatus { get; set; }

    List<string> AvailableRoutes => AllNotifications
        .Select(n => n.Route)
        .Where(r => !string.IsNullOrEmpty(r))
        .Distinct()
        .OrderBy(r => r)
        .ToList();

    List<Notification> FilteredNotifications {
        get {
            IEnumerable<Notification> filtered = AllNotifications;
            if (FilterRoute is not null)
                filtered = filtered.Where(n => n.Route == FilterRoute);
            if (FilterReadStatus is not null)
                filtered = filtered.Where(n => n.IsRead == FilterReadStatus.Value);
            return filtered.ToList();
        }
    }

    bool IsFiltering => FilterRoute is not null || FilterReadStatus is not null;
    string CountLabel => IsFiltering
        ? $"({FilteredNotifications.Count} of {AllNotifications.Count})"
        : $"({AllNotifications.Count})";

    static string ElideId(string id) =>
        id.Length > 12
            ? $"{id[..6]}...{id[^4..]}"
            : id;

    static string RouteLabel(string route) => route switch {
        "/exn/ipex/grant" => "Credential Grant",
        "/exn/ipex/admit" => "Credential Admit",
        "/exn/ipex/apply" => "Credential Apply",
        "/exn/ipex/offer" => "Credential Offer",
        "/exn/ipex/agree" => "Credential Agree",
        "/multisig/iss" => "Multisig Issuance",
        "/multisig/icp" => "Multisig Inception",
        "/multisig/rot" => "Multisig Rotation",
        "/multisig/exn" => "Multisig Exchange",
        _ => route
    };

    static string RouteIcon(string route) => route switch {
        "/exn/ipex/grant" => Icons.Material.Filled.CardGiftcard,
        "/exn/ipex/admit" => Icons.Material.Filled.CheckCircle,
        "/exn/ipex/apply" => Icons.Material.Filled.Assignment,
        "/exn/ipex/offer" => Icons.Material.Filled.LocalOffer,
        "/exn/ipex/agree" => Icons.Material.Filled.Handshake,
        "/multisig/iss" => Icons.Material.Filled.GroupWork,
        "/multisig/icp" => Icons.Material.Filled.Groups,
        "/multisig/rot" => Icons.Material.Filled.RotateRight,
        "/multisig/exn" => Icons.Material.Filled.SwapHoriz,
        _ => Icons.Material.Filled.Notifications
    };

    // Mark-all-as-read state
    bool IsMarkingAll { get; set; }
    int MarkAllProgress { get; set; }
    int MarkAllTotal { get; set; }

    // Expansion state
    string? ExpandedNotificationId { get; set; }
    RecursiveDictionary? ExpandedExchangeData { get; set; }
    bool IsLoadingExchange { get; set; }
    string? ExchangeLoadError { get; set; }
    bool IsAdmitting { get; set; }

    protected override async Task OnInitializedAsync() {
        logger.LogInformation("OnInitializedAsync");
        InitializeAppCache(appCache);
        await this.SubscribeToAppCache(appCache);
    }

    async Task ToggleNotificationDetail(Notification notification) {
        if (ExpandedNotificationId == notification.Id) {
            ExpandedNotificationId = null;
            ExpandedExchangeData = null;
            ExchangeLoadError = null;
            StateHasChanged();
            return;
        }

        ExpandedNotificationId = notification.Id;
        ExpandedExchangeData = null;
        ExchangeLoadError = null;

        if (notification.ExchangeSaid is null) {
            ExchangeLoadError = "No exchange SAID available";
            StateHasChanged();
            return;
        }

        IsLoadingExchange = true;
        StateHasChanged();

        try {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestGetExchange,
                new { payload = new { said = notification.ExchangeSaid } });

            if (!response.Ok) {
                ExchangeLoadError = response.Error ?? "Failed to load exchange details";
                return;
            }

            var exchangeResult = response.Result is JsonElement jsonEl
                ? JsonSerializer.Deserialize<GetExchangeResponsePayload>(jsonEl.GetRawText(), Helper.JsonOptions.PortMessaging)
                : null;

            if (exchangeResult is not null && exchangeResult.Success && exchangeResult.Exchange is not null) {
                ExpandedExchangeData = exchangeResult.Exchange;
            }
            else {
                ExchangeLoadError = exchangeResult?.Error ?? "Unknown error loading exchange";
            }
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error fetching exchange details");
            ExchangeLoadError = "Error loading exchange details";
        }
        finally {
            IsLoadingExchange = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    async Task AdmitCredential(Notification notification) {
        if (IsAdmitting || ExpandedExchangeData is null) return;

        // KERI exchange (exn) fields: see LogExchangeDetailsOnceAsync in NotificationPollingService.cs for spec references
        RecursiveDictionary? exn = null;
        if (ExpandedExchangeData.TryGetValue("exn", out var exnVal) && exnVal?.Dictionary is RecursiveDictionary exnDict) {
            exn = exnDict;
        }

        if (exn is null) {
            snackbar.Add("Invalid exchange data structure", Severity.Error);
            return;
        }

        // Extract sender (issuer) prefix from exn.i
        exn.TryGetValue("i", out var senderVal);
        var issuerPrefix = senderVal?.StringValue;

        // Extract recipient (our AID) prefix from exn.rp
        exn.TryGetValue("rp", out var rpVal);
        var recipientPrefix = rpVal?.StringValue;

        // Look up our AID name from the prefix
        var ourAid = appCache.Aids.FirstOrDefault(a => a.Prefix == recipientPrefix);
        if (ourAid is null) {
            snackbar.Add("Could not find matching AID for this grant", Severity.Error);
            return;
        }

        if (notification.ExchangeSaid is null || issuerPrefix is null) {
            snackbar.Add("Missing exchange data for admit", Severity.Error);
            return;
        }

        IsAdmitting = true;
        StateHasChanged();

        try {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestIpexAdmit,
                new { payload = new IpexAdmitRequestPayload(ourAid.Name, issuerPrefix, notification.ExchangeSaid) },
                timeout: TimeSpan.FromMinutes(2));

            if (!response.Ok) {
                snackbar.Add($"Admit failed: {response.Error}", Severity.Error);
                return;
            }

            var admitResult = response.Result is JsonElement admitJsonEl
                ? JsonSerializer.Deserialize<IpexAdmitResponsePayload>(admitJsonEl.GetRawText(), Helper.JsonOptions.PortMessaging)
                : null;

            if (admitResult is not null && admitResult.Success) {
                snackbar.Add("Credential admitted", Severity.Success);
                if (!notification.IsRead) {
                    await MarkAsRead(notification);
                }
            }
            else {
                snackbar.Add($"Admit failed: {admitResult?.Error ?? "Unknown error"}", Severity.Error);
            }
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error during IPEX admit");
            snackbar.Add("Error admitting credential", Severity.Error);
        }
        finally {
            IsAdmitting = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    async Task MarkAsRead(Notification notification) {
        if (IsProcessing) return;
        IsProcessing = true;
        StateHasChanged();

        try {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestMarkNotification,
                new { payload = new { said = notification.Id } });

            if (!response.Ok) {
                snackbar.Add($"Failed to mark notification: {response.Error}", Severity.Error);
            }
            else {
                var notifId = notification.Id;
                await appCache.WaitForAppCache([
                    () => appCache.MyNotifications.Items.Any(n => n.Id == notifId && n.IsRead)
                ]);
                snackbar.Add("Marked as read", Severity.Info);
            }
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error marking notification as read");
            snackbar.Add("Error marking notification", Severity.Error);
        }
        finally {
            IsProcessing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    async Task DeleteNotification(Notification notification) {
        if (IsProcessing) return;
        IsProcessing = true;
        StateHasChanged();

        try {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestDeleteNotification,
                new { payload = new { said = notification.Id } });

            if (!response.Ok) {
                snackbar.Add($"Failed to delete notification: {response.Error}", Severity.Error);
            }
            else {
                var notifId = notification.Id;
                await appCache.WaitForAppCache([
                    () => !appCache.MyNotifications.Items.Any(n => n.Id == notifId)
                ]);
                snackbar.Add("Notification deleted", Severity.Info);
            }
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error deleting notification");
            snackbar.Add("Error deleting notification", Severity.Error);
        }
        finally {
            IsProcessing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    async Task MarkAllAsRead() {
        var unread = AllNotifications.Where(n => !n.IsRead).ToList();
        if (unread.Count == 0 || IsMarkingAll) return;

        IsMarkingAll = true;
        MarkAllProgress = 0;
        MarkAllTotal = unread.Count;
        StateHasChanged();

        try {
            foreach (var n in unread) {
                var response = await appBwPortService.SendRpcRequestAsync(
                    AppBwMessageType.Values.RequestMarkNotification,
                    new { payload = new { said = n.Id } });

                if (!response.Ok) {
                    logger.LogWarning("MarkAllAsRead: Failed to mark {Id}: {Error}", n.Id, response.Error);
                }
                MarkAllProgress++;
                await InvokeAsync(StateHasChanged);
            }
            snackbar.Add($"Marked {MarkAllTotal} as read", Severity.Info);
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error during mark all as read");
            snackbar.Add("Error marking notifications", Severity.Error);
        }
        finally {
            IsMarkingAll = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    public void Dispose() {
        this.UnsubscribeFromAppCache();
        GC.SuppressFinalize(this);
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    <MudStack Class="bt-main">
        <div class="bt-main-inside-scroll">
            <MudStack Row="true" AlignItems="AlignItems.Center">
                <PageHeading Title="Notifications" InfoTooltip="Notifications from KERIA">
                    <CountContent>@CountLabel</CountContent>
                </PageHeading>
                <MudSpacer />
                @if (UnreadCount > 0 && !IsMarkingAll)
                {
                    <MudButton Variant="Variant.Text"
                               Size="Size.Small"
                               StartIcon="@Icons.Material.Filled.DoneAll"
                               OnClick="MarkAllAsRead"
                               Disabled="@IsProcessing">
                        Mark all read
                    </MudButton>
                }
            </MudStack>

            @if (IsMarkingAll)
            {
                <MudProgressLinear Value="@MarkAllProgress" Max="@MarkAllTotal" Color="Color.Primary" Class="my-1" />
            }

            @if (AllNotifications.Count > 0)
            {
                <MudStack Row="true" Spacing="2" Class="mt-1">
                    <MudSelect T="string" Label="Route" Value="@FilterRoute" ValueChanged="@(v => FilterRoute = v)"
                               Clearable="true" Dense="true" Margin="Margin.Dense" Variant="Variant.Outlined"
                               Style="min-width: 160px;">
                        @foreach (var route in AvailableRoutes)
                        {
                            <MudSelectItem T="string" Value="@route">@RouteLabel(route)</MudSelectItem>
                        }
                    </MudSelect>
                    <MudSelect T="bool?" Label="Status" Value="@FilterReadStatus" ValueChanged="@(v => FilterReadStatus = v)"
                               Clearable="true" Dense="true" Margin="Margin.Dense" Variant="Variant.Outlined"
                               Style="min-width: 120px;">
                        <MudSelectItem T="bool?" Value="@((bool?)false)">Unread</MudSelectItem>
                        <MudSelectItem T="bool?" Value="@((bool?)true)">Read</MudSelectItem>
                    </MudSelect>
                </MudStack>
            }

            @if (!FilteredNotifications.Any())
            {
                <MudAlert Severity="Severity.Info" Class="mt-4">
                    @(IsFiltering ? "No notifications match the current filters." : "No notifications.")
                </MudAlert>
            }

            @foreach (var n in FilteredNotifications)
            {
                <MudCard Elevation="0" Class="py-0 my-1" Style="@(n.IsRead ? "opacity: 0.6;" : "")">
                    <div class="d-flex" style="align-items: center; padding: 8px 4px; cursor: pointer;"
                         @onclick="@(() => ToggleNotificationDetail(n))">
                        <MudIcon Icon="@RouteIcon(n.Route)"
                                 Color="@(n.IsRead ? Color.Default : Color.Primary)"
                                 Style="margin-right: 8px;" />
                        <div style="flex:1; min-width:0;">
                            <MudText Typo="@(n.IsRead ? Typo.body1 : Typo.h6)">@RouteLabel(n.Route)</MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">@n.DateTime</MudText>
                            <MudTooltip Text="@n.Id" Delay="300">
                                <MudText Typo="Typo.caption" Style="font-family: monospace;">@ElideId(n.Id)</MudText>
                            </MudTooltip>
                        </div>
                        @if (!n.IsRead)
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Primary" Variant="Variant.Text">New</MudChip>
                        }
                        <MudMenu Icon="@Icons.Material.Filled.MoreVert" Dense="true" AnchorOrigin="Origin.BottomRight" TransformOrigin="Origin.TopRight">
                            @if (!n.IsRead)
                            {
                                <MudMenuItem OnClick="@(() => MarkAsRead(n))" Icon="@Icons.Material.Filled.MarkEmailRead" Disabled="@IsProcessing">Mark as Read</MudMenuItem>
                            }
                            <MudMenuItem OnClick="@(() => DeleteNotification(n))" Icon="@Icons.Material.Filled.Delete" IconColor="Color.Error" Disabled="@IsProcessing">Delete</MudMenuItem>
                        </MudMenu>
                    </div>

                    @if (ExpandedNotificationId == n.Id)
                    {
                        <MudDivider />
                        <div style="padding: 8px 12px;">
                            @if (IsLoadingExchange)
                            {
                                <div style="display:flex; align-items:center; padding: 8px 0;">
                                    <MudProgressCircular Color="Color.Default" Size="Size.Small" Indeterminate="true" />
                                    <MudText Typo="Typo.caption" Class="ml-2">Loading exchange details...</MudText>
                                </div>
                            }
                            else if (ExchangeLoadError is not null)
                            {
                                <MudAlert Severity="Severity.Warning" Dense="true">@ExchangeLoadError</MudAlert>
                            }
                            else if (ExpandedExchangeData is not null)
                            {
                                <NotificationExchangeDetail Exchange="@ExpandedExchangeData"
                                                            Route="@n.Route"
                                                            OnAdmit="@(() => AdmitCredential(n))"
                                                            IsAdmitting="@IsAdmitting" />
                            }
                        </div>
                    }
                </MudCard>
            }

            @if (IsProcessing)
            {
                <div style="display:flex; align-items: center; justify-content:center; padding: 24px;">
                    <MudProgressCircular Color="Color.Default" Indeterminate="true" />
                </div>
            }
        </div>
    </MudStack>
    <MudStack Row="true" class="bt-button-tray">
        <MudIconButton Icon="@Icons.Material.Filled.ArrowBackIosNew" Variant="Variant.Text" OnClick='@(async () => await Helper.PreviousPage.GoBack(js))' Class="justify-start" />
        <MudSpacer />
    </MudStack>
</div>
