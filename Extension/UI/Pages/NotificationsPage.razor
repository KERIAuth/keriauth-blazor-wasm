@page "/Notifications.html"
@using Extension.Models
@using Extension.Models.Messages.AppBw
@using Extension.Services.SignifyService.Models
@using Extension.Services.Storage
@using Extension.Services.Port
@using Extension.UI.Components
@inherits AuthenticatedPageBase
@implements IDisposable

@inject ILogger<NotificationsPage> logger
@inject IStorageService storageService
@inject IJSRuntime js
@inject ISnackbar snackbar
@inject AppCache appCache
@inject IAppBwPortService appBwPortService

@code {
    bool IsProcessing { get; set; }
    string selectedViewDefId = ViewDefIds.NotifAll;

    List<Notification> AllNotifications => appCache?.MyNotifications?.Items ?? [];

    int UnreadCount => AllNotifications.Count(n => !n.IsRead);

    // ViewDef
    List<FilterSet<Notification>> ProfileSubtotalFilterSets =>
    [
        new("Target", [(Notification n) => n.TargetPrefix == appCache.SelectedPrefix]),
        new("Sender", [(Notification n) => n.SenderPrefix == appCache.SelectedPrefix])
    ];

    List<ViewDef<Notification>> NotificationViewDefs =>
    [
        new(ViewDefIds.NotifTarget, "Target (active profile)",
            FilterSets: [new("Target", [(Notification n) => n.TargetPrefix == appCache.SelectedPrefix])],
            SubtotalFilterSets: ProfileSubtotalFilterSets,
            CountStyle: CountStyle.OfSubTotal,
            SortSets: [new("DateTime", [new SortExpression<Notification>(n => n.DateTime, Descending: true)])]),
        new(ViewDefIds.NotifSender, "Sender (active profile)",
            FilterSets: [new("Sender", [(Notification n) => n.SenderPrefix == appCache.SelectedPrefix])],
            SubtotalFilterSets: ProfileSubtotalFilterSets,
            CountStyle: CountStyle.OfSubTotal,
            SortSets: [new("DateTime", [new SortExpression<Notification>(n => n.DateTime, Descending: true)])]),
        new(ViewDefIds.NotifAll, "All",
            CountStyle: CountStyle.Total,
            SortSets: [new("DateTime", [new SortExpression<Notification>(n => n.DateTime, Descending: true)])])
    ];

    ViewDef<Notification>? SelectedViewDef => NotificationViewDefs.FirstOrDefault(v => v.Id == selectedViewDefId);

    // ViewDef-filtered list (profile-based filtering + sorting)
    List<Notification> ViewDefFilteredNotifications => ViewDefHelper.Apply(AllNotifications, SelectedViewDef);

    int? SubtotalCount => SelectedViewDef?.SubtotalFilterSets is { Count: > 0 }
        ? ViewDefHelper.ApplySubtotalCount(AllNotifications, SelectedViewDef)
        : (int?)null;

    // Route/ReadStatus filtering state (composes on top of ViewDef)
    string? FilterRoute { get; set; }
    bool? FilterReadStatus { get; set; }

    List<string> AvailableRoutes => ViewDefFilteredNotifications
        .Select(n => n.Route)
        .Where(r => !string.IsNullOrEmpty(r))
        .Distinct()
        .OrderBy(r => r)
        .ToList();

    List<Notification> FilteredNotifications {
        get {
            IEnumerable<Notification> filtered = ViewDefFilteredNotifications;
            if (FilterRoute is not null) {
                filtered = filtered.Where(n => n.Route == FilterRoute);
            }
            if (FilterReadStatus is not null) {
                filtered = filtered.Where(n => n.IsRead == FilterReadStatus.Value);
            }
            return filtered.ToList();
        }
    }

    bool IsFiltering => FilterRoute is not null || FilterReadStatus is not null;

    static string ElideId(string id) =>
        id.Length > 12
            ? $"{id[..6]}...{id[^4..]}"
            : id;

    static string RouteLabel(string route) => route switch {
        "/exn/ipex/grant" => "Credential Grant",
        "/exn/ipex/admit" => "Credential Admit",
        "/exn/ipex/apply" => "Credential Apply",
        "/exn/ipex/offer" => "Credential Offer",
        "/exn/ipex/agree" => "Credential Agree",
        "/multisig/iss" => "Multisig Issuance",
        "/multisig/icp" => "Multisig Inception",
        "/multisig/rot" => "Multisig Rotation",
        "/multisig/exn" => "Multisig Exchange",
        _ => route
    };

    static string RouteIcon(string route) => route switch {
        "/exn/ipex/grant" => Icons.Material.Filled.CardGiftcard,
        "/exn/ipex/admit" => Icons.Material.Filled.CheckCircle,
        "/exn/ipex/apply" => Icons.Material.Filled.Assignment,
        "/exn/ipex/offer" => Icons.Material.Filled.LocalOffer,
        "/exn/ipex/agree" => Icons.Material.Filled.Handshake,
        "/multisig/iss" => Icons.Material.Filled.GroupWork,
        "/multisig/icp" => Icons.Material.Filled.Groups,
        "/multisig/rot" => Icons.Material.Filled.RotateRight,
        "/multisig/exn" => Icons.Material.Filled.SwapHoriz,
        _ => Icons.Material.Filled.Notifications
    };

    // Mark-all-as-read state
    bool IsMarkingAll { get; set; }
    int MarkAllProgress { get; set; }
    int MarkAllTotal { get; set; }

    // Expansion state
    string? ExpandedNotificationId { get; set; }
    ExchangeView? ExpandedExchangeData { get; set; }
    bool IsLoadingExchange { get; set; }
    string? ExchangeLoadError { get; set; }
    bool IsAdmitting { get; set; }
    bool IsAlreadyAdmitted { get; set; }

    protected override async Task OnInitializedAsync() {
        logger.LogInformation("OnInitializedAsync");
        InitializeAppCache(appCache);
        await this.SubscribeToAppCache(appCache);

        // Restore persisted ViewDef selection
        var pageKey = GetType().Name;
        if (appCache.MyPreferences.SelectedViewDefIds.TryGetValue(pageKey, out var savedId)
            && NotificationViewDefs.Any(v => v.Id == savedId))
        {
            selectedViewDefId = savedId;
        }
    }

    async Task OnViewDefChanged(string newId) {
        selectedViewDefId = newId;
        var updatedIds = new Dictionary<string, string>(appCache.MyPreferences.SelectedViewDefIds)
        {
            [GetType().Name] = newId
        };
        await storageService.SetItem(appCache.MyPreferences with { SelectedViewDefIds = updatedIds });
    }

    async Task ToggleNotificationDetail(Notification notification) {
        if (ExpandedNotificationId == notification.Id) {
            ExpandedNotificationId = null;
            ExpandedExchangeData = null;
            ExchangeLoadError = null;
            return;
        }

        ExpandedNotificationId = notification.Id;
        ExpandedExchangeData = null;
        ExchangeLoadError = null;
        IsAlreadyAdmitted = false;

        if (notification.ExchangeSaid is null) {
            ExchangeLoadError = "No exchange SAID available";
            return;
        }

        IsLoadingExchange = true;

        try {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestGetExchange,
                new { payload = new { said = notification.ExchangeSaid } });

            if (!response.Ok) {
                ExchangeLoadError = response.Error ?? "Failed to load exchange details";
                return;
            }

            var exchangeResult = response.Result is JsonElement jsonEl
                ? JsonSerializer.Deserialize<GetExchangeResponsePayload>(jsonEl.GetRawText(), Helper.JsonOptions.PortMessaging)
                : null;

            if (exchangeResult is not null && exchangeResult.Success && exchangeResult.Exchange is not null) {
                ExpandedExchangeData = ExchangeView.FromRecursiveDictionary(exchangeResult.Exchange);

                // For grant notifications, check if credential has already been admitted
                if (notification.Route == "/exn/ipex/grant") {
                    var credSaid = ExpandedExchangeData.Value.E?.GetValueByPath("acdc.d")?.Value?.ToString();
                    if (credSaid is not null) {
                        try {
                            var cached = await storageService.GetItem<CachedCredentials>(StorageArea.Session);
                            if (cached.IsSuccess && cached.Value?.RawJson is not null) {
                                var credentials = Helper.CredentialHelper.DeserializeCredentialsRawJson(cached.Value.RawJson);
                                IsAlreadyAdmitted = credentials.Any(c =>
                                    c.GetValueByPath("sad.d")?.Value?.ToString() == credSaid);
                            }
                        }
                        catch (Exception credEx) {
                            logger.LogWarning(credEx, "Error checking credential existence");
                        }
                    }

                    if (IsAlreadyAdmitted && !notification.IsRead) {
                        _ = MarkAsRead(notification);
                    }
                }
            }
            else {
                ExchangeLoadError = exchangeResult?.Error ?? "Unknown error loading exchange";
            }
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error fetching exchange details");
            ExchangeLoadError = "Error loading exchange details";
        }
        finally {
            IsLoadingExchange = false;
        }
    }

    async Task AdmitCredential(Notification notification) {
        if (IsAdmitting || ExpandedExchangeData is null) return;

        var view = ExpandedExchangeData.Value;
        var issuerPrefix = view.I;
        var recipientPrefix = view.Rp;

        // Validate the recipient is one of our AIDs
        if (recipientPrefix is null || !appCache.Aids.Any(a => a.Prefix == recipientPrefix)) {
            snackbar.Add("Could not find matching AID for this grant", Severity.Error);
            return;
        }

        if (notification.ExchangeSaid is null || issuerPrefix is null) {
            snackbar.Add("Missing exchange data for admit", Severity.Error);
            return;
        }

        IsAdmitting = true;

        try {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestIpexAdmit,
                new { payload = new IpexAdmitRequestPayload(
                    SenderNameOrPrefix: recipientPrefix,
                    RecipientPrefix: issuerPrefix,
                    GrantSaid: notification.ExchangeSaid) },
                timeout: TimeSpan.FromMinutes(2));

            if (!response.Ok) {
                snackbar.Add($"Admit failed: {response.Error}", Severity.Error);
                return;
            }

            var admitResult = response.Result is JsonElement admitJsonEl
                ? JsonSerializer.Deserialize<IpexAdmitResponsePayload>(admitJsonEl.GetRawText(), Helper.JsonOptions.PortMessaging)
                : null;

            if (admitResult is not null && admitResult.Success) {
                IsAlreadyAdmitted = true;
                snackbar.Add("Credential admitted", Severity.Success);
                if (!notification.IsRead) {
                    await MarkAsRead(notification);
                }
            }
            else {
                snackbar.Add($"Admit failed: {admitResult?.Error ?? "Unknown error"}", Severity.Error);
            }
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error during IPEX admit");
            snackbar.Add("Error admitting credential", Severity.Error);
        }
        finally {
            IsAdmitting = false;
        }
    }

    async Task MarkAsRead(Notification notification) {
        if (IsProcessing) return;
        IsProcessing = true;

        try {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestMarkNotification,
                new { payload = new { said = notification.Id } });

            if (!response.Ok) {
                snackbar.Add($"Failed to mark notification: {response.Error}", Severity.Error);
            }
            else {
                var notifId = notification.Id;
                await appCache.WaitForAppCache([
                    () => appCache.MyNotifications.Items.Any(n => n.Id == notifId && n.IsRead)
                ]);
                snackbar.Add("Marked as read", Severity.Info);
            }
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error marking notification as read");
            snackbar.Add("Error marking notification", Severity.Error);
        }
        finally {
            IsProcessing = false;
        }
    }

    async Task DeleteNotification(Notification notification) {
        if (IsProcessing) return;
        IsProcessing = true;

        try {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestDeleteNotification,
                new { payload = new { said = notification.Id } });

            if (!response.Ok) {
                snackbar.Add($"Failed to delete notification: {response.Error}", Severity.Error);
            }
            else {
                var notifId = notification.Id;
                await appCache.WaitForAppCache([
                    () => !appCache.MyNotifications.Items.Any(n => n.Id == notifId)
                ]);
                snackbar.Add("Notification deleted", Severity.Info);
            }
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error deleting notification");
            snackbar.Add("Error deleting notification", Severity.Error);
        }
        finally {
            IsProcessing = false;
        }
    }

    async Task MarkAllAsRead() {
        var unread = AllNotifications.Where(n => !n.IsRead).ToList();
        if (unread.Count == 0 || IsMarkingAll) return;

        IsMarkingAll = true;
        MarkAllProgress = 0;
        MarkAllTotal = unread.Count;

        try {
            foreach (var n in unread) {
                var response = await appBwPortService.SendRpcRequestAsync(
                    AppBwMessageType.Values.RequestMarkNotification,
                    new { payload = new { said = n.Id } });

                if (!response.Ok) {
                    logger.LogWarning("MarkAllAsRead: Failed to mark {Id}: {Error}", n.Id, response.Error);
                }
                MarkAllProgress++;
                await InvokeAsync(StateHasChanged);
            }
            snackbar.Add($"Marked {MarkAllTotal} as read", Severity.Info);
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error during mark all as read");
            snackbar.Add("Error marking notifications", Severity.Error);
        }
        finally {
            IsMarkingAll = false;
        }
    }

    public void Dispose() {
        this.UnsubscribeFromAppCache();
        GC.SuppressFinalize(this);
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    <MudStack Class="bt-main">
        <div class="bt-main-inside-scroll">
            <PageHeading Title="Notifications" InfoTooltip="Notifications from KERIA" />
            <MudStack Row="true" AlignItems="AlignItems.Center">
                <ViewSelector T="Notification"
                              ViewDefs="@NotificationViewDefs"
                              SelectedViewDefId="@selectedViewDefId"
                              SelectedViewDefIdChanged="@OnViewDefChanged"
                              FilteredCount="@ViewDefFilteredNotifications.Count"
                              SubtotalCount="@SubtotalCount"
                              TotalCount="@AllNotifications.Count" />
                <MudSpacer />
                @if (UnreadCount > 0 && !IsMarkingAll)
                {
                    <MudButton Variant="Variant.Text"
                               Size="Size.Small"
                               StartIcon="@Icons.Material.Filled.DoneAll"
                               OnClick="MarkAllAsRead"
                               Disabled="@IsProcessing">
                        Mark all read
                    </MudButton>
                }
            </MudStack>

            @if (IsMarkingAll)
            {
                <MudProgressLinear Value="@MarkAllProgress" Max="@MarkAllTotal" Color="Color.Primary" Class="my-1" />
            }

            @if (ViewDefFilteredNotifications.Count > 0)
            {
                <MudStack Row="true" Spacing="2" Class="mt-1">
                    <MudSelect T="string" Label="Route" Value="@FilterRoute" ValueChanged="@(v => FilterRoute = v)"
                               Clearable="true" Dense="true" Margin="Margin.Dense" Variant="Variant.Outlined"
                               Style="min-width: 160px;">
                        @foreach (var route in AvailableRoutes)
                        {
                            <MudSelectItem T="string" Value="@route">@RouteLabel(route)</MudSelectItem>
                        }
                    </MudSelect>
                    <MudSelect T="bool?" Label="Status" Value="@FilterReadStatus" ValueChanged="@(v => FilterReadStatus = v)"
                               Clearable="true" Dense="true" Margin="Margin.Dense" Variant="Variant.Outlined"
                               Style="min-width: 120px;">
                        <MudSelectItem T="bool?" Value="@((bool?)false)">Unread</MudSelectItem>
                        <MudSelectItem T="bool?" Value="@((bool?)true)">Read</MudSelectItem>
                    </MudSelect>
                </MudStack>
            }

            @if (!FilteredNotifications.Any())
            {
                <MudAlert Severity="Severity.Info" Class="mt-4">
                    @(IsFiltering ? "No notifications match the current filters." : "No notifications.")
                </MudAlert>
            }

            @foreach (var n in FilteredNotifications)
            {
                <MudCard Elevation="0" Class="py-0 my-1" Style="@(n.IsRead ? "opacity: 0.6;" : "")">
                    <div class="d-flex" style="align-items: center; padding: 8px 4px; cursor: pointer;"
                         @onclick="@(() => ToggleNotificationDetail(n))">
                        <MudIcon Icon="@RouteIcon(n.Route)"
                                 Color="@(n.IsRead ? Color.Default : Color.Primary)"
                                 Style="margin-right: 8px;" />
                        <div style="flex:1; min-width:0;">
                            <MudText Typo="@(n.IsRead ? Typo.body1 : Typo.h6)">@RouteLabel(n.Route)</MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">@n.DateTime</MudText>
                            <MudTooltip Text="@n.Id" Delay="300">
                                <MudText Typo="Typo.caption" Style="font-family: monospace;">@ElideId(n.Id)</MudText>
                            </MudTooltip>
                        </div>
                        @if (!n.IsRead)
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Primary" Variant="Variant.Text">New</MudChip>
                        }
                        <MudMenu Icon="@Icons.Material.Filled.MoreVert" Dense="true" AnchorOrigin="Origin.BottomRight" TransformOrigin="Origin.TopRight">
                            @if (!n.IsRead)
                            {
                                <MudMenuItem OnClick="@(() => MarkAsRead(n))" Icon="@Icons.Material.Filled.MarkEmailRead" Disabled="@IsProcessing">Mark as Read</MudMenuItem>
                            }
                            <MudMenuItem OnClick="@(() => DeleteNotification(n))" Icon="@Icons.Material.Filled.Delete" IconColor="Color.Error" Disabled="@IsProcessing">Delete</MudMenuItem>
                        </MudMenu>
                    </div>

                    @if (ExpandedNotificationId == n.Id)
                    {
                        <MudDivider />
                        <div style="padding: 8px 12px;">
                            <LoadingDiv IsLoading="@IsLoadingExchange">
                                @if (ExchangeLoadError is not null)
                                {
                                    <MudAlert Severity="Severity.Warning" Dense="true">@ExchangeLoadError</MudAlert>
                                }
                                else if (ExpandedExchangeData is not null)
                                {
                                    <NotificationExchangeDetail Exchange="@ExpandedExchangeData.Value"
                                                                Route="@n.Route"
                                                                OnAdmit="@(() => AdmitCredential(n))"
                                                                IsAdmitting="@IsAdmitting"
                                                                IsAlreadyAdmitted="@IsAlreadyAdmitted" />
                                }
                            </LoadingDiv>
                        </div>
                    }
                </MudCard>
            }

            @if (IsProcessing)
            {
                <div style="display:flex; align-items: center; justify-content:center; padding: 24px;">
                    <MudProgressCircular Color="Color.Default" Indeterminate="true" />
                </div>
            }
        </div>
    </MudStack>
    <MudStack Row="true" class="bt-button-tray">
        <MudIconButton Icon="@Icons.Material.Filled.ArrowBackIosNew" Variant="Variant.Text" OnClick='@(async () => await Helper.PreviousPage.GoBack(js))' Class="justify-start" />
        <MudSpacer />
    </MudStack>
</div>
