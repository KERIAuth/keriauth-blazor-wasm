@page "/Notifications.html"
@using Extension.Models.Messages.AppBw
@using Extension.Services.SignifyService.Models
@using Extension.Services.Port
@using Extension.UI.Components
@inherits AuthenticatedPageBase
@implements IDisposable

@inject ILogger<NotificationsPage> logger
@inject IJSRuntime js
@inject ISnackbar snackbar
@inject AppCache appCache
@inject IAppBwPortService appBwPortService

@code {
    bool IsProcessing { get; set; }

    List<Notification> AllNotifications => appCache?.MyNotifications?.Items?
        .OrderByDescending(n => n.DateTime)
        .ToList() ?? [];

    int UnreadCount => AllNotifications.Count(n => !n.IsRead);
    string CountLabel => $"({AllNotifications.Count})";

    static string ElideId(string id) =>
        id.Length > 12
            ? $"{id[..6]}...{id[^4..]}"
            : id;

    static string RouteLabel(string route) => route switch {
        "/exn/ipex/grant" => "Credential Grant",
        "/exn/ipex/admit" => "Credential Admit",
        "/exn/ipex/apply" => "Credential Apply",
        "/exn/ipex/offer" => "Credential Offer",
        "/exn/ipex/agree" => "Credential Agree",
        "/multisig/iss" => "Multisig Issuance",
        "/multisig/icp" => "Multisig Inception",
        "/multisig/rot" => "Multisig Rotation",
        "/multisig/exn" => "Multisig Exchange",
        _ => route
    };

    // Expansion state
    string? ExpandedNotificationId { get; set; }
    RecursiveDictionary? ExpandedExchangeData { get; set; }
    bool IsLoadingExchange { get; set; }
    string? ExchangeLoadError { get; set; }
    bool IsAdmitting { get; set; }

    protected override async Task OnInitializedAsync() {
        logger.LogInformation("OnInitializedAsync");
        InitializeAppCache(appCache);
        await this.SubscribeToAppCache(appCache);
    }

    async Task ToggleNotificationDetail(Notification notification) {
        if (ExpandedNotificationId == notification.Id) {
            ExpandedNotificationId = null;
            ExpandedExchangeData = null;
            ExchangeLoadError = null;
            StateHasChanged();
            return;
        }

        ExpandedNotificationId = notification.Id;
        ExpandedExchangeData = null;
        ExchangeLoadError = null;

        if (notification.ExchangeSaid is null) {
            ExchangeLoadError = "No exchange SAID available";
            StateHasChanged();
            return;
        }

        IsLoadingExchange = true;
        StateHasChanged();

        try {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestGetExchange,
                new { payload = new { said = notification.ExchangeSaid } });

            if (!response.Ok) {
                ExchangeLoadError = response.Error ?? "Failed to load exchange details";
                return;
            }

            var exchangeResult = response.Result is JsonElement jsonEl
                ? JsonSerializer.Deserialize<GetExchangeResponsePayload>(jsonEl.GetRawText(), Helper.JsonOptions.PortMessaging)
                : null;

            if (exchangeResult is not null && exchangeResult.Success && exchangeResult.Exchange is not null) {
                ExpandedExchangeData = exchangeResult.Exchange;
            }
            else {
                ExchangeLoadError = exchangeResult?.Error ?? "Unknown error loading exchange";
            }
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error fetching exchange details");
            ExchangeLoadError = "Error loading exchange details";
        }
        finally {
            IsLoadingExchange = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    async Task AdmitCredential(Notification notification) {
        if (IsAdmitting || ExpandedExchangeData is null) return;

        // Exchange response has wrapper: { exn: { i, rp, a, e, ... }, pathed: {...} }
        RecursiveDictionary? exn = null;
        if (ExpandedExchangeData.TryGetValue("exn", out var exnVal) && exnVal?.Dictionary is RecursiveDictionary exnDict) {
            exn = exnDict;
        }

        if (exn is null) {
            snackbar.Add("Invalid exchange data structure", Severity.Error);
            return;
        }

        // Extract sender (issuer) prefix from exn.i
        exn.TryGetValue("i", out var senderVal);
        var issuerPrefix = senderVal?.StringValue;

        // Extract recipient (our AID) prefix from exn.rp
        exn.TryGetValue("rp", out var rpVal);
        var recipientPrefix = rpVal?.StringValue;

        // Look up our AID name from the prefix
        var ourAid = appCache.Aids.FirstOrDefault(a => a.Prefix == recipientPrefix);
        if (ourAid is null) {
            snackbar.Add("Could not find matching AID for this grant", Severity.Error);
            return;
        }

        if (notification.ExchangeSaid is null || issuerPrefix is null) {
            snackbar.Add("Missing exchange data for admit", Severity.Error);
            return;
        }

        IsAdmitting = true;
        StateHasChanged();

        try {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestIpexAdmit,
                new { payload = new IpexAdmitRequestPayload(ourAid.Name, issuerPrefix, notification.ExchangeSaid) },
                timeout: TimeSpan.FromMinutes(2));

            if (!response.Ok) {
                snackbar.Add($"Admit failed: {response.Error}", Severity.Error);
                return;
            }

            var admitResult = response.Result is JsonElement admitJsonEl
                ? JsonSerializer.Deserialize<IpexAdmitResponsePayload>(admitJsonEl.GetRawText(), Helper.JsonOptions.PortMessaging)
                : null;

            if (admitResult is not null && admitResult.Success) {
                snackbar.Add("Credential admitted", Severity.Success);
                // Mark notification as read after successful admit
                await MarkAsRead(notification);
            }
            else {
                snackbar.Add($"Admit failed: {admitResult?.Error ?? "Unknown error"}", Severity.Error);
            }
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error during IPEX admit");
            snackbar.Add("Error admitting credential", Severity.Error);
        }
        finally {
            IsAdmitting = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    async Task MarkAsRead(Notification notification) {
        if (IsProcessing) return;
        IsProcessing = true;
        StateHasChanged();

        try {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestMarkNotification,
                new { payload = new { said = notification.Id } });

            if (!response.Ok) {
                snackbar.Add($"Failed to mark notification: {response.Error}", Severity.Error);
            }
            else {
                var notifId = notification.Id;
                await appCache.WaitForAppCache([
                    () => appCache.MyNotifications.Items.Any(n => n.Id == notifId && n.IsRead)
                ]);
                snackbar.Add("Marked as read", Severity.Info);
            }
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error marking notification as read");
            snackbar.Add("Error marking notification", Severity.Error);
        }
        finally {
            IsProcessing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    async Task DeleteNotification(Notification notification) {
        if (IsProcessing) return;
        IsProcessing = true;
        StateHasChanged();

        try {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestDeleteNotification,
                new { payload = new { said = notification.Id } });

            if (!response.Ok) {
                snackbar.Add($"Failed to delete notification: {response.Error}", Severity.Error);
            }
            else {
                var notifId = notification.Id;
                await appCache.WaitForAppCache([
                    () => !appCache.MyNotifications.Items.Any(n => n.Id == notifId)
                ]);
                snackbar.Add("Notification deleted", Severity.Info);
            }
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error deleting notification");
            snackbar.Add("Error deleting notification", Severity.Error);
        }
        finally {
            IsProcessing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    public void Dispose() {
        this.UnsubscribeFromAppCache();
        GC.SuppressFinalize(this);
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    <MudStack Class="bt-main">
        <div class="bt-main-inside-scroll">
            <PageHeading Title="Notifications" InfoTooltip="Notifications from KERIA">
                <CountContent>@CountLabel</CountContent>
            </PageHeading>

            @if (!AllNotifications.Any())
            {
                <MudAlert Severity="Severity.Info" Class="mt-4">No notifications.</MudAlert>
            }

            @foreach (var n in AllNotifications)
            {
                <MudCard Elevation="0" Class="py-0 my-1" Style="@(n.IsRead ? "opacity: 0.6;" : "")">
                    <div class="d-flex" style="align-items: center; padding: 8px 4px; cursor: pointer;"
                         @onclick="@(() => ToggleNotificationDetail(n))">
                        <MudIcon Icon="@(n.IsRead ? Icons.Material.Outlined.Notifications : Icons.Material.Filled.NotificationsActive)"
                                 Color="@(n.IsRead ? Color.Default : Color.Primary)"
                                 Style="margin-right: 8px;" />
                        <div style="flex:1; min-width:0;">
                            <MudText Typo="@(n.IsRead ? Typo.body1 : Typo.h6)">@RouteLabel(n.Route)</MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">@n.DateTime</MudText>
                            <MudTooltip Text="@n.Id" Delay="300">
                                <MudText Typo="Typo.caption" Style="font-family: monospace;">@ElideId(n.Id)</MudText>
                            </MudTooltip>
                        </div>
                        @if (!n.IsRead)
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Primary" Variant="Variant.Text">New</MudChip>
                        }
                        <MudMenu Icon="@Icons.Material.Filled.MoreVert" Dense="true" AnchorOrigin="Origin.BottomRight" TransformOrigin="Origin.TopRight">
                            @if (!n.IsRead)
                            {
                                <MudMenuItem OnClick="@(() => MarkAsRead(n))" Icon="@Icons.Material.Filled.MarkEmailRead" Disabled="@IsProcessing">Mark as Read</MudMenuItem>
                            }
                            <MudMenuItem OnClick="@(() => DeleteNotification(n))" Icon="@Icons.Material.Filled.Delete" IconColor="Color.Error" Disabled="@IsProcessing">Delete</MudMenuItem>
                        </MudMenu>
                    </div>

                    @if (ExpandedNotificationId == n.Id)
                    {
                        <MudDivider />
                        <div style="padding: 8px 12px;">
                            @if (IsLoadingExchange)
                            {
                                <div style="display:flex; align-items:center; padding: 8px 0;">
                                    <MudProgressCircular Color="Color.Default" Size="Size.Small" Indeterminate="true" />
                                    <MudText Typo="Typo.caption" Class="ml-2">Loading exchange details...</MudText>
                                </div>
                            }
                            else if (ExchangeLoadError is not null)
                            {
                                <MudAlert Severity="Severity.Warning" Dense="true">@ExchangeLoadError</MudAlert>
                            }
                            else if (ExpandedExchangeData is not null)
                            {
                                <NotificationExchangeDetail Exchange="@ExpandedExchangeData"
                                                            Route="@n.Route"
                                                            OnAdmit="@(() => AdmitCredential(n))"
                                                            IsAdmitting="@IsAdmitting" />
                            }
                        </div>
                    }
                </MudCard>
            }

            @if (IsProcessing)
            {
                <div style="display:flex; align-items: center; justify-content:center; padding: 24px;">
                    <MudProgressCircular Color="Color.Default" Indeterminate="true" />
                </div>
            }
        </div>
    </MudStack>
    <MudStack Row="true" class="bt-button-tray">
        <MudIconButton Icon="@Icons.Material.Filled.ArrowBackIosNew" Variant="Variant.Text" OnClick='@(async () => await Helper.PreviousPage.GoBack(js))' Class="justify-start" />
        <MudSpacer />
    </MudStack>
</div>
