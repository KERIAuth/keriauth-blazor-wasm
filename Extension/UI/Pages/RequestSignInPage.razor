@page "/RequestSignIn.html"
@layout Layouts.DialogLayout
@inherits Extension.UI.Components.TabDialogPageBase

@using Extension.Helper
@using Extension.Models
@using Extension.Models.Messages.AppBw
@using Extension.Models.Messages.BwApp
@using Extension.Models.Messages.BwApp.Requests
@using Extension.Models.Messages.CsBw
@using Extension.Services
@using FluentResults
@using MudBlazor

@inject ILogger<RequestSignInPage> logger
@inject ISnackbar snackbar

@code {
    // Page-specific types
    enum SignInMode { Credential, Identifier, IdentifierAndOptionalCredential }

    // Page-specific fields
    private MudButton? signInButton;

    // Page-specific properties
    SignInMode RequestedSignInMode => (payload?.OriginalType ?? string.Empty) switch
    {
        CsBwMessageTypes.SELECT_AUTHORIZE_AID => SignInMode.Identifier,
        CsBwMessageTypes.SELECT_AUTHORIZE_CREDENTIAL => SignInMode.Credential,
        CsBwMessageTypes.AUTHORIZE => SignInMode.IdentifierAndOptionalCredential,
        _ => SignInMode.IdentifierAndOptionalCredential
    };
    string? SelectedPrefix { get; set; }
    string? SelectedAlias { get; set; }
    RecursiveDictionary? SelectedCredentialOrNothing { get; set; }

    RequestSelectAuthorizePayload? payload;

    // Computed properties
    bool IsSignInDisabled => (SelectedPrefix is null || (RequestedSignInMode == SignInMode.Credential && SelectedCredentialOrNothing is null));

    string PageTitle => RequestedSignInMode switch
    {
        SignInMode.Identifier => "Request to Sign In with Profile",
        SignInMode.Credential => "Request to Sign In with Credential",
        SignInMode.IdentifierAndOptionalCredential => "Request to Sign In",
        _ => $"Unsupported SignIn Mode: {RequestedSignInMode}"
    };

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        logger.LogInformation("OnInitializedAsync");

        payload = await InitializeFromPendingRequestAsync<RequestSelectAuthorizePayload>(
            BwAppMessageType.Values.RequestSelectAuthorize);
        if (payload is null)
        {
            return;
        }

        logger.LogInformation("OnInitializedAsync: origin={Origin}", payload.Origin);

        // Load the active tab for display
        await LoadActiveTabAsync();

        var originalType = payload.OriginalType ?? string.Empty;
        if (originalType is not (CsBwMessageTypes.AUTHORIZE or CsBwMessageTypes.SELECT_AUTHORIZE_AID or CsBwMessageTypes.SELECT_AUTHORIZE_CREDENTIAL))
        {
            logger.LogWarning("OnInitializedAsync: Unexpected original message type: {Type}, defaulting to IdentifierAndOptionalCredential mode", originalType);
        }

        IsInitialized = true;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await SetSignInFocus();
        }
    }

    async Task SetSignInFocus()
    {
        if (signInButton is not null)
        {
            logger.LogInformation("setting focus on Sign In button");
            await signInButton.FocusAsync();
        }
    }

    /// <summary>
    /// Sign in with the selected identifier or credential.
    /// </summary>
    async Task<Result> SignIn()
    {
        await BeginActionAsync();

        if (TabId <= 0)
        {
            var error = new ValidationError("TabId", "Invalid tab ID");
            snackbar.Add(error.Message, Severity.Error);
            return Result.Fail(error);
        }

        if (SelectedPrefix is null || SelectedAlias is null)
        {
            var error = new ValidationError("Selection", "Identifier selection is incomplete");
            snackbar.Add(error.Message, Severity.Error);
            return Result.Fail(error);
        }

        string? credentialSaid = null;
        if (SelectedCredentialOrNothing is not null)
        {
            credentialSaid = SelectedCredentialOrNothing.GetValueByPath("sad.d")?.Value as string;
            if (credentialSaid is null)
            {
                var error = new ValidationError("Credential", "Credential SAID is missing");
                snackbar.Add(error.Message, Severity.Error);
                return Result.Fail(error);
            }
        }
        else if (RequestedSignInMode == SignInMode.Credential)
        {
            var error = new ValidationError("Credential", "No credential is selected");
            snackbar.Add(error.Message, Severity.Error);
            return Result.Fail(error);
        }

        logger.LogInformation("SignIn with prefix: {Prefix}, credential: {HasCred}", SelectedPrefix, credentialSaid is not null);
        var approval = new AidApprovalPayload(
            Prefix: SelectedPrefix,
            Alias: SelectedAlias,
            CredentialSaid: credentialSaid
        );
        var message = new AppBwReplyAidApprovalMessage(TabId, OriginStr, PageRequestId, approval);
        await AppBwPortService.SendToBackgroundWorkerAsync(message);
        MarkAsReplied();

        try
        {
            // Clear the pending request now that sign-in is complete
            await ClearPendingRequestAsync();
            await WaitForAppCacheClearAsync();
            await ReturnToPriorUIAsync();
            // maybe unreachable if popup closes
            return Result.Ok();
        }
        catch (Exception ex)
        {
            logger.LogError("Failed to send sign-in response: {error}", ex.Message);
            return Result.Fail(new JavaScriptInteropError("SendToServiceWorker", ex.Message, ex));
        }
    }

    async Task Cancel()
    {
        await CancelAndReturnAsync("User canceled sign-in request");
    }

    private async Task HandleIdOrCredChanged((string selectedPrefix, string selectedAlias, RecursiveDictionary? selectedCredentialOrNothing, WebsiteConfig? websiteConfig) value)
    {
        logger.LogInformation($"HandleValueChanged prefix {value.selectedPrefix} | selectedCredential {value.selectedCredentialOrNothing is not null}");
        SelectedPrefix = value.selectedPrefix;
        SelectedAlias = value.selectedAlias;
        SelectedCredentialOrNothing = value.selectedCredentialOrNothing;
        StateHasChanged();
        await SetSignInFocus();
    }

    private async Task SignInHandler()
    {
        var result = await SignIn();
        if (result.IsFailed)
        {
            logger.LogError("Sign-in failed: {error}", result.Errors.FirstOrDefault()?.Message);
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" || e.Code == "NumpadEnter")
        {
            await SignInHandler();
        }
    }

}

@if (IsInitialized)
{
    <div id="@this.GetType().Name" class="bt-body-page">
        <MudStack Class="bt-main">
            <div class="bt-main-inside-scroll">
                <PageHeading Title="@PageTitle" />
                @if (ActiveTab is not null)
                {
                    // Note: the message text from the website request is intentionally not displayed.
                    <TabInteractionDisplay ActiveTab=@ActiveTab />
                    @switch (RequestedSignInMode)
                    {
                        case SignInMode.Identifier:
                            <MudText Class="bt-help-text">The website is requesting you to select a profile for identification.</MudText>
                            break;
                        case SignInMode.Credential:
                            <MudText Class="bt-help-text">The website is requesting you to select a profile and credential for authorization.</MudText>
                            break;
                        case SignInMode.IdentifierAndOptionalCredential:
                            <MudText Class="bt-help-text">The website is requesting you to provide your profile for identification or a credential for authorization.</MudText>
                            break;
                        default:
                            <MudText Class="bt-help-text">Unknown sign-in mode.</MudText>
                            break;
                    }
                }
                else
                {
                    <MudText Typo="Typo.body1" Class="mb-4">Unknown Page (tab not found)</MudText>
                }

                @switch (RequestedSignInMode)
                {
                    case SignInMode.IdentifierAndOptionalCredential:
                        <WebsiteConfigDisplay OriginStr="@OriginStr" IsOriginShown="false" IsCredentialShown="true" IsCredentialRequired="false" IsAutoSignShown="false" ValueChanged="async (v) => await HandleIdOrCredChanged(v)" />
                        break;
                    case SignInMode.Identifier:
                        <WebsiteConfigDisplay OriginStr="@OriginStr" IsOriginShown="false" IsCredentialShown="false" IsAutoSignShown="false" ValueChanged="async (v) => await HandleIdOrCredChanged(v)" />
                        break;
                    case SignInMode.Credential:
                        <WebsiteConfigDisplay OriginStr="@OriginStr" IsOriginShown="false" IsCredentialShown="true" IsAutoSignShown="false" ValueChanged="async (v) => await HandleIdOrCredChanged(v)" />
                        break;
                    default:
                        <MudText>Unsupported SignInMode: @RequestedSignInMode</MudText>
                        break;
                }
            </div>
        </MudStack>

        <MudStack Row="true" class="bt-button-tray">
            <MudButton StartIcon="@Icons.Material.Filled.Cancel" Variant="Variant.Filled" Color="Color.Tertiary" OnClick="@(async (_) => await Cancel())">Cancel</MudButton>
            <MudButton @ref="signInButton"
                       StartIcon="@Icons.Material.Filled.Login"
                       Disabled="IsSignInDisabled"
                       Variant="Variant.Filled"
                       Color="Color.Primary"
                       OnClick="SignInHandler"
                       @onkeydown="HandleKeyDown">
                Sign In
            </MudButton>
        </MudStack>
    </div>
}

