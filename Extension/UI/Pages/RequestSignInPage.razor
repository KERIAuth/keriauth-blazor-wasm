@page "/RequestSignIn.html"
@layout Layouts.DialogLayout

@using Extension.Services.Storage
@using System;
@using System.Collections.Generic;
@using System.Diagnostics
@using System.Linq
@using System.Text.Json
@using System.Text.Json.Serialization
@using System.Web
@using Extension.Helper
@using Extension.Models
@using Extension.Models.Messages.AppBw
@using Extension.Models.Messages.BwApp
@using Extension.Models.Messages.BwApp.Requests
@using Extension.Models.Messages.CsBw
@using Extension.Services
@using Extension.Services.JsBindings
@using Extension.Services.SignifyService
@using Extension.Services.SignifyService.Models
@using FluentResults
@using MudBlazor
@using static Extension.AppConfig
@using WebExtensions.Net.Runtime
@using WebExtensions.Net.Tabs
@using BrowserTab = WebExtensions.Net.Tabs.Tab

@implements IAsyncDisposable

@inject IStorageService storageService
@inject NavigationManager navManager
@inject IJSRuntime js
@using static Extension.Helper.PreviousPage
@inject ILogger<RequestSignInPage> logger
@inject ISignifyClientService signifyClientService
@inject IDialogService dialogService
@inject ISnackbar snackbar
@inject IWebsiteConfigService websiteConfigService
@inject IStorageService storageService
@inject IAppBwMessagingService appBwMessagingService
@inject IPendingBwAppRequestService pendingBwAppRequestService
@inject AppCache appCache
@inject IJSRuntime jsRuntime
@inject ISignifyClientBinding signifyClientBinding
@inject IWebExtensionsApi webExtensionsApi

@code {
    [CascadingParameter] public DialogLayout? Layout { get; set; }

    // fields and types
    enum SignInMode { Credential, Identifier, Prompt }
    private MudButton? signInButton;

    // properties

    public BrowserTab? ActiveTab { get; set; }
    /// <summary>
    /// The original requestId from the web page that initiated this authorization request.
    /// This must be returned in replies so the page can correlate the response.
    /// </summary>
    public string PageRequestId { get; set; } = "";
    public int TabId { get; set; } = -1;
    SignInMode RequestedSignInMode { get; set; } = SignInMode.Prompt;
    string? SelectedPrefix { get; set; }
    string? SelectedAlias { get; set; }
    RecursiveDictionary? SelectedCredentialOrNothing { get; set; }
    bool IsInitialized { get; set; }
    /// <summary>
    /// Tracks whether a reply (success or cancel) has been sent to the page.
    /// Used to avoid sending duplicate cancel messages on dispose.
    /// </summary>
    bool HasRepliedToPage { get; set; } = false;
    string OriginStr { get; set; } = "unset";

    // computed properties
    bool IsSignInDisabled => (SelectedPrefix is null || (RequestedSignInMode == SignInMode.Credential && SelectedCredentialOrNothing is null));
    /// <summary>
    /// Reactively checks if this page's pending request has been cleared from AppCache.
    /// Returns true if PageRequestId is empty or no longer matches the next pending request.
    /// </summary>
    bool IsPendingRequestCleared => string.IsNullOrEmpty(PageRequestId) ||
        appCache.NextPendingBwAppRequest?.RequestId != PageRequestId;


    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation("OnInitializedAsync");

        // Get the pending request from storage (set by BackgroundWorker before opening popup)
        var pendingRequest = appCache.NextPendingBwAppRequest;
        if (pendingRequest?.Type != BwAppMessageType.Values.RequestSelectAuthorize)
        {
            logger.LogError("OnInitializedAsync: No pending RequestSelectAuthorize request found");
            return;
        }

        OriginStr = pendingRequest.TabUrl ?? "unknown";
        var payload = pendingRequest.GetPayload<RequestSelectAuthorizePayload>();
        if (payload is null)
        {
            logger.LogError("OnInitializedAsync: Failed to deserialize pending request payload to RequestSelectAuthorizePayload");
            return;
        }

        // Extract values from the pending request payload
        // pageRequestId is the original request ID from the web page - must be returned in replies
        PageRequestId = pendingRequest.RequestId;
        TabId = payload.TabId;

        logger.LogInformation("OnInitializedAsync: pageRequestId={PageRequestId}, tabId={TabId}, origin={Origin}",
            PageRequestId, TabId, payload.Origin);

        // TODO P2 move this into component, then pass only the TabId to component
        ActiveTab = await webExtensionsApi.Tabs.Get(TabId);

        // Determine sign-in mode from the original message type
        var originalType = payload.OriginalType ?? string.Empty;
        RequestedSignInMode = originalType switch
        {
            CsBwMessageTypes.SELECT_AUTHORIZE_AID => SignInMode.Identifier,
            CsBwMessageTypes.SELECT_AUTHORIZE_CREDENTIAL => SignInMode.Credential,
            CsBwMessageTypes.AUTHORIZE => SignInMode.Prompt,
            _ => SignInMode.Prompt
        };

        if (originalType != CsBwMessageTypes.AUTHORIZE &&
            originalType != CsBwMessageTypes.SELECT_AUTHORIZE_AID &&
            originalType != CsBwMessageTypes.SELECT_AUTHORIZE_CREDENTIAL)
        {
            logger.LogWarning("OnInitializedAsync: Unexpected original message type: {Type}, defaulting to Prompt mode", originalType);
        }

        IsInitialized = true;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await SetSignInFocus();
        }
    }

    async Task SetSignInFocus()
    {
        if (signInButton is not null)
        {
            logger.LogInformation("setting focus on Sign In button");
            await signInButton.FocusAsync();
        }
    }

    /*
    * SignIn()
    */
    async Task<Result> SignIn(SignInMode RequestedSignInMode, string pageRequestIdParam)
    {
        // will received Prefix and credential via callback from WebsiteConfigDisplay component

        if (TabId <= 0)
        {
            var error = new ValidationError("TabId", "Invalid tab ID");
            snackbar.Add(error.Message, Severity.Error);
            return Result.Fail(error);
        }

        switch (RequestedSignInMode)
        {
            case SignInMode.Identifier:
                logger.LogInformation("SignIn with Identifier: {0}", SelectedPrefix);
                if (SelectedPrefix is null || SelectedAlias is null)
                {
                    var error = new ValidationError("Selection", "Identifier selection is incomplete");
                    snackbar.Add(error.Message, Severity.Error);
                    return Result.Fail(error);
                }

                var identifierResult = new Extension.Models.Messages.AppBw.AuthorizeResult(
                    Aid: new Aid(name: SelectedAlias, prefix: SelectedPrefix, salty: null!),
                    Credential: null
                );
                var identifierMessage = new AppBwReplyAidMessage(TabId, OriginStr, PageRequestId, identifierResult);
                await appBwMessagingService.SendToBackgroundWorkerAsync(identifierMessage);
                HasRepliedToPage = true;
                break;

            case SignInMode.Credential:
                if (SelectedCredentialOrNothing is null || SelectedPrefix is null || SelectedAlias is null)
                {
                    var error = new ValidationError("Credential", "No credential is selected");
                    snackbar.Add(error.Message, Severity.Error);
                    return Result.Fail(error);
                }

                var selectedCredentialSaid = SelectedCredentialOrNothing.GetValueByPath("sad.d")?.Value as string;
                if (selectedCredentialSaid is null)
                {
                    var error = new ValidationError("Credential", "Credential SAID is missing");
                    snackbar.Add(error.Message, Severity.Error);
                    return Result.Fail(error);
                }

                // Get CESR representation of credential
                var cesr = await signifyClientBinding.GetCredentialAsync(selectedCredentialSaid, true);

                // Pass RecursiveDictionary directly - NEVER serialize/deserialize credentials
                // RecursiveDictionary preserves CESR/SAID ordering required for verification
                var authorizeResultCredential = new Extension.Models.Messages.AppBw.AuthorizeResultCredential(
                    Raw: SelectedCredentialOrNothing,
                    Cesr: cesr
                );
                var authorizeResult = new Extension.Models.Messages.AppBw.AuthorizeResult(
                    Aid: new Aid(name: SelectedAlias, prefix: SelectedPrefix, salty: null!),
                    Credential: authorizeResultCredential
                );
                var credentialMessage = new AppBwReplyAidMessage(TabId, OriginStr, PageRequestId, authorizeResult);
                await appBwMessagingService.SendToBackgroundWorkerAsync(credentialMessage);
                HasRepliedToPage = true;
                break;

            default:
                return Result.Fail(new ValidationError("SignInMode", $"Unknown sign-in mode: {RequestedSignInMode}"));
        }

        try
        {
            // Clear the pending request now that sign-in is complete
            await ClearPendingRequestAsync();
            await Layout!.ReturnToPriorUI();
            // maybe unreachable if popup closes
            return Result.Ok();
        }
        catch (Exception ex)
        {
            logger.LogError("Failed to send sign-in response: {error}", ex.Message);
            return Result.Fail(new JavaScriptInteropError("SendToServiceWorker", ex.Message, ex));
        }

    }

    async Task Cancel(MouseEventArgs _)
    {
        logger.LogInformation("Cancel: User initiated cancel for pageRequestId={PageRequestId}", PageRequestId);

        var message = new AppBwReplyCanceledMessage(TabId, OriginStr, PageRequestId, "User canceled sign-in");
        try
        {
            await appBwMessagingService.SendToBackgroundWorkerAsync(message);
            HasRepliedToPage = true;
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Cancel: Failed to send cancel message to BackgroundWorker");
            // Continue to clear pending request and close popup even if message send failed
        }

        // Clear pending request BEFORE navigation to prevent Index.razor from re-routing back here
        logger.LogInformation("Cancel: Clearing pending request before navigation");
        await ClearPendingRequestAsync();

        // Wait for AppCache to reflect the cleared request (prevents race with Index.razor routing)
        var waitResult = await appCache.WaitForAppCache([() => !appCache.HasPendingBwAppRequests], 3000, 100);
        if (!waitResult)
        {
            logger.LogWarning("Cancel: AppCache did not clear pending requests within timeout, proceeding anyway");
        }
        else
        {
            logger.LogInformation("Cancel: AppCache confirmed no pending requests");
        }

        await Layout!.ReturnToPriorUI();
        return;
    }

    public async ValueTask DisposeAsync()
    {
        // If user closes popup without previously clicking Sign In or Cancel,
        // send a cancel reply to the page so it's not left waiting
        if (!HasRepliedToPage && TabId > 0 && !string.IsNullOrEmpty(PageRequestId))
        {
            logger.LogInformation("DisposeAsync: Sending cancel reply for pageRequestId={PageRequestId} (popup closed without action)", PageRequestId);
            try
            {
                var message = new AppBwReplyCanceledMessage(TabId, OriginStr, PageRequestId, "User closed sign-in dialog (popup or SidePanel dialog");
                await appBwMessagingService.SendToBackgroundWorkerAsync(message);
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "DisposeAsync: Failed to send cancel message to BackgroundWorker");
            }
        }

        // Clear pending request if user closes popup without explicit action
        await ClearPendingRequestAsync();
        // TODO P4 unsubscribe from services, observables
    }

    /// <summary>
    /// Clears the pending request from storage using the pageRequestId captured during initialization.
    /// This ensures we clear the correct request even if multiple requests are queued.
    /// </summary>
    async Task ClearPendingRequestAsync()
    {
        if (string.IsNullOrEmpty(PageRequestId))
        {
            logger.LogWarning("ClearPendingRequestAsync: No pageRequestId available to clear");
            return;
        }

        logger.LogInformation("ClearPendingRequestAsync: Clearing pending request, pageRequestId={PageRequestId}", PageRequestId);
        var result = await pendingBwAppRequestService.RemoveRequestAsync(PageRequestId);
        if (result.IsFailed)
        {
            logger.LogError("ClearPendingRequestAsync: Failed to remove request - {Errors}", string.Join(", ", result.Errors.Select(e => e.Message)));
        }
    }

    private async Task HandleIdOrCredChanged((string selectedPrefix, string selectedAlias, RecursiveDictionary? selectedCredentialOrNothing) value)
    {
        logger.LogInformation($"HandleValueChanged prefix {value.selectedPrefix} | selectedCredential {value.selectedCredentialOrNothing is not null}");
        SelectedPrefix = value.selectedPrefix;
        SelectedAlias = value.selectedAlias;
        SelectedCredentialOrNothing = value.selectedCredentialOrNothing;
        StateHasChanged();
        await SetSignInFocus();
    }

    //
    //
    //
    private async Task SignInHandler()
    {
        var result = await SignIn(RequestedSignInMode, PageRequestId);
        if (result.IsFailed)
        {
            logger.LogError("Sign-in failed: {error}", result.Errors.FirstOrDefault()?.Message);
        }
    }

    //
    //
    //
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" || e.Code == "NumpadEnter")
        {
            await SignInHandler();
        }
    }

}

@if (IsInitialized)
{
    <div id="@this.GetType().Name" class="bt-body-page">
        <MudStack Class="bt-main">
            <div class="bt-main-inside-scroll">
                @switch (RequestedSignInMode)
                {
                    case SignInMode.Identifier:
                        <MudText Class="bt-page-title">Request to Sign In with Identifier</MudText>
                        break;
                    case SignInMode.Credential:
                        <MudText Class="bt-page-title">Request to Sign In with Credential</MudText>
                        break;
                    case SignInMode.Prompt:
                        <MudText Class="bt-page-title">Request to Sign In</MudText>
                        break;
                    default:
                        <MudText Class="bt-page-title">Unsupported SignIn Mode: @RequestedSignInMode</MudText>
                        break;
                }
                @if (ActiveTab is not null)
                {
                    <TabInteractionDisplay ActiveTab=@ActiveTab />
                } else
                {
                    <MudText Typo="Typo.body1" Class="mb-4">Unknown Page (tab not found)</MudText>
                }

                @switch (RequestedSignInMode)
                {
                    case SignInMode.Prompt:
                        <MudStack Class="gap-0">
                            <MudText Class="mt-6"><b>Sign-in method</b></MudText>
                            <MudRadioGroup @bind-Value="RequestedSignInMode" T=@SignInMode InputStyle="flex-direction:column; align-items:start;">
                                <MudRadio Value=@(SignInMode.Identifier)>Identifier only</MudRadio>
                                <MudRadio Value=@(SignInMode.Credential)>Identifier with Credential</MudRadio>
                            </MudRadioGroup>
                        </MudStack>
                        break;
                    case SignInMode.Identifier:
                        <WebsiteConfigDisplay OriginStr="@OriginStr" IsOriginShown="false" IsCredentialShown="false" IsAutoSignShown="false" ValueChanged="async (v) => await HandleIdOrCredChanged(v)" />
                        break;
                    case SignInMode.Credential:
                        <WebsiteConfigDisplay OriginStr="@OriginStr" IsOriginShown="false" IsCredentialShown="true" IsAutoSignShown="false" ValueChanged="async (v) => await HandleIdOrCredChanged(v)" />
                        break;
                    default:
                        <MudText>Unsupported SignInMode: @RequestedSignInMode</MudText>
                        break;
                }
            </div>
        </MudStack>

        <MudStack Row="true" class="bt-button-tray">
            <MudButton StartIcon="@Icons.Material.Filled.Cancel" Variant="Variant.Filled" Color="Color.Tertiary" OnClick=Cancel>Cancel</MudButton>
            <MudButton @ref="signInButton"
                       StartIcon="@Icons.Material.Filled.Login"
                       Disabled="IsSignInDisabled"
                       Variant="Variant.Filled"
                       Color="Color.Primary"
                       OnClick="SignInHandler"
                       @onkeydown="HandleKeyDown">
                Sign In
            </MudButton>
        </MudStack>
    </div>
}

<style>
    .mud-select .mud-select-input .mud-input-slot {
        height: auto;
    }

    .selected-item {
        border-left: 4px solid blue;
    }
</style>
