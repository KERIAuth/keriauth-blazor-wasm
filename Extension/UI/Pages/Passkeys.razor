@page "/Passkeys.html"
@using Extension.Services.Storage

@using Extension.Helper
@using Extension.Models
@using Extension.Services
@using Extension.Services.SignifyService
@using Extension.Services.SignifyService.Models
@using static Extension.AppConfig;
@using static Extension.Helper.Identicon;
@using static Extension.Helper.PreviousPage
@using System.Diagnostics
@using System.Text.Json
@using WebExtensions.Net
@using WebExtensions.Net.Runtime
@using JsBind.Net
@using System.Linq;

@using System.Net.Http.Json
@inject HttpClient httpClient
@inject IStorageService storageService
@inject NavigationManager navManager
@inject IJSRuntime js
@inject ILogger<Passkeys> logger
@inject ISignifyClientService signifyClientService
@inject IDialogService dialogService
@inject ISnackbar snackbar
@inject IWebExtensionsApi webExtensionsApi
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject IWebauthnService webauthnService
@inject AppCache appCache
@inject IFidoMetadataService fidoMetadataService

@code {
    // fields
    // TODO P2: should MyStoredPasskeys be initialized here or only in OnParametersSetAsync? Should it be cached and retrieved from AppCache as needed with a reactive pattern and subscription to appCache?
    StoredPasskeys MyStoredPasskeys = new();
    int CurrentPasscodeHash = 0;

    // reactive properties
    string CountLabel => "(" + MyStoredPasskeys.Passkeys.Count.ToString() + ")";

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation($"OnInitializedAsync");
        // TODO P2 does this need to be recreated here?
        webExtensionsApi ??= new WebExtensionsApi(jsRuntimeAdapter);
    }

    protected override async Task OnParametersSetAsync()
    {
        logger.LogInformation($"OnParametersSetAsync");

        // Load current PasscodeHash from configuration
        var configResult = await storageService.GetItem<KeriaConnectConfig>(StorageArea.Local);
        if (configResult.IsSuccess && configResult.Value is not null)
        {
            CurrentPasscodeHash = configResult.Value.PasscodeHash;
        }

        var result = await webauthnService.GetStoredPasskeysAsync();
        if (result.IsSuccess)
        {
            MyStoredPasskeys = result.Value;
        }
        StateHasChanged();
    }

    bool IsConsistentWithCurrentPasscode(StoredPasskey passkey) =>
        CurrentPasscodeHash != 0 && passkey.PasscodeHash == CurrentPasscodeHash;

    async Task AddPasskey()
    {
        navManager.NavigateTo(Routes.PathFor<AddPasskeyPage>());
    }

    async Task rename(string newName, string credentialBase64)
    {
        if (newName.Length == 0)
        {
            return;
        }
        var updatedPasskeys = MyStoredPasskeys with
            {
                Passkeys = MyStoredPasskeys.Passkeys
                        .Select(pk => pk.CredentialBase64.GetHashCode() == credentialBase64.GetHashCode()
                            ? pk with { Name = newName, LastUpdatedUtc = DateTime.UtcNow }
                            : pk)
                        .ToList(),
                IsStored = true
            };
        // Use StorageService via type-safe model
        var saveResult = await storageService.SetItem<StoredPasskeys>(updatedPasskeys, StorageArea.Local);
        if (saveResult.IsFailed)
        {
            snackbar.Add("Failed to save passkey changes", Severity.Error);
            logger.LogError("Failed to rename passkey: {Errors}", string.Join(", ", saveResult.Errors));
            return;
        }
        snackbar.Add("Successfully renamed passkey", Severity.Success);
        // update page's collection
        var result = await webauthnService.GetStoredPasskeysAsync();
        if (result.IsSuccess)
        {
            MyStoredPasskeys = result.Value;
        }
        StateHasChanged();
    }

    async Task delete(string credentialBase64)
    {
        var deleteResult = await webauthnService.RemovePasskeyAsync(credentialBase64);
        if (deleteResult.IsFailed)
        {
            snackbar.Add("Failed to delete passkey", Severity.Error);
            logger.LogError("Failed to delete passkey: {Errors}", string.Join(", ", deleteResult.Errors));
            return;
        }
        snackbar.Add("Successfully removed passkey", Severity.Success);
        // update page's collection
        var result = await webauthnService.GetStoredPasskeysAsync();
        if (result.IsSuccess)
        {
            MyStoredPasskeys = result.Value;
        }
        StateHasChanged();
    }

    // All available WebAuthn transport types
    static readonly string[] AllTransports = new[] { "usb", "nfc", "ble", "internal", "hybrid" };

    async Task UpdateTransport(string credentialBase64, string transport, bool isEnabled)
    {
        var passkey = MyStoredPasskeys.Passkeys
            .FirstOrDefault(a => a.CredentialBase64 == credentialBase64);
        if (passkey == null) return;

        var currentTransports = passkey.Transports.ToList();
        if (isEnabled && !currentTransports.Contains(transport))
        {
            currentTransports.Add(transport);
        }
        else if (!isEnabled && currentTransports.Contains(transport))
        {
            currentTransports.Remove(transport);
        }
        else
        {
            return; // No change needed
        }

        // Ensure at least one transport remains enabled
        if (currentTransports.Count == 0)
        {
            snackbar.Add("At least one transport must be enabled", Severity.Warning);
            return;
        }

        var updatedPasskeys = MyStoredPasskeys with
        {
            Passkeys = MyStoredPasskeys.Passkeys
                .Select(pk => pk.CredentialBase64 == credentialBase64
                    ? pk with { Transports = currentTransports.ToArray(), LastUpdatedUtc = DateTime.UtcNow }
                    : pk)
                .ToList(),
            IsStored = true
        };

        var saveResult = await storageService.SetItem<StoredPasskeys>(updatedPasskeys, StorageArea.Local);
        if (saveResult.IsFailed)
        {
            snackbar.Add("Failed to save transport changes", Severity.Error);
            logger.LogError("Failed to update transports: {Errors}", string.Join(", ", saveResult.Errors));
            return;
        }

        // Refresh the list
        var result = await webauthnService.GetStoredPasskeysAsync();
        if (result.IsSuccess)
        {
            MyStoredPasskeys = result.Value;
        }
        StateHasChanged();
    }

    async Task test(string credentialBase64)
    {
        // Test only the specific passkey that was clicked
        var testResult = await webauthnService.TestPasskeyAsync(credentialBase64);
        if (testResult.IsSuccess) {
            snackbar.Add("Test successful - passkey verified", Severity.Success);
        } else {
            snackbar.Add("Test failed: " + string.Join(", ", testResult.Errors.Select(e => e.Message)), Severity.Warning);
        }
    }

    async Task testAll()
    {
        // Test all passkeys with permissive options
        var testResult = await webauthnService.TestAllPasskeysAsync();
        if (testResult.IsSuccess) {
            snackbar.Add($"Test successful using: {testResult.Value}", Severity.Success);
        } else {
            snackbar.Add("Test failed: " + string.Join(", ", testResult.Errors.Select(e => e.Message)), Severity.Warning);
        }
    }

    bool HasPasskeys => MyStoredPasskeys.Passkeys.Any();

    /// <summary>
    /// Gets the appropriate icon for a passkey based on the current theme.
    /// Uses IconDark when dark theme is active and available, otherwise falls back to Icon.
    /// Looks up IconDark from FIDO metadata at display time using the stored AAGUID.
    /// </summary>
    string? GetPasskeyIcon(StoredPasskey passkey) {
        if (appCache.MyPreferences.IsDarkTheme) {
            var metadata = fidoMetadataService.GetMetadata(passkey.Aaguid);
            if (!string.IsNullOrEmpty(metadata?.IconDark)) {
                return metadata.IconDark;
            }
        }
        return passkey.Icon;
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    <MudStack Class="bt-main">
        <div class="d-flex gap-3 bt-main">
            <div class="bt-main-inside-scroll">
                <MudText Class="bt-page-title">Passkeys  @CountLabel</MudText>
                <MudStack Class="pt-4">
                    @if (MyStoredPasskeys.Passkeys.Any())
                    {
                        @foreach (var pk in MyStoredPasskeys.Passkeys)
                        {
                            <MudCard Elevation="0">
                                <MudCardContent Class="pb-0 mb-0">
                                    @{
                                        var iconUrl = GetPasskeyIcon(pk);
                                    }
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                                        @if (!string.IsNullOrEmpty(iconUrl))
                                        {
                                            <MudAvatar Size="Size.Medium" Style="background-color:transparent;">
                                                <MudImage Src="@iconUrl" Alt="Passkey icon" Width="40" Height="40" ObjectFit="ObjectFit.Contain" />
                                            </MudAvatar>
                                        }
                                        else
                                        {
                                            <MudAvatar Size="Size.Medium" Color="Color.Default">
                                                <MudIcon Icon="@Icons.Material.Filled.Key" />
                                            </MudAvatar>
                                        }
                                        <MudTextField Value="@pk.Name" HelperText="" Label="" ValueChanged="@(async (string newName) => await rename(newName, pk.CredentialBase64))" Style="flex:1;" />
                                    </MudStack>
                                    <MudText Color="Color.Secondary" Style="font-weight:100; font-size:small;"><span>Created: </span>@pk.CreationTime.ToString("u")</MudText>
                                    <MudText Color="Color.Secondary" Style="font-weight:100; font-size:small;"><span>Updated: </span>@pk.LastUpdatedUtc.ToString("u")</MudText>
                                    @{
                                        var isConsistent = IsConsistentWithCurrentPasscode(pk);
                                    }
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Class="mt-2">
                                        <MudIcon Icon="@(isConsistent ? Icons.Material.Filled.CheckCircle : Icons.Material.Filled.Cancel)"
                                                 Color="@(isConsistent ? Color.Success : Color.Error)"
                                                 Size="Size.Small" />
                                        <MudText Color="@(isConsistent ? Color.Success : Color.Error)" Style="font-weight:100; font-size:small;">
                                            Consistent with current KERIA Cloud Service connection
                                        </MudText>
                                    </MudStack>
                                    <MudText Color="Color.Secondary" Class="mt-2" Style="font-weight:100; font-size:small;">Transports:</MudText>
                                    <MudStack Row="true" Class="ml-2" Style="flex-wrap:wrap; gap:0.286rem;">
                                        @foreach (var transport in AllTransports)
                                        {
                                            var credId = pk.CredentialBase64;
                                            var isEnabled = pk.Transports.Contains(transport);
                                            <MudCheckBox T="bool" Label="@transport" Size="Size.Small" Dense="true"
                                                         Value="@isEnabled"
                                                         ValueChanged="@(async (bool val) => await UpdateTransport(credId, transport, val))"
                                                         Style="margin:0; padding:0;" />
                                        }
                                    </MudStack>
                                    @if (pk.Transports.Contains("internal"))
                                    {
                                        <MudText Color="Color.Secondary" Class="mt-2 ml-2" Style="font-weight:100; font-size:small;">
                                            <b>Note:</b> Passkeys with "internal" transport (e.g., Windows Hello, Touch ID)
                                            are prioritized by the browser. To prefer a USB security key, uncheck "internal".
                                        </MudText>
                                    }
                                </MudCardContent>
                                <MudCardActions Style="justify-content:flex-end; padding:0;">
                                    <MudButton OnClick="async () => await test(pk.CredentialBase64)">Test</MudButton>
                                    <MudIconButton Icon="@Icons.Material.Filled.DeleteForever" Color="Color.Error" OnClick="async () => await delete(pk.CredentialBase64)">Delete</MudIconButton>
                                </MudCardActions>
                            </MudCard>
                        }
                    }
                </MudStack>
            </div>
        </div>
    </MudStack>
    <MudStack Row="true" class="bt-button-tray">
        <MudIconButton Icon="@Icons.Material.Filled.ArrowBackIosNew" Variant="Variant.Text" OnClick='@( async () => await GoBack(js) )' Class="justify-start" />
        <MudSpacer />
        <MudButton OnClick="async () => await testAll()" Variant="Variant.Outlined" Disabled="@(!HasPasskeys)">Test All</MudButton>
        <MudButton StartIcon="@Icons.Material.Filled.Add" OnClick="async () => await AddPasskey()" Variant="Variant.Filled" Color="Color.Primary">Add</MudButton>
    </MudStack>
</div>
