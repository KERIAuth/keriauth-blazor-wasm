@page "/RequestSignHeaders.html"
@layout Layouts.DialogLayout
@using Extension.Services.Storage

@inherits AuthenticatedPageBase

@using System.Linq
@using System.Text.Json
@using Extension.Helper
@using Extension.Models
@using Extension.Models.Messages.AppBw
@using Extension.Models.Messages.BwApp
@using Extension.Models.Messages.BwApp.Requests
@using Extension.Models.Storage
@using Extension.Services
@using Extension.Services.SignifyService
@using Extension.Services.SignifyService.Models
@using static Extension.AppConfig
@using MudBlazor
@using FluentResults
@using System.Web
@using System.Text.Json.Serialization
@using System;
@using System.Collections.Generic;
@using JsBind.Net
@using WebExtensions.Net
@using WebExtensions.Net.Tabs
@using BrowserTab = WebExtensions.Net.Tabs.Tab

@implements IAsyncDisposable

@inject IStorageService storageService
@inject NavigationManager navManager
@using static Extension.Helper.PreviousPage
@inject ILogger<RequestSignHeadersPage> logger
@inject ISignifyClientService signifyClientService
@inject IDialogService dialogService
@inject ISnackbar snackbar
@inject IWebsiteConfigService websiteConfigService
@inject IStorageService storageService
@inject IAppBwMessagingService appBwMessagingService
@inject IPendingBwAppRequestService pendingBwAppRequestService
@inject IJSRuntime jsRuntime
@inject IJSRuntime js
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject ISnackbar snackbar
@inject AppCache appCache // Non-reactive here unless/until SubscribeToAppCache() is added in OnInitializedAsync
@inject IWebExtensionsApi webExtensionsApi

@code {
    [CascadingParameter] public DialogLayout? Layout { get; set; }

    // fields
    private MudButton? signRequestButton;

    static readonly HashSet<string> SafeMethods = new(StringComparer.OrdinalIgnoreCase)
    {
        "GET",
        "HEAD",
        "OPTIONS"
    };

    // properties
    string RequestId { get; set; } = "";
    int TabId { get; set; } = -1;
    string PayloadJson { get; set; } = "";
    Dictionary<string, string> HeadersDict { get; set; } = new();
    bool IsInitialized { get; set; }
    bool IsExpanded { get; set; }
    enum SignInMode { Credential, Identifier, Prompt }
    WebsiteConfig? ThisWebsiteConfig { get; set; }
    List<RecursiveDictionary> credentials = new();
    SignInMode RequestedSignInMode { get; set; } = SignInMode.Prompt;
    string WebsiteConfiguredPrefix { get; set; } = "unknown";
    List<Aid>? Identifiers { get; set; }
    string OriginStr { get; set; } = "unset";
    public BrowserTab? ActiveTab { get; set; }

    // reactive properties
    public bool HasSafeHttpRequestMethod => HeadersDict.Any(header =>
       string.Equals(header.Key, "method", StringComparison.OrdinalIgnoreCase) &&
       SafeMethods.Contains(header.Value));
    bool IsAutoSignIn => ThisWebsiteConfig?.IsAutoSignInCredential ?? false;
    bool IsAutoSignSafeHeaders => ThisWebsiteConfig?.IsAutoSignSafeHeaders ?? true;
    string ExpandIcon => IsExpanded ? Icons.Material.Filled.ExpandLess : Icons.Material.Filled.ExpandMore;
    string WebsiteConfiguredAlias => Identifiers?.Find(x => x.Prefix == WebsiteConfiguredPrefix)?.Name ?? "not configured";
    Preferences Prefs => appCache.MyPreferences;
    string SelectedPrefix => Prefs.SelectedPrefix;
    bool IsDetailShown => Prefs.IsSignRequestDetailShown;

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation("OnInitializedAsync");

        // Initialize base class for authentication-based render suppression
        InitializeAppCache(appCache);

        // Get the pending request from storage (set by BackgroundWorker before opening popup)
        var pendingRequest = appCache.NextPendingBwAppRequest;
        if (pendingRequest?.Type != BwAppMessageType.Values.RequestSignHeaders)
        {
            logger.LogError("OnInitializedAsync: No pending RequestSignHeaders request found");
            return;
        }

        OriginStr = pendingRequest.TabUrl ?? "unknown";
        var payload = pendingRequest.GetPayload<RequestSignHeadersPayload>();
        if (payload is null)
        {
            logger.LogError("OnInitializedAsync: Failed to deserialize pending request payload to RequestSignHeadersPayload");
            return;
        }

        // Extract values from the pending request payload
        RequestId = pendingRequest.RequestId;
        TabId = payload.TabId;
        ActiveTab = await webExtensionsApi.Tabs.Get(TabId);
        HeadersDict = payload.Headers;
        PayloadJson = JsonSerializer.Serialize(payload.Headers);
        WebsiteConfiguredPrefix = payload.RememberedPrefix ?? "unknown";

        logger.LogInformation("OnInitializedAsync: requestId={RequestId}, tabId={TabId}, origin={Origin}",
            RequestId, TabId, payload.Origin);

        LoadIdentifiersFromCache();
        await RefreshFromWebsiteConfig();

        if (IsAutoSignSafeHeaders && HasSafeHttpRequestMethod)
        {
            // TODO P2: Move this logic into BackgroundWorker.cs, to avoid calling this page altogether.
            // TODO P2 notify the user signing is happening, and close?
        }

        IsInitialized = true;
    }

    private void LoadIdentifiersFromCache()
    {
        // Guard against null during session timeout navigation
        var identifiersList = appCache?.MyKeriaConnectionInfo?.IdentifiersList;
        if (identifiersList is not null && identifiersList.Count > 0 && identifiersList[0].Aids is not null)
        {
            Identifiers = identifiersList[0].Aids.OrderBy(a => a.Name).ToList();
        }
        else
        {
            // During session timeout, identifiers may be unavailable - this is expected
            logger.LogWarning("LoadIdentifiersFromCache: identifiers unavailable in cache");
            Identifiers = null;
        }
    }

    //
    //
    //
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && signRequestButton is not null)
        {
            await signRequestButton.FocusAsync();
        }
    }

    //
    //
    //
    Uri? GetOriginUri()
    {
        try
        {
            var uri = App.InitialUri;
            return uri;
        }
        catch (Exception ex)
        {
            logger.LogError("GetOriginUri: Error parsing OriginStr '{o}': {e}", OriginStr, ex);
            return null;
        }
    }

    //
    //
    //
    async Task SetIsDetailShown(bool isDetailShown)
    {
        // TODO P3 IsSignRequestDetailShown should be per website, since not every site should be trusted the same
        await storageService.SetItem<Preferences>(Prefs with { IsSignRequestDetailShown = isDetailShown });
        return;
    }

    //
    //
    //
    async Task updateIsAutoSignSafeHeaders(bool isChecked)
    {
        // logger.LogWarning("updateIsAutoSignHeaders: isChecked: {b} WebsiteConfig: {w}", isChecked, ThisWebsiteConfig);
        if (ThisWebsiteConfig is not null && ThisWebsiteConfig.IsAutoSignSafeHeaders != isChecked)
        {
            ThisWebsiteConfig = ThisWebsiteConfig with { IsAutoSignSafeHeaders = isChecked };
            await websiteConfigService.Update(ThisWebsiteConfig);
        }
        StateHasChanged();
    }

    //
    //
    //
    // TODO P2 DRY with similar method in WebsiteConfigDisplay
    async Task RefreshFromWebsiteConfig()
    {
        var originUri = GetOriginUri();
        if (originUri is null)
        {
            throw new Exception($"RefreshThisWebsiteConfig: origin must be set.");
        }

        var getOrCreateWebsiteRes = await websiteConfigService.GetOrCreateWebsiteConfig(originUri);
        if (getOrCreateWebsiteRes.IsFailed)
        {
            throw new Exception($"Error from websiteService {getOrCreateWebsiteRes.Errors}");
        }
        var (websiteConfig, isConfigNew) = getOrCreateWebsiteRes.Value;
        ThisWebsiteConfig = websiteConfig;

        if (isConfigNew)
        {
            var prefsResult = await storageService.GetItem<Preferences>();
            WebsiteConfiguredPrefix = prefsResult.IsSuccess && prefsResult.Value is not null
                ? prefsResult.Value.SelectedPrefix
                : AppConfig.DefaultPreferences.SelectedPrefix;
            ThisWebsiteConfig = ThisWebsiteConfig with { RememberedPrefixOrNothing = WebsiteConfiguredPrefix };
            await websiteConfigService.Update(ThisWebsiteConfig);
        }
        else
        {
            WebsiteConfiguredPrefix = ThisWebsiteConfig.RememberedPrefixOrNothing!;
        }
        StateHasChanged();
    }

    //
    //
    //
    // 
    async Task Cancel()
    {
        var message = new AppBwReplyCanceledMessage(TabId, OriginStr, RequestId, "User cancelled sign request");
        await appBwMessagingService.SendToBackgroundWorkerAsync(message);

        // Clear the pending request now that cancel is complete
        await ClearPendingRequestAsync();

        if (Layout is not null)
        {
            await Layout.ClosePopupAsync();
        }
        // unreachable
        return;
    }

    //
    //
    //
    public async ValueTask DisposeAsync()
    {
        // Clear pending request if user closes popup without explicit action
        await ClearPendingRequestAsync();
        // TODO P4 unsubscribe from services, observables
    }

    /// <summary>
    /// Clears any pending RequestSignHeaders request from storage.
    /// Should be called when user completes or cancels the sign headers flow.
    /// </summary>
    // TODO P1: This method fetches NextPendingBwAppRequest each time it's called, which could be
    // a different request if multiple are queued and one was already cleared. To fix: capture the
    // requestId when the page initializes (from the pending request that triggered navigation here)
    // and only clear that specific request, rather than whatever is currently first in the queue.
    async Task ClearPendingRequestAsync()
    {
        var pendingRequest = appCache.NextPendingBwAppRequest;
        if (pendingRequest?.Type == BwAppMessageType.Values.RequestSignHeaders)
        {
            logger.LogInformation("ClearPendingRequestAsync: Clearing pending RequestSignHeaders, requestId={RequestId}", pendingRequest.RequestId);
            await pendingBwAppRequestService.RemoveRequestAsync(pendingRequest.RequestId);
        }
    }

    //
    //
    //
    void ToggleExpand()
    {
        IsExpanded = !IsExpanded;
    }

    //
    //
    //
    private async Task ApproveRequestHandler()
    {
        var message = new AppBwReplySignMessage(TabId, OriginStr, RequestId, HeadersDict, WebsiteConfiguredPrefix, true);
        await appBwMessagingService.SendToBackgroundWorkerAsync(message);

        // Clear the pending request now that approval is complete
        await ClearPendingRequestAsync();

        if (Layout is not null)
        {
            await Layout.ClosePopupAsync();
        }
        // unreachable
       return;
    }
    
    //
    //
    //
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" || e.Code == "NumpadEnter")
        {
            await ApproveRequestHandler();
        }
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    <MudStack Class="bt-main">
        <div class="bt-main-inside-scroll">
            <MudText Class="bt-page-title">Request to Sign HTTP Request Headers</MudText>
            @if (ActiveTab is not null)
                {
                    <TabInteractionDisplay ActiveTab=@ActiveTab />
                } 
            <MudText class="mt-6" Typo="Typo.body1">
                This website is requesting KERI Auth, with your approval,
                to cryptographically sign HTTP Request Headers with the key material of the identifier you selected for this site when you signed in to it.
                The resulting signature and other headers will then allow the server for the requested url to validate and authorize the request.
            </MudText>
            <MudText Class="mt-2"><b>Signing Identifier</b></MudText>
            <MudStack Row Class="pl-1" Style="align-items:center;">
                <MudIcon Icon=@Helper.Identicon.MakeIdenticon(WebsiteConfiguredPrefix) ViewBox="0 0 100 100" Class="bt-identicon" Style="margin-top: 0.214rem;" />
                <MudText>@WebsiteConfiguredAlias</MudText>
            </MudStack>
                <MudStack Row>
                <MudCheckBox Label="Show Input Headers" Value="IsDetailShown" ValueChanged="async (bool b) => await SetIsDetailShown(b)" Style="padding-left:0;"></MudCheckBox>
                </MudStack>
                @if (IsDetailShown)
                {
                    <MudPaper Elevation="0" Class="ml-12">
                        <table class="non-responsive-table">
                            <thead style="text-align:left;">
                                <tr>
                                    <th class="content-width-col">Key</th>
                                    <th class="remaining-width-col">Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var item in HeadersDict)
                                {
                                    <tr>
                                        <td class="content-width-col">@item.Key</td>
                                        <td class="remaining-width-col">@item.Value</td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </MudPaper>
                }
                <MudCheckBox Label="Always auto-sign Http Request Headers that are safe and read-only (i.e., GET, HEAD, OPTIONS, TRACE)" Value="IsAutoSignSafeHeaders" ValueChanged="async (bool b) => await updateIsAutoSignSafeHeaders(b)" Style="padding-left:0; height: 2rem;" />
        </div>
    </MudStack>
    <MudStack Row="true" class="bt-button-tray">
        <MudSpacer />
        <MudButton StartIcon="@Icons.Material.Filled.Cancel" Variant="Variant.Filled" Color="Color.Tertiary" @onclick="Cancel">Reject</MudButton>
        <MudButton @ref="signRequestButton"
                   StartIcon="@Icons.Material.Filled.Login"
                   Variant="Variant.Filled"
                   Color="Color.Primary"
                   OnClick="ApproveRequestHandler"
                   @onkeydown="HandleKeyDown">
            Approve & Sign
        </MudButton>
    </MudStack>
</div>

<style>
    .mud-select .mud-select-input .mud-input-slot {
        height: auto;
    }

    .selected-item {
        border-left: 4px solid blue;
    }

    .content-width-col {
        width: 1%;
        white-space: nowrap;
    }

    .remaining-width-col {
        word-break: break-all;
        text-overflow: unset;
        word-wrap: anywhere;
        width: auto;
        white-space: unset !important;
    }

    .non-responsive-table {
        table-layout: fixed;
        border-collapse: collapse;
        text-align: left;
        vertical-align: baseline;
    }

        .non-responsive-table th,
        .non-responsive-table td {
            border: 1px solid #ddd;
            padding: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            vertical-align: baseline;
        }

        .non-responsive-table th {
            font-weight: bold;
        }
</style>
