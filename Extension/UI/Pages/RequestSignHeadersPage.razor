@page "/RequestSignHeaders.html"
@layout Layouts.DialogLayout
@inherits Extension.UI.Components.TabDialogPageBase

@using System.Text.Json
@using Extension.Helper
@using Extension.Models.Messages.AppBw
@using Extension.Models.Messages.BwApp
@using Extension.Models.Messages.BwApp.Requests
@using Extension.Models.Storage
@using Extension.Services
@using Extension.Services.Storage
@using MudBlazor
@using FluentResults

@inject ILogger<RequestSignHeadersPage> logger
@inject IStorageService storageService
@inject IWebsiteConfigService websiteConfigService

@code {
    // Page-specific fields
    private MudButton? signRequestButton;

    static readonly HashSet<string> SafeMethods = new(StringComparer.OrdinalIgnoreCase)
    {
        "GET",
        "HEAD",
        "OPTIONS"
    };

    // Page-specific properties
    string PayloadJson { get; set; } = "";
    string RequestUrl { get; set; } = "";
    string RequestMethod { get; set; } = "GET";
    Dictionary<string, string> HeadersDict { get; set; } = new();
    bool IsExpanded { get; set; }
    WebsiteConfig? ThisWebsiteConfig { get; set; }
    string? SelectedPrefix { get; set; }
    string? SelectedAlias { get; set; }

    // Computed properties
    public bool HasSafeHttpRequestMethod => SafeMethods.Contains(RequestMethod);
    bool IsAutoSignSafeHeaders => ThisWebsiteConfig?.IsAutoSignSafeHeaders ?? false;
    string ExpandIcon => IsExpanded ? Icons.Material.Filled.ExpandLess : Icons.Material.Filled.ExpandMore;
    Preferences Prefs => AppCache.MyPreferences;
    bool IsDetailShown => Prefs.IsSignRequestDetailShown;
    bool IsSignDisabled => SelectedPrefix is null;

    Uri? GetRequestUri()
    {
        if (string.IsNullOrEmpty(RequestUrl))
            return null;
        return Uri.TryCreate(RequestUrl, UriKind.Absolute, out var uri) ? uri : null;
    }

    bool HasOriginMismatch
    {
        get
        {
            var pageUri = GetOriginUri();
            var requestUri = GetRequestUri();
            if (pageUri is null || requestUri is null)
                return false;
            return !string.Equals(pageUri.Scheme, requestUri.Scheme, StringComparison.OrdinalIgnoreCase)
                || !string.Equals(pageUri.Host, requestUri.Host, StringComparison.OrdinalIgnoreCase)
                || pageUri.Port != requestUri.Port;
        }
    }

    string PageOriginDisplay
    {
        get
        {
            var uri = GetOriginUri();
            if (uri is null) return OriginStr;
            return uri.IsDefaultPort
                ? $"{uri.Scheme}://{uri.Host}"
                : $"{uri.Scheme}://{uri.Host}:{uri.Port}";
        }
    }

    string RequestOriginDisplay
    {
        get
        {
            var uri = GetRequestUri();
            if (uri is null) return RequestUrl;
            return uri.IsDefaultPort
                ? $"{uri.Scheme}://{uri.Host}"
                : $"{uri.Scheme}://{uri.Host}:{uri.Port}";
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        logger.LogInformation("OnInitializedAsync");

        var payload = await InitializeFromPendingRequestAsync<RequestSignHeadersPayload>(
            BwAppMessageType.Values.RequestSignHeaders);
        if (payload is null)
        {
            return;
        }

        // Load the active tab for display
        await LoadActiveTabAsync();

        // Extract page-specific values from the payload
        RequestUrl = payload.Url;
        RequestMethod = payload.Method;
        HeadersDict = payload.Headers;
        PayloadJson = JsonSerializer.Serialize(payload.Headers);

        logger.LogInformation("OnInitializedAsync: url={Url}, method={Method}, headersCount={HeadersCount}",
            RequestUrl, RequestMethod, HeadersDict?.Count ?? 0);
        if (HeadersDict != null && HeadersDict.Count > 0) {
            foreach (var kvp in HeadersDict) {
                logger.LogDebug("OnInitializedAsync: header[{Key}]={Value}", kvp.Key, kvp.Value);
            }
        }

        // Note: IsAutoSignSafeHeaders will be false here (before WebsiteConfigDisplay fires ValueChanged).
        // This is safe since the block below is a TODO no-op.
        if (IsAutoSignSafeHeaders && HasSafeHttpRequestMethod && !HasOriginMismatch)
        {
            // TODO P2: Move this logic into BackgroundWorker.cs, to avoid calling this page altogether.
            // TODO P2 notify the user signing is happening, and close?
        }

        IsInitialized = true;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && signRequestButton is not null)
        {
            // allow time for animation
            await Task.Delay(100);
            await signRequestButton.FocusAsync();
        }
    }

    Uri? GetOriginUri()
    {
        try
        {
            // Use the origin from the payload (set in OnInitializedAsync), not App.InitialUri
            // App.InitialUri would be the SidePanel/popup URL, not the requesting page's origin
            if (string.IsNullOrEmpty(OriginStr) || OriginStr == "unset")
            {
                logger.LogWarning("GetOriginUri: OriginStr not set");
                return null;
            }
            return new Uri(OriginStr);
        }
        catch (Exception ex)
        {
            logger.LogError("GetOriginUri: Error parsing OriginStr '{o}': {e}", OriginStr, ex);
            return null;
        }
    }

    async Task SetIsDetailShown(bool isDetailShown)
    {
        // TODO P3 IsSignRequestDetailShown should be per website, since not every site should be trusted the same
        await storageService.SetItem<Preferences>(Prefs with { IsSignRequestDetailShown = isDetailShown });
        return;
    }

    async Task updateIsAutoSignSafeHeaders(bool isChecked)
    {
        if (ThisWebsiteConfig is not null && ThisWebsiteConfig.IsAutoSignSafeHeaders != isChecked)
        {
            ThisWebsiteConfig = ThisWebsiteConfig with { IsAutoSignSafeHeaders = isChecked };
            await websiteConfigService.Update(ThisWebsiteConfig);
        }
        StateHasChanged();
    }

    async Task Cancel()
    {
        await CancelAndReturnAsync("User canceled sign headers request");
    }

    void ToggleExpand()
    {
        IsExpanded = !IsExpanded;
    }

    private async Task ApproveRequestHandler()
    {
        await BeginActionAsync();

        if (SelectedPrefix is null)
        {
            logger.LogError("ApproveRequestHandler: SelectedPrefix is null");
            return;
        }

        var message = new AppBwReplySignMessage(TabId, OriginStr, PageRequestId, OriginStr, RequestUrl, RequestMethod, HeadersDict, SelectedPrefix);
        await AppBwPortService.SendToBackgroundWorkerAsync(message);
        MarkAsReplied();

        // Clear the pending request now that approval is complete
        await ClearPendingRequestAsync();
        await WaitForAppCacheClearAsync();
        await ReturnToPriorUIAsync();
    }

    private async Task HandleIdOrCredChanged((string selectedPrefix, string selectedAlias, RecursiveDictionary? selectedCredentialOrNothing, WebsiteConfig? websiteConfig) value)
    {
        logger.LogInformation("HandleIdOrCredChanged prefix {Prefix}", value.selectedPrefix);
        SelectedPrefix = value.selectedPrefix;
        SelectedAlias = value.selectedAlias;
        ThisWebsiteConfig = value.websiteConfig;
        StateHasChanged();
        if (signRequestButton is not null)
        {
            await signRequestButton.FocusAsync();
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" || e.Code == "NumpadEnter")
        {
            await ApproveRequestHandler();
        }
    }
}

@if (IsInitialized)
{
    <div id="@this.GetType().Name" class="bt-body-page">
        <MudStack Class="bt-main">
            <div class="bt-main-inside-scroll">
                <PageHeading Title="Request to Sign HTTP Request Headers" />
                @if (ActiveTab is not null)
                {
                    <TabInteractionDisplay ActiveTab=@ActiveTab />
                }
                <MudText Typo="Typo.body1" Class="bt-help-text">
                    This website is asking you to digitally sign certain request details using your selected profile.
                    Your digital signature enables this website to verify your identity and confirm that the request is authorized by you.
                </MudText>
                <WebsiteConfigDisplay OriginStr="@OriginStr" IsOriginShown="false" IsCredentialShown="false" IsAutoSignShown="false" ValueChanged="async (v) => await HandleIdOrCredChanged(v)" />
                <MudText Class="bt-section-title">Request to Sign</MudText>
                <MudPaper Elevation="0" Class="ml-4 pa-2" Style="background-color: var(--mud-palette-background-grey);">
                    <MudText><b>Method:</b> @RequestMethod</MudText>
                    <MudText Style="word-break: break-all;"><b>URL:</b> @RequestUrl</MudText>
                </MudPaper>
                @if (HasOriginMismatch)
                {
                    <MudAlert Severity="Severity.Warning" Dense="true" Class="mt-2">
                        <MudText Typo="Typo.body2" Style="font-weight:bold;">Cross-Origin Request</MudText>
                        <MudText Typo="Typo.body2">
                            The page origin <b>@PageOriginDisplay</b> differs from the request URL origin
                            <b>@RequestOriginDisplay</b>.
                            Verify that you trust this page to sign requests to the destination URL.
                        </MudText>
                    </MudAlert>
                }
                
                @if (HeadersDict.Count > 0)
                {
                    <MudStack Row>
                        <MudCheckBox Label="Show Additional Headers" Value="IsDetailShown" ValueChanged="async (bool b) => await SetIsDetailShown(b)" Style="padding-left:0;"></MudCheckBox>
                    </MudStack>
                    @if (IsDetailShown)
                    {
                        <MudPaper Elevation="0" Class="ml-12">
                            <table class="non-responsive-table">
                                <thead style="text-align:left;">
                                    <tr>
                                        <th class="content-width-col">Key</th>
                                        <th class="remaining-width-col">Value</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @foreach (var item in HeadersDict)
                                    {
                                        <tr>
                                            <td class="content-width-col">@item.Key</td>
                                            <td class="remaining-width-col">@item.Value</td>
                                        </tr>
                                    }
                                </tbody>
                            </table>
                        </MudPaper>
                    }
                }
                <MudCheckBox Label="Always auto-sign HTTP Request Headers that are safe and read-only (i.e., GET, HEAD, OPTIONS, TRACE)" Value="IsAutoSignSafeHeaders" ValueChanged="async (bool b) => await updateIsAutoSignSafeHeaders(b)" Style="padding-left:0; height: 2rem;" />
            </div>
        </MudStack>
        <MudStack Row="true" class="bt-button-tray">
            <MudSpacer />
            <MudButton StartIcon="@Icons.Material.Filled.Cancel" Variant="Variant.Filled" Color="Color.Tertiary" OnClick="@(async (_) => await Cancel())">Reject</MudButton>
            <MudButton @ref="signRequestButton"
                       StartIcon="@Icons.Material.Filled.Login"
                       Disabled="IsSignDisabled"
                       Variant="Variant.Filled"
                       Color="Color.Primary"
                       OnClick="ApproveRequestHandler"
                       @onkeydown="HandleKeyDown">
                Approve & Sign
            </MudButton>
        </MudStack>
    </div>
}

<style>
    .content-width-col {
        width: 1%;
        white-space: nowrap;
    }

    .remaining-width-col {
        word-break: break-all;
        text-overflow: unset;
        word-wrap: anywhere;
        width: auto;
        white-space: unset !important;
    }

    .non-responsive-table {
        table-layout: fixed;
        border-collapse: collapse;
        text-align: left;
        vertical-align: baseline;
    }

        .non-responsive-table th,
        .non-responsive-table td {
            border: 1px solid #ddd;
            padding: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            vertical-align: baseline;
        }

        .non-responsive-table th {
            font-weight: bold;
        }
</style>
