@page "/RequestSignHeaders.html"
@layout Layouts.DialogLayout
@inherits Extension.UI.Components.TabDialogPageBase

@using System.Linq
@using System.Text.Json
@using Extension.Helper
@using Extension.Models
@using Extension.Models.Messages.AppBw
@using Extension.Models.Messages.BwApp
@using Extension.Models.Messages.BwApp.Requests
@using Extension.Models.Storage
@using Extension.Services
@using Extension.Services.Storage
@using Extension.Services.SignifyService
@using Extension.Services.SignifyService.Models
@using static Extension.AppConfig
@using MudBlazor
@using FluentResults

@inject ILogger<RequestSignHeadersPage> logger
@inject IStorageService storageService
@inject IWebsiteConfigService websiteConfigService

@code {
    // Page-specific fields
    private MudButton? signRequestButton;

    static readonly HashSet<string> SafeMethods = new(StringComparer.OrdinalIgnoreCase)
    {
        "GET",
        "HEAD",
        "OPTIONS"
    };

    // Page-specific properties
    string PayloadJson { get; set; } = "";
    string RequestUrl { get; set; } = "";
    string RequestMethod { get; set; } = "GET";
    Dictionary<string, string> HeadersDict { get; set; } = new();
    bool IsExpanded { get; set; }
    enum SignInMode { Credential, Identifier, Prompt }
    WebsiteConfig? ThisWebsiteConfig { get; set; }
    List<RecursiveDictionary> credentials = new();
    SignInMode RequestedSignInMode { get; set; } = SignInMode.Prompt;
    string WebsiteConfiguredPrefix { get; set; } = "unknown";
    List<Aid>? Identifiers { get; set; }

    // Computed properties
    public bool HasSafeHttpRequestMethod => SafeMethods.Contains(RequestMethod);
    bool IsAutoSignIn => ThisWebsiteConfig?.IsAutoSignInCredential ?? false;
    bool IsAutoSignSafeHeaders => ThisWebsiteConfig?.IsAutoSignSafeHeaders ?? false;
    string ExpandIcon => IsExpanded ? Icons.Material.Filled.ExpandLess : Icons.Material.Filled.ExpandMore;
    string WebsiteConfiguredAlias => Identifiers?.Find(x => x.Prefix == WebsiteConfiguredPrefix)?.Name ?? "not configured";
    Preferences Prefs => AppCache.MyPreferences;
    string SelectedPrefix => AppCache.SelectedPrefix ?? "";
    bool IsDetailShown => Prefs.IsSignRequestDetailShown;

    Uri? GetRequestUri()
    {
        if (string.IsNullOrEmpty(RequestUrl))
            return null;
        return Uri.TryCreate(RequestUrl, UriKind.Absolute, out var uri) ? uri : null;
    }

    bool HasOriginMismatch
    {
        get
        {
            var pageUri = GetOriginUri();
            var requestUri = GetRequestUri();
            if (pageUri is null || requestUri is null)
                return false;
            return !string.Equals(pageUri.Scheme, requestUri.Scheme, StringComparison.OrdinalIgnoreCase)
                || !string.Equals(pageUri.Host, requestUri.Host, StringComparison.OrdinalIgnoreCase)
                || pageUri.Port != requestUri.Port;
        }
    }

    string PageOriginDisplay
    {
        get
        {
            var uri = GetOriginUri();
            if (uri is null) return OriginStr;
            return uri.IsDefaultPort
                ? $"{uri.Scheme}://{uri.Host}"
                : $"{uri.Scheme}://{uri.Host}:{uri.Port}";
        }
    }

    string RequestOriginDisplay
    {
        get
        {
            var uri = GetRequestUri();
            if (uri is null) return RequestUrl;
            return uri.IsDefaultPort
                ? $"{uri.Scheme}://{uri.Host}"
                : $"{uri.Scheme}://{uri.Host}:{uri.Port}";
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        logger.LogInformation("OnInitializedAsync");

        var payload = await InitializeFromPendingRequestAsync<RequestSignHeadersPayload>(
            BwAppMessageType.Values.RequestSignHeaders);
        if (payload is null)
        {
            return;
        }

        // Load the active tab for display
        await LoadActiveTabAsync();

        // Extract page-specific values from the payload
        RequestUrl = payload.Url;
        RequestMethod = payload.Method;
        HeadersDict = payload.Headers;
        PayloadJson = JsonSerializer.Serialize(payload.Headers);
        WebsiteConfiguredPrefix = payload.RememberedPrefix ?? "unknown";

        logger.LogInformation("OnInitializedAsync: url={Url}, method={Method}, headersCount={HeadersCount}",
            RequestUrl, RequestMethod, HeadersDict?.Count ?? 0);
        if (HeadersDict != null && HeadersDict.Count > 0) {
            foreach (var kvp in HeadersDict) {
                logger.LogDebug("OnInitializedAsync: header[{Key}]={Value}", kvp.Key, kvp.Value);
            }
        }

        LoadIdentifiersFromCache();
        await RefreshFromWebsiteConfig();

        if (IsAutoSignSafeHeaders && HasSafeHttpRequestMethod && !HasOriginMismatch)
        {
            // TODO P2: Move this logic into BackgroundWorker.cs, to avoid calling this page altogether.
            // TODO P2 notify the user signing is happening, and close?
        }

        IsInitialized = true;
    }

    private void LoadIdentifiersFromCache()
    {
        // Guard against null during session timeout navigation
        var identifiersList = AppCache?.MyKeriaConnectionInfo?.IdentifiersList;
        if (identifiersList is not null && identifiersList.Count > 0 && identifiersList[0].Aids is not null)
        {
            Identifiers = identifiersList[0].Aids.OrderBy(a => a.Name).ToList();
        }
        else
        {
            // During session timeout, identifiers may be unavailable - this is expected
            logger.LogWarning("LoadIdentifiersFromCache: identifiers unavailable in cache");
            Identifiers = null;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && signRequestButton is not null)
        {
            // allow time for animation
            await Task.Delay(100);
            await signRequestButton.FocusAsync();
        }
    }

    Uri? GetOriginUri()
    {
        try
        {
            // Use the origin from the payload (set in OnInitializedAsync), not App.InitialUri
            // App.InitialUri would be the SidePanel/popup URL, not the requesting page's origin
            if (string.IsNullOrEmpty(OriginStr) || OriginStr == "unset")
            {
                logger.LogWarning("GetOriginUri: OriginStr not set");
                return null;
            }
            return new Uri(OriginStr);
        }
        catch (Exception ex)
        {
            logger.LogError("GetOriginUri: Error parsing OriginStr '{o}': {e}", OriginStr, ex);
            return null;
        }
    }

    async Task SetIsDetailShown(bool isDetailShown)
    {
        // TODO P3 IsSignRequestDetailShown should be per website, since not every site should be trusted the same
        await storageService.SetItem<Preferences>(Prefs with { IsSignRequestDetailShown = isDetailShown });
        return;
    }

    async Task updateIsAutoSignSafeHeaders(bool isChecked)
    {
        if (ThisWebsiteConfig is not null && ThisWebsiteConfig.IsAutoSignSafeHeaders != isChecked)
        {
            ThisWebsiteConfig = ThisWebsiteConfig with { IsAutoSignSafeHeaders = isChecked };
            await websiteConfigService.Update(ThisWebsiteConfig);
        }
        StateHasChanged();
    }

    // TODO P2 DRY with similar method in WebsiteConfigDisplay
    async Task RefreshFromWebsiteConfig()
    {
        var originUri = GetOriginUri();
        if (originUri is null)
        {
            throw new InvalidOperationException($"RefreshThisWebsiteConfig: origin must be set.");
        }

        var getOrCreateWebsiteRes = await websiteConfigService.GetOrCreateWebsiteConfig(originUri);
        if (getOrCreateWebsiteRes.IsFailed)
        {
            throw new InvalidOperationException($"Error from websiteService {getOrCreateWebsiteRes.Errors}");
        }
        var (websiteConfig, isConfigNew) = getOrCreateWebsiteRes.Value;
        ThisWebsiteConfig = websiteConfig;

        if (isConfigNew)
        {
            WebsiteConfiguredPrefix = AppCache.SelectedPrefix ?? "unknown";
            ThisWebsiteConfig = ThisWebsiteConfig with { RememberedPrefixOrNothing = WebsiteConfiguredPrefix };
            await websiteConfigService.Update(ThisWebsiteConfig);
        }
        else
        {
            WebsiteConfiguredPrefix = ThisWebsiteConfig.RememberedPrefixOrNothing!;
        }
        StateHasChanged();
    }

    async Task Cancel()
    {
        await CancelAndReturnAsync("User canceled sign headers request");
    }

    void ToggleExpand()
    {
        IsExpanded = !IsExpanded;
    }

    private async Task ApproveRequestHandler()
    {
        await BeginActionAsync();

        var message = new AppBwReplySignMessage(TabId, OriginStr, PageRequestId, OriginStr, RequestUrl, RequestMethod, HeadersDict, WebsiteConfiguredPrefix);
        await AppBwPortService.SendToBackgroundWorkerAsync(message);
        MarkAsReplied();

        // Clear the pending request now that approval is complete
        await ClearPendingRequestAsync();
        await WaitForAppCacheClearAsync();
        await ReturnToPriorUIAsync();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" || e.Code == "NumpadEnter")
        {
            await ApproveRequestHandler();
        }
    }
}

@if (IsInitialized)
{
    <div id="@this.GetType().Name" class="bt-body-page">
        <MudStack Class="bt-main">
            <div class="bt-main-inside-scroll">
                <PageHeading Title="Request to Sign HTTP Request Headers" />
                @if (ActiveTab is not null)
                {
                    <TabInteractionDisplay ActiveTab=@ActiveTab />
                }
                <MudText class="mt-6" Typo="Typo.body1">
                    This website is requesting KERI Auth, with your approval,
                    to cryptographically sign HTTP Request Headers with the key material of the profile you selected for this site when you signed in to it.
                    The resulting signature and other headers will then allow the server for the requested url to validate and authorize the request.
                </MudText>
                <MudText Class="mt-2"><b>Request to Sign</b></MudText>
                <MudPaper Elevation="0" Class="ml-4 pa-2" Style="background-color: var(--mud-palette-background-grey);">
                    <MudText><b>Method:</b> @RequestMethod</MudText>
                    <MudText Style="word-break: break-all;"><b>URL:</b> @RequestUrl</MudText>
                </MudPaper>
                @if (HasOriginMismatch)
                {
                    <MudAlert Severity="Severity.Warning" Dense="true" Class="mt-2">
                        <MudText Typo="Typo.body2" Style="font-weight:bold;">Cross-Origin Request</MudText>
                        <MudText Typo="Typo.body2">
                            The page origin <b>@PageOriginDisplay</b> differs from the request URL origin
                            <b>@RequestOriginDisplay</b>.
                            Verify that you trust this page to sign requests to the destination URL.
                        </MudText>
                    </MudAlert>
                }
                <MudText Class="mt-4"><b>Signing Profile</b></MudText>
                <MudStack Row Class="pl-1" Style="align-items:center;">
                    <MudIcon Icon=@Helper.Identicon.MakeIdenticon(WebsiteConfiguredPrefix) ViewBox="0 0 100 100" Class="bt-identicon" Style="margin-top: 0.214rem;" />
                    <MudText>@WebsiteConfiguredAlias</MudText>
                </MudStack>
                @if (HeadersDict.Count > 0)
                {
                    <MudStack Row>
                        <MudCheckBox Label="Show Additional Headers" Value="IsDetailShown" ValueChanged="async (bool b) => await SetIsDetailShown(b)" Style="padding-left:0;"></MudCheckBox>
                    </MudStack>
                    @if (IsDetailShown)
                    {
                        <MudPaper Elevation="0" Class="ml-12">
                            <table class="non-responsive-table">
                                <thead style="text-align:left;">
                                    <tr>
                                        <th class="content-width-col">Key</th>
                                        <th class="remaining-width-col">Value</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @foreach (var item in HeadersDict)
                                    {
                                        <tr>
                                            <td class="content-width-col">@item.Key</td>
                                            <td class="remaining-width-col">@item.Value</td>
                                        </tr>
                                    }
                                </tbody>
                            </table>
                        </MudPaper>
                    }
                }
                <MudCheckBox Label="Always auto-sign Http Request Headers that are safe and read-only (i.e., GET, HEAD, OPTIONS, TRACE)" Value="IsAutoSignSafeHeaders" ValueChanged="async (bool b) => await updateIsAutoSignSafeHeaders(b)" Style="padding-left:0; height: 2rem;" />
            </div>
        </MudStack>
        <MudStack Row="true" class="bt-button-tray">
            <MudSpacer />
            <MudButton StartIcon="@Icons.Material.Filled.Cancel" Variant="Variant.Filled" Color="Color.Tertiary" OnClick="@(async (_) => await Cancel())">Reject</MudButton>
            <MudButton @ref="signRequestButton"
                       StartIcon="@Icons.Material.Filled.Login"
                       Variant="Variant.Filled"
                       Color="Color.Primary"
                       OnClick="ApproveRequestHandler"
                       @onkeydown="HandleKeyDown">
                Approve & Sign
            </MudButton>
        </MudStack>
    </div>
}

<style>
    .mud-select .mud-select-input .mud-input-slot {
        height: auto;
    }

    .selected-item {
        border-left: 4px solid blue;
    }

    .content-width-col {
        width: 1%;
        white-space: nowrap;
    }

    .remaining-width-col {
        word-break: break-all;
        text-overflow: unset;
        word-wrap: anywhere;
        width: auto;
        white-space: unset !important;
    }

    .non-responsive-table {
        table-layout: fixed;
        border-collapse: collapse;
        text-align: left;
        vertical-align: baseline;
    }

        .non-responsive-table th,
        .non-responsive-table td {
            border: 1px solid #ddd;
            padding: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            vertical-align: baseline;
        }

        .non-responsive-table th {
            font-weight: bold;
        }
</style>
