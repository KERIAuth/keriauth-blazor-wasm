@page "/Configure.html"
@using Extension.Models
@using Extension.Models.Storage
@using Extension.Services.Storage
@using Extension.Utilities
@using Extension.UI.Components

@using Extension.Services.Port
@using Extension.Models.Messages.AppBw

@inject IStorageService storageService
@inject ILogger<ConfigurePage> logger
@inject HttpClient httpClient
@inject NavigationManager navManager
@inject IJSRuntime js
@inject ISnackbar snackbar
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject AppCache appCache
@inject IAppBwPortService appBwPortService
@inject IScrollManager scrollManager
@using FluentResults
@using Extension.Helper
@using System.Globalization

@implements IAsyncDisposable

@code {
    // TODO P2 restructure as a record?
    struct Preset
    {
        public string ProviderName { get; init; }
        public string AgentUrl { get; init; }
        public string BootUrl { get; init; }
        public Preset(string provider, string adminUrl, string bootUrl)
        {
            ProviderName = provider;
            AgentUrl = adminUrl;
            BootUrl = bootUrl;
        }
    }

    class UrlModel
    {
        // TODO P2 add setters that validate these values are a URL.  If not equal to the selected preset, set the preset to "Custom"
        [Required]
        [Url(ErrorMessage = "Enter KERIA Agent Admin URL")]
        public string AdminUrl { get; set; } = presetAgents[0].AgentUrl;

        public string? BootUrl { get; set; } = presetAgents[0].BootUrl;
    }

    // TODO P3 DRY with UnlockView
    class PasscodeFormModel
    {
        [Required]
        [StringLength(21, ErrorMessage = "Passcode must be 21 characters long", MinimumLength = 21)]
        [DataType(DataType.Password)]
        public string Passcode { get; set; } = "";
    }

    // fields
    KeriaConnectConfig defaultKeriaConnectConfig => new KeriaConnectConfig(defaultPreset.ProviderName, defaultPreset.AgentUrl, defaultPreset.BootUrl, 0);

    // Operation displays - instance properties for proper state isolation per page instance
    OperationDisplay Ops1CheckLiveness { get; } = new OperationDisplay("Checking KERIA liveness", "KERIA live");
    OperationDisplay Ops2CheckHealth { get; } = new OperationDisplay("Checking KERIA health", "... healthy");
    OperationDisplay Ops3Connect { get; } = new OperationDisplay("Connecting", "... connected");
    OperationDisplay Ops4ListAids { get; } = new OperationDisplay("Retrieving your profiles", "Retrieved profiles");
    OperationDisplay Ops5CreatePersonalAid { get; } = new OperationDisplay("Creating personal profile", "Created new profile");
    OperationDisplay Ops6AllDone { get; } = new OperationDisplay("Press Next to continue", "Press Next to continue →");
    // TODO P2 load presets from AppConfig or external source
    static List<Preset> presetAgents = new List<Preset>
    {
        new Preset("KERI Auth Test Cloud", "https://keria.cloud.keriauth.com", "https://keria-boot.cloud.keriauth.com"),
        // TODO P2: add basic auth for agent Boot
        // Note: GLEIF Test Cloud boot is :3903; however, that requires a HTTP Basic Auth request, and we don't yet support sending a Base64-encoded username (empty) and password, e.g. "Authorization: Basic dXNlcjpwYXNzd29yZA=="
        new Preset("GLEIF Test Cloud", "https://keria.testnet.gleif.org:3901", ""),
        new Preset("Veridian Testnet", "https://keria.veridian.dandelion.link", "https://keria-boot.veridian.dandelion.link"),
        new Preset("Veridian Dev Testnet", "https://keria.dev.idw-sandboxes.cf-deployments.org", "https://keria-boot.dev.idw-sandboxes.cf-deployments.org"),
        new Preset("localhost", AppConfig.LocalhostKeriaAdminUrl, AppConfig.LocalhostKeriaBootUrl),
        new Preset("Custom", "", "")
    };
    private MudTextField<string>? _newPasscodeTextField;
    WebExtensionsApi? webExtensionsApi;
    Preset _presetChoice = presetAgents[0];
    UrlModel urlModel = new UrlModel()
    {
        AdminUrl = presetAgents[0].AgentUrl,
        BootUrl = presetAgents[0].BootUrl,
    };
    PasscodeFormModel configuredPasscodeModel = new PasscodeFormModel();
    private ElementReference _pageContainer;
    private MudButton? nextButton;
    private MudButton? connectButton;
    private MudButton? resetButton;

    // properties
    KeriaConnectConfig? KeriaConnectConfig { get; set; }
    string RandomPasscode { get; set; } = "";
    bool IsRandomPasscodeRevealed { get; set; } = false;
    bool IsPasscodeCopyConfirmed { get; set; }
    bool IsUsingExistingPasscode { get; set; } = true;
    bool IsProcessing { get; set; }
    bool IsConnected { get; set; }
    bool IsReadyForNext { get; set; }

    // Ratcheting gates - prevent backtracking during configuration flow
    // Gate 1: Set when Connect is clicked, disables Provider/URL fields
    bool IsFlowStarted { get; set; }
    // Gate 2: Set when passcode is used in Connect call, disables passcode fields
    bool IsPasscodeUsed { get; set; }

    // Flow step tracking - drives reactive operation state rendering
    enum FlowStep { NotStarted, Ops1, Ops2, Ops3, Ops4, Ops5, Done, Failed }
    FlowStep _currentStep = FlowStep.NotStarted;
    int? _failedAtStep = null; // Track which step failed for error display
    string? _errorMessage = null; // Error message for failed step
    Preset PresetChoice
    {
        get
        {
            return _presetChoice;
        }
        set
        {
            _presetChoice = value;
            urlModel.AdminUrl = value.AgentUrl;
            urlModel.BootUrl = value.BootUrl;
        }
    }

    // reactive properties
    Preset defaultPreset => presetAgents[0];
    bool IsValidAdminURL =>
        !string.IsNullOrWhiteSpace(urlModel.AdminUrl) &&
        Uri.IsWellFormedUriString(urlModel.AdminUrl, UriKind.Absolute);
    bool IsValidBootURL =>
        !string.IsNullOrWhiteSpace(urlModel.BootUrl) &&
        Uri.IsWellFormedUriString(urlModel.BootUrl, UriKind.Absolute);
    bool IsValidNewInfo =>
        IsValidAdminURL
        && !string.IsNullOrWhiteSpace(configuredPasscodeModel.Passcode)
        && configuredPasscodeModel.Passcode.Length == 21
        && (IsUsingExistingPasscode
            || (IsValidBootURL
                && RandomPasscode == configuredPasscodeModel.Passcode
                && IsPasscodeCopyConfirmed)
        );
    bool IsKeriaConfigured => (KeriaConnectConfig is not null) && KeriaConnectConfig.ValidateConfiguration().IsSuccess;
    string BootUrlLabel => IsUsingExistingPasscode ? "Boot URL (optional if you have established KERIA connection passcode)" : "Boot URL";

    // Computed operation states based on current flow step
    // Each operation shows: InvisibleInactive (not applicable), Pending (waiting), Running (current), CompletedSuccess, or uses stored error state
    OperationState Ops1State => ComputeOpState(1, IsValidBootURL);
    OperationState Ops2State => ComputeOpState(2, IsValidBootURL);
    OperationState Ops3State => ComputeOpState(3, true);
    OperationState Ops4State => ComputeOpState(4, true);
    OperationState Ops5State => ComputeOpState(5, !IsUsingExistingPasscode && !_ops5Skipped);
    OperationState Ops6State => _currentStep == FlowStep.Done ? OperationState.CompletedSuccess : (_currentStep != FlowStep.NotStarted ? OperationState.Pending : OperationState.InvisibleInactive);

    bool _ops5Skipped = false; // Set when existing account has identifiers

    OperationState ComputeOpState(int opNumber, bool isApplicable)
    {
        if (!isApplicable || _currentStep == FlowStep.NotStarted)
            return OperationState.InvisibleInactive;

        int currentStepNumber = _currentStep switch
        {
            FlowStep.Ops1 => 1,
            FlowStep.Ops2 => 2,
            FlowStep.Ops3 => 3,
            FlowStep.Ops4 => 4,
            FlowStep.Ops5 => 5,
            FlowStep.Done => 6,
            FlowStep.Failed => _failedAtStep ?? 0,
            _ => 0
        };

        if (_currentStep == FlowStep.Failed && _failedAtStep == opNumber)
            return OperationState.CompletedFailed;

        if (opNumber < currentStepNumber || _currentStep == FlowStep.Done)
            return OperationState.CompletedSuccess;

        if (opNumber == currentStepNumber && _currentStep != FlowStep.Failed)
            return OperationState.Running;

        return OperationState.Pending;
    }

    // Focus state - determines which element should have focus
    enum FocusTarget { None, Passcode, ConfirmPasscode, Connect, Next, Reset }
    FocusTarget _focusTarget = FocusTarget.Passcode;
    bool ShouldFocusPasscode => _focusTarget == FocusTarget.Passcode && IsUsingExistingPasscode;
    bool ShouldFocusConfirmPasscode => _focusTarget == FocusTarget.ConfirmPasscode && !IsUsingExistingPasscode && IsPasscodeCopyConfirmed;
    bool ShouldFocusConnect => _focusTarget == FocusTarget.Connect;

    protected override async Task OnInitializedAsync()
    {
        webExtensionsApi = new WebExtensionsApi(jsRuntimeAdapter);

        // Subscribe to AppCache changes - will trigger StateHasChanged when state updates
        await this.SubscribeToAppCache(appCache);
    }

    public async ValueTask DisposeAsync()
    {
        this.UnsubscribeFromAppCache();
        GC.SuppressFinalize(this);
    }

    protected override async Task OnAfterRenderAsync(bool isFirstRender)
    {
        // Handle button focus imperatively (MudButton doesn't support AutoFocus)
        if (_focusTarget == FocusTarget.Connect && connectButton is not null)
        {
            // allow time for animation
            await Task.Delay(100);
            _focusTarget = FocusTarget.None;
            await connectButton.FocusAsync();
        }
        else if (_focusTarget == FocusTarget.Next && nextButton is not null)
        {
            // allow time for animation
            await Task.Delay(100);
            _focusTarget = FocusTarget.None;
            await nextButton.FocusAsync();
        }
        else if (_focusTarget == FocusTarget.Reset && resetButton is not null)
        {
            // allow time for animation
            await Task.Delay(100);
            _focusTarget = FocusTarget.None;
            await resetButton.FocusAsync();
        }
        else if (_focusTarget == FocusTarget.Passcode || _focusTarget == FocusTarget.ConfirmPasscode)
        {
            // Text fields use AutoFocus attribute - reset after first render so it triggers
            // allow time for animation
            await Task.Delay(100);
            _focusTarget = FocusTarget.None;
        }
    }

    void OnPasscodeChanged(string value)
    {
        // Check if pasted value is an 18-word BIP39 recovery phrase
        if (IsUsingExistingPasscode && !string.IsNullOrWhiteSpace(value))
        {
            var words = value.Trim().Split(new[] { ' ', '\t', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
            if (words.Length == 18 && Bip39MnemonicConverter.AreAllValidBip39Words(words))
            {
                try
                {
                    var convertedPasscode = Bip39MnemonicConverter.ConvertMnemonicToPasscode(words);
                    configuredPasscodeModel.Passcode = convertedPasscode;
                    snackbar.Add("Recovery phrase converted to passcode", Severity.Success);
                    _focusTarget = FocusTarget.Connect;
                    StateHasChanged();
                    return;
                }
                catch
                {
                    // If conversion fails, fall through to normal handling
                }
            }
        }

        configuredPasscodeModel.Passcode = value;
        if (value.Length == 21)
        {
            if (IsUsingExistingPasscode || value == RandomPasscode && IsPasscodeCopyConfirmed)
            {
                _focusTarget = FocusTarget.ConfirmPasscode;
            }
            StateHasChanged();
        }
    }

    async Task HandlePasscodeKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter" && IsValidNewInfo && !IsKeriaConfigured)
        {
            await UnifiedOnboardingFlow();
        }
    }

    void OnPasscodeCopyConfirmedChanged(bool value)
    {
        IsPasscodeCopyConfirmed = value;
        if (value)
        {
            _focusTarget = FocusTarget.ConfirmPasscode;
        }
    }

    async Task SetIsNewAccount(bool isNewAccount)
    {
        IsUsingExistingPasscode = !isNewAccount;
        RandomPasscode = RandomStringGenerator.GenerateRandomString(21);
        // clear in case radio is toggled after passcode is copied, entered
        configuredPasscodeModel.Passcode = "";
        IsPasscodeCopyConfirmed = false;
        // ResetOps();
        // intentionally NOT copying to clipboard since the user may prefer to only write it down manually due to security concerns
    }

    void ResetOps()
    {
        IsProcessing = false;
        _currentStep = FlowStep.NotStarted;
        _failedAtStep = null;
        _errorMessage = null;
        _ops5Skipped = false;
        IsReadyForNext = false;
    }

    void SetFlowFailed(int stepNumber, string errorMessage)
    {
        // Log full error for debugging, but sanitize for UI display
        logger.LogError("Flow failed at step {Step}: {Error}", stepNumber, errorMessage);

        _currentStep = FlowStep.Failed;
        _failedAtStep = stepNumber;
        _errorMessage = SanitizeErrorForDisplay(errorMessage);
        IsProcessing = false;
        _focusTarget = FocusTarget.Reset;
    }

    /// <summary>
    /// Extracts user-friendly error message, removing stack traces and technical details.
    /// </summary>
    static string SanitizeErrorForDisplay(string errorMessage)
    {
        if (string.IsNullOrWhiteSpace(errorMessage))
            return "An error occurred";

        // Find the first occurrence of " at " which typically starts a stack trace
        var atIndex = errorMessage.IndexOf(" at ", StringComparison.Ordinal);
        if (atIndex > 0)
            errorMessage = errorMessage[..atIndex].Trim();

        // Also handle "Error:" prefix pattern like "Error: Agent booted but cannot connect"
        if (errorMessage.StartsWith("Error: ", StringComparison.OrdinalIgnoreCase))
            errorMessage = errorMessage[7..];

        return errorMessage;
    }

    async Task UnifiedOnboardingFlow()
    {
        ResetOps();
        logger.LogInformation("UnifiedOnboardingFlow starting...");
        IsProcessing = true;

        // Ratchet Gate 1: Lock Provider/URL fields once flow starts
        IsFlowStarted = true;
        StateHasChanged();
        await Task.Yield(); // Let Blazor render the Connection section into the DOM
        await scrollManager.ScrollToBottomAsync("#connect-progress", ScrollBehavior.Smooth);

        // Validate preconditions
        if (!(IsValidNewInfo || IsKeriaConfigured))
        {
            snackbar.Add("Please complete all required fields", Severity.Error);
            IsProcessing = false;
            return;
        }

        // Step 0: Validate BootUrl for "Create new" flow
        if (!IsUsingExistingPasscode && !IsValidBootURL)
        {
            snackbar.Add("Boot URL is required for creating a new account", Severity.Error);
            IsProcessing = false;
            return;
        }

        // Step 1: Check KERIA liveness (if BootUrl is provided)
        if (IsValidBootURL)
        {
            _currentStep = FlowStep.Ops1;

            var baseUri = new Uri(urlModel.BootUrl!);
            var healthUri = new Uri(baseUri, "health");
            var healthUriBuilder = new UriBuilder(healthUri);

            // Send health check request to BackgroundWorker via RPC
            var healthCheckResponse = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestHealthCheck,
                new { payload = new HealthCheckRequestPayload(healthUriBuilder.Uri.ToString()) });

            if (!healthCheckResponse.Ok)
            {
                SetFlowFailed(1, healthCheckResponse.Error ?? "KERIA cloud service is not reachable");
                return;
            }

            // Parse the response payload
            var healthResult = healthCheckResponse.Result is System.Text.Json.JsonElement healthJsonEl
                ? System.Text.Json.JsonSerializer.Deserialize<HealthCheckResponsePayload>(healthJsonEl.GetRawText(), Extension.Helper.JsonOptions.CamelCase)
                : null;

            if (healthResult is null || !healthResult.Success)
            {
                SetFlowFailed(1, healthResult?.Error ?? "KERIA cloud service is not reachable");
                return;
            }

            // Step 2: Check if KERIA is reporting as healthy
            _currentStep = FlowStep.Ops2;
            var httpClientService2 = new HttpClientService(new HttpClient());
            var healthStatusResult = await httpClientService2.GetJsonAsync<String>(healthUriBuilder.Uri.ToString());
            if (!healthStatusResult.IsSuccess || healthStatusResult.Value.StatusCode != System.Net.HttpStatusCode.OK)
            {
                SetFlowFailed(2, healthStatusResult.Reasons.FirstOrDefault()?.Message ?? "KERIA health check failed");
                return;
            }
        }

        // Store partial KeriaConnectConfig with passcodeHash
        // Explicitly set IsStored = true to ensure it's persisted correctly
        int passcodeHash = DeterministicHash.ComputeHash(configuredPasscodeModel.Passcode);
        var partialConfig = new KeriaConnectConfig(
            providerName: _presetChoice.ProviderName,
            adminUrl: urlModel.AdminUrl,
            bootUrl: urlModel.BootUrl,
            passcodeHash: passcodeHash,
            clientAidPrefix: null, // will be set after Connect
            agentAidPrefix: null,  // will be set after Connect
            isStored: true
        )
        { Alias = "Configured at " + DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm", CultureInfo.InvariantCulture) + "UTC" };

        var storePartialConfigResult = await StoreKeriaConnectConfigAsync(partialConfig, setAsSelected: false);
        if (storePartialConfigResult.IsFailed)
        {
            logger.LogError("Failed to store partial connection config: {Errors}", string.Join(", ", storePartialConfigResult.Errors));
            SetFlowFailed(3, "Failed to store connection configuration");
            return;
        }

        // Wait for AppCache to reflect the partial config in KeriaConnectConfigs
        await appCache.WaitForAppCache([() => appCache.MyKeriaConnectConfigs.Configs.Values.Any(c => c.PasscodeHash != 0)]);
        // KeriaConnectConfigs PasscodeHash check passed

        // Step 3: Connect to KERIA
        _currentStep = FlowStep.Ops3;

        // Ratchet Gate 2: Lock passcode fields once passcode is used for connection
        IsPasscodeUsed = true;

        logger.LogInformation("Connecting to KERIA at {url}...", urlModel.AdminUrl);

        // Send connect request to BackgroundWorker via RPC
        var connectResponse = await appBwPortService.SendRpcRequestAsync(
            AppBwMessageType.Values.RequestConnect,
            new { payload = new ConnectRequestPayload(
                urlModel.AdminUrl,
                configuredPasscodeModel.Passcode,
                urlModel.BootUrl,
                !IsUsingExistingPasscode,
                passcodeHash) });

        if (!connectResponse.Ok)
        {
            SetFlowFailed(3, connectResponse.Error ?? "Connect failed");
            return;
        }

        // Parse the response payload
        var connectResult = connectResponse.Result is System.Text.Json.JsonElement connectJsonEl
            ? System.Text.Json.JsonSerializer.Deserialize<ConnectResponsePayload>(connectJsonEl.GetRawText(), Extension.Helper.JsonOptions.CamelCase)
            : null;

        if (connectResult is null || !connectResult.Success)
        {
            SetFlowFailed(3, connectResult?.Error ?? "Connect failed");
            return;
        }

        // Extract agent and client prefixes from Connect result
        string clientAidPrefix = connectResult.ClientAidPrefix!;
        string agentAidPrefix = connectResult.AgentAidPrefix!;

        // Store PasscodeModel to Session storage
        var sessionExpiry = DateTime.UtcNow.AddMinutes(appCache.MyPreferences.InactivityTimeoutMinutes);
        var passcodeModel = new PasscodeModel
        {
            Passcode = configuredPasscodeModel.Passcode,
            SessionExpirationUtc = sessionExpiry
        };

        var storePasscodeResult = await storageService.SetItem<PasscodeModel>(passcodeModel, StorageArea.Session);
        if (storePasscodeResult.IsFailed)
        {
            logger.LogError("Failed to store passcode: {Errors}", string.Join(", ", storePasscodeResult.Errors));
            SetFlowFailed(3, "Failed to store session passcode");
            return;
        }

        // Wait for PasscodeModel to be reflected in AppCache
        // Waiting for IsSessionPasscodeSet (current: {Value})", appCache.IsSessionPasscodeSet);
        await appCache.WaitForAppCache([() => appCache.IsSessionPasscodeSet]);
        // IsSessionPasscodeSet check passed

        // Waiting for IsSessionNotExpired (current: {Value})", appCache.IsSessionNotExpired);
        await appCache.WaitForAppCache([() => appCache.IsSessionNotExpired]);
        // IsSessionNotExpired check passed

        // Update KeriaConnectConfig with complete information
        var completeConfig = partialConfig with
        {
            ClientAidPrefix = clientAidPrefix,
            AgentAidPrefix = agentAidPrefix
        };

        // Compute the expected digest so we can wait for it specifically
        var expectedDigestResult = KeriaConnectionDigestHelper.Compute(completeConfig);
        if (expectedDigestResult.IsFailed)
        {
            logger.LogError("Failed to compute digest for complete config: {Errors}", string.Join(", ", expectedDigestResult.Errors));
            SetFlowFailed(3, "Failed to compute configuration digest");
            return;
        }
        var expectedDigest = expectedDigestResult.Value;
        logger.LogInformation("Computed expected digest for new config: {Digest}", expectedDigest);

        var storeCompleteConfigResult = await StoreKeriaConnectConfigAsync(completeConfig, setAsSelected: true);
        if (storeCompleteConfigResult.IsFailed)
        {
            logger.LogError("Failed to update connection config: {Errors}", string.Join(", ", storeCompleteConfigResult.Errors));
            SetFlowFailed(3, "Failed to update connection configuration");
            return;
        }

        // Wait for complete config to be reflected in AppCache (both KeriaConnectConfigs and Preferences)
        // CRITICAL: Wait for the SPECIFIC new digest, not just any non-empty digest.
        // This prevents race conditions when adding a new config while another already exists.
        var digestUpdated = await appCache.WaitForAppCache([
            () => appCache.IsConfigured,
            () => appCache.MyPreferences.KeriaPreference.SelectedKeriaConnectionDigest == expectedDigest
        ]);
        if (!digestUpdated)
        {
            logger.LogWarning("Timed out waiting for new digest {Digest} to appear in Preferences", expectedDigest);
        }
        // IsConfigured check passed
        KeriaConnectConfig = completeConfig;

        // Step 4: Get Identifiers (from storage - BW stored them after Connect)
        _currentStep = FlowStep.Ops4;

        // Wait for identifiers to be available in appCache (stored by BW's Connect handler)
        var waitSuccess = await appCache.WaitForAppCache([
            () => appCache.MyKeriaConnectionInfo.IdentifiersList is not null &&
                  appCache.MyKeriaConnectionInfo.IdentifiersList.Count > 0
        ], 30000, 100);

        if (!waitSuccess)
        {
            SetFlowFailed(4, "Timed out waiting for identifiers from BackgroundWorker");
            return;
        }

        var identifiers = appCache.MyKeriaConnectionInfo.IdentifiersList[0];

        // Step 5: Create identifier if none exist
        if (identifiers.Aids.Count == 0)
        {
            _currentStep = FlowStep.Ops5;

            // Send create AID request to BackgroundWorker via RPC
            var createAidResponse = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestCreateAid,
                new { payload = new CreateAidRequestPayload("Alias1") });

            if (!createAidResponse.Ok)
            {
                SetFlowFailed(5, createAidResponse.Error ?? "Failed to create identifier");
                return;
            }

            // Parse the response payload
            var createAidResult = createAidResponse.Result is System.Text.Json.JsonElement createAidJsonEl
                ? System.Text.Json.JsonSerializer.Deserialize<CreateAidResponsePayload>(createAidJsonEl.GetRawText(), Extension.Helper.JsonOptions.CamelCase)
                : null;

            if (createAidResult is null || !createAidResult.Success)
            {
                SetFlowFailed(5, createAidResult?.Error ?? "Failed to create identifier");
                return;
            }

            // Wait for identifiers to be updated in appCache (BW updates storage after CreateAid)
            var waitRefreshSuccess = await appCache.WaitForAppCache([
                () => appCache.MyKeriaConnectionInfo.IdentifiersList is not null &&
                      appCache.MyKeriaConnectionInfo.IdentifiersList.Count > 0 &&
                      appCache.MyKeriaConnectionInfo.IdentifiersList[0].Aids.Count > 0
            ], 30000, 100);

            if (!waitRefreshSuccess)
            {
                SetFlowFailed(5, "Timed out waiting for refreshed identifiers after creation");
                return;
            }

            identifiers = appCache.MyKeriaConnectionInfo.IdentifiersList[0];
        }
        else
        {
            // Existing account with identifiers - skip Ops5
            _ops5Skipped = true;
        }

        // Store SelectedPrefix in the KeriaConnectConfig
        if (identifiers.Aids.Count == 0)
        {
            SetFlowFailed(5, "No identifiers available after creation");
            return;
        }

        var selectedPrefix = identifiers.Aids.First().Prefix;

        // Get the digest from preferences (set earlier in this flow via StoreKeriaConnectConfigAsync)
        var selectedDigest = appCache.MyPreferences.KeriaPreference.SelectedKeriaConnectionDigest;
        if (string.IsNullOrEmpty(selectedDigest))
        {
            logger.LogError("SelectedKeriaConnectionDigest is not set in preferences");
            SetFlowFailed(5, "Configuration digest not found");
            return;
        }

        // Update the KeriaConnectConfig with SelectedPrefix
        var configs = appCache.MyKeriaConnectConfigs;
        if (configs.Configs.TryGetValue(selectedDigest, out var currentConfig))
        {
            var updatedConfig = currentConfig with { SelectedPrefix = selectedPrefix };
            var updatedConfigs = new Dictionary<string, KeriaConnectConfig>(configs.Configs) {
                [selectedDigest] = updatedConfig
            };
            var storeConfigsResult = await storageService.SetItem(new KeriaConnectConfigs {
                Configs = updatedConfigs,
                IsStored = true
            });
            if (storeConfigsResult.IsFailed)
            {
                logger.LogError("Failed to store config with SelectedPrefix: {Errors}", string.Join(", ", storeConfigsResult.Errors));
                SetFlowFailed(5, "Failed to store selected identifier");
                return;
            }
        }
        else
        {
            logger.LogError("Config not found for digest {Digest}", selectedDigest);
            SetFlowFailed(5, "Configuration not found");
            return;
        }

        // Wait for SelectedPrefix to be reflected in AppCache (via the config)
        await appCache.WaitForAppCache([() => !string.IsNullOrWhiteSpace(appCache.SelectedPrefix)]);
        // SelectedPrefix check passed

        // Store KeriaConnectionInfo to Session storage
        if (string.IsNullOrEmpty(selectedDigest))
        {
            logger.LogError("SelectedKeriaConnectionDigest is not set in preferences");
            SetFlowFailed(5, "Configuration digest not found");
            return;
        }

        var connectionInfo = new KeriaConnectionInfo
        {
            KeriaConnectionDigest = selectedDigest,
            IdentifiersList = [identifiers]
        };

        var storeConnectionInfoResult = await storageService.SetItem<KeriaConnectionInfo>(connectionInfo, StorageArea.Session);
        if (storeConnectionInfoResult.IsFailed)
        {
            logger.LogError("Failed to cache connection info: {Errors}", string.Join(", ", storeConnectionInfoResult.Errors));
            SetFlowFailed(5, "Failed to cache connection info");
            return;
        }

        // Wait for KeriaConnectionInfo to be reflected in AppCache
        await appCache.WaitForAppCache([() => !string.IsNullOrEmpty(appCache.MyKeriaConnectionInfo.KeriaConnectionDigest)]);
        // KeriaConnectionDigest check passed

        // Final confirmation and navigation
        // Waiting for IsConnectedToKeria (current: {Value})", appCache.IsConnectedToKeria);
        await appCache.WaitForAppCache([() => appCache.IsConnectedToKeria]);
        // IsConnectedToKeria check passed

        _currentStep = FlowStep.Done;
        IsConnected = true;

        _focusTarget = FocusTarget.Next;
        StateHasChanged();

        logger.LogInformation("UnifiedOnboardingFlow completed successfully");
    }

    private async Task SelectNewPasscodeText(MouseEventArgs args)
    {
        await _newPasscodeTextField!.SelectAsync();
    }

    /// <summary>
    /// Resets the configuration by clearing KeriaConnectConfig from Local storage,
    /// clearing Session storage (PasscodeModel, KeriaConnectionInfo), and resetting
    /// all local page state to defaults. This allows the user to start fresh.
    /// </summary>
    async Task RetryResetConfiguration()
    {
        logger.LogInformation("ResetConfiguration: Clearing storage and resetting page state");

        // Note, not clearing all of session, since readiness of BW is tied to session existence.
        // Clear Session storage (PasscodeModel and KeriaConnectionInfo)
        var removePasscodeResult = await storageService.RemoveItem<PasscodeModel>(StorageArea.Session);
        if (removePasscodeResult.IsFailed)
        {
            logger.LogWarning("Failed to remove PasscodeModel: {Errors}", string.Join(", ", removePasscodeResult.Errors));
        }

        var removeConnectionInfoResult = await storageService.RemoveItem<KeriaConnectionInfo>(StorageArea.Session);
        if (removeConnectionInfoResult.IsFailed)
        {
            logger.LogWarning("Failed to remove KeriaConnectionInfo: {Errors}", string.Join(", ", removeConnectionInfoResult.Errors));
        }

        // Wait for appCache to reflect the cleared state
        /*
        await appCache.WaitForAppCache([
        () => !appCache.IsConfigured,
                () => !appCache.IsSessionPasscodeSet
        ]);
        */

        // Reset KeriaConnectConfigs in Local storage
        var removeConfigResult = await ClearKeriaConnectConfigsAsync();
        if (removeConfigResult.IsFailed)
        {
            logger.LogError("Failed to remove KeriaConnectConfigs: {Errors}", string.Join(", ", removeConfigResult.Errors));
            snackbar.Add("Failed to clear configuration", Severity.Error);
            return;
        }

        // Wait for appCache to reflect the cleared updates
        logger.LogInformation("ResetConfiguration: waiting for appCache.IsProductOnboarded");
        await appCache.WaitForAppCache([() => appCache.IsProductOnboarded]);
        logger.LogInformation("ResetConfiguration: waiting to assure !appCache.IsKeriaConfigValidated");
        await appCache.WaitForAppCache([() => !appCache.IsKeriaConfigValidated]);
        // () => !appCache.IsSessionPasscodeSet
        // () => string.IsNullOrWhiteSpace(appCache.SessionKeriaAdminUrl)
        

        // Reset local page state to defaults
        ResetLocalState();
        StateHasChanged(); // TODO P2 code smell
        logger.LogInformation("ResetConfiguration: Complete");
        // snackbar.Add("KERIA Connection Reset", Severity.Info);
    }

    /// <summary>
    /// Resets all local page state to default values.
    /// Called by ResetConfiguration and can be called when appCache detects external storage changes.
    /// </summary>
    void ResetLocalState()
    {
        // Reset to default preset
        _presetChoice = defaultPreset;
        urlModel = new UrlModel()
        {
            AdminUrl = defaultPreset.AgentUrl,
            BootUrl = defaultPreset.BootUrl
        };

        // Reset passcode state
        configuredPasscodeModel = new PasscodeFormModel();
        RandomPasscode = "";
        IsRandomPasscodeRevealed = false;
        IsPasscodeCopyConfirmed = false;
        IsUsingExistingPasscode = true;

        // Reset ratchet gates
        IsFlowStarted = false;
        IsPasscodeUsed = false;

        // Reset progress state
        IsProcessing = false;
        IsConnected = false;
        IsReadyForNext = false;
        KeriaConnectConfig = null;

        // Reset operation displays
        // ops1CheckLiveness.Reset();
        // ops2CheckHealth.Reset();
        // ops3Connect.Reset();
        // ops4ListAids.Reset();
        // ops5CreatePersonalAid.Reset();
        ResetOps();

        // Reset focus
        _focusTarget = FocusTarget.Passcode;
    }

    /// <summary>
    /// Stores a KeriaConnectConfig to the KeriaConnectConfigs dictionary and updates the selected digest in Preferences.
    /// </summary>
    /// <param name="config">The config to store</param>
    /// <param name="setAsSelected">If true, updates Preferences.KeriaPreference.SelectedKeriaConnectionDigest</param>
    /// <returns>Result indicating success or failure</returns>
    private async Task<Result> StoreKeriaConnectConfigAsync(KeriaConnectConfig config, bool setAsSelected = true)
    {
        // Compute the digest for this config (requires ClientAidPrefix and AgentAidPrefix to be set)
        string? digest = null;
        if (!string.IsNullOrEmpty(config.ClientAidPrefix) && !string.IsNullOrEmpty(config.AgentAidPrefix))
        {
            var digestResult = KeriaConnectionDigestHelper.Compute(config);
            if (digestResult.IsFailed)
            {
                logger.LogWarning("Could not compute digest for config: {Errors}", string.Join(", ", digestResult.Errors));
                // Use a temporary key for partial configs (before Connect completes)
                digest = $"partial_{config.AdminUrl}_{config.PasscodeHash}";
            }
            else
            {
                digest = digestResult.Value;
            }
        }
        else
        {
            // Partial config - use a temporary key
            digest = $"partial_{config.AdminUrl}_{config.PasscodeHash}";
        }

        // Get the current KeriaConnectConfigs or create new
        var existingConfigsResult = await storageService.GetItem<KeriaConnectConfigs>();
        var configs = existingConfigsResult.IsSuccess && existingConfigsResult.Value is not null && existingConfigsResult.Value.IsStored
            ? existingConfigsResult.Value
            : new KeriaConnectConfigs { IsStored = true };

        // Create new dictionary with the updated/added config
        var newConfigsDict = new Dictionary<string, KeriaConnectConfig>(configs.Configs);

        // Remove any partial config keys if we now have a complete digest
        if (!digest.StartsWith("partial_"))
        {
            var partialKeys = newConfigsDict.Keys.Where(k => k.StartsWith("partial_")).ToList();
            foreach (var key in partialKeys)
            {
                newConfigsDict.Remove(key);
            }
        }

        newConfigsDict[digest] = config;

        var updatedConfigs = configs with { Configs = newConfigsDict };
        var storeResult = await storageService.SetItem<KeriaConnectConfigs>(updatedConfigs);
        if (storeResult.IsFailed)
        {
            return Result.Fail($"Failed to store KeriaConnectConfigs: {string.Join(", ", storeResult.Errors)}");
        }

        // Update Preferences with the selected digest if requested and we have a complete digest
        if (setAsSelected && !digest.StartsWith("partial_"))
        {
            var currentPrefs = appCache.MyPreferences;
            var updatedKeriaPreference = currentPrefs.KeriaPreference with
            {
                SelectedKeriaConnectionDigest = digest
            };
            var updatedPrefs = currentPrefs with { KeriaPreference = updatedKeriaPreference };
            var prefsResult = await storageService.SetItem<Preferences>(updatedPrefs);
            if (prefsResult.IsFailed)
            {
                logger.LogWarning("Failed to update SelectedKeriaConnectionDigest in Preferences: {Errors}", string.Join(", ", prefsResult.Errors));
                // Don't fail the whole operation for this
            }
        }

        return Result.Ok();
    }

    /// <summary>
    /// Clears all KeriaConnectConfigs and resets the selected digest in Preferences.
    /// </summary>
    private async Task<Result> ClearKeriaConnectConfigsAsync()
    {
        // Clear the KeriaConnectConfigs
        var emptyConfigs = new KeriaConnectConfigs { IsStored = false, Configs = new Dictionary<string, KeriaConnectConfig>() };
        var storeResult = await storageService.SetItem<KeriaConnectConfigs>(emptyConfigs);
        if (storeResult.IsFailed)
        {
            return Result.Fail($"Failed to clear KeriaConnectConfigs: {string.Join(", ", storeResult.Errors)}");
        }

        // Clear the selected digest in Preferences
        var currentPrefs = appCache.MyPreferences;
        var updatedKeriaPreference = currentPrefs.KeriaPreference with
        {
            SelectedKeriaConnectionDigest = null
        };
        var updatedPrefs = currentPrefs with { KeriaPreference = updatedKeriaPreference };
        var prefsResult = await storageService.SetItem<Preferences>(updatedPrefs);
        if (prefsResult.IsFailed)
        {
            logger.LogWarning("Failed to clear SelectedKeriaConnectionDigest in Preferences: {Errors}", string.Join(", ", prefsResult.Errors));
        }

        return Result.Ok();
    }
}

<div @ref="_pageContainer" tabindex="-1" id="@this.GetType().Name" class="bt-body-page">
    <div id="connect-progress"  class="d-flex gap-2 bt-main">
        <MudStack Style="min-width: 24.286rem; width:100%; margin-right:1.143rem;">
            <MudText Class="bt-page-title">Connect with KERIA Cloud Service</MudText>

            <MudText Typo="Typo.h6">Service</MudText>
            <MudStack Class="ml-4">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudText Style="min-width: 8.571rem;">Provider</MudText>
                    <MudSelect T="Preset" @bind-Value="@PresetChoice" Disabled="@IsFlowStarted" Style="flex-grow: 1;">
                        @foreach (var preset in presetAgents)
                        {
                            <MudSelectItem Value="@preset">@preset.ProviderName</MudSelectItem>
                        }
                    </MudSelect>
                </MudStack>
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudText Style="min-width: 8.571rem;">Agent URL</MudText>
                    <MudTextField @bind-Value="@urlModel.AdminUrl"
                                  For="@(() => urlModel.AdminUrl)"
                                  Immediate="true"
                                  Disabled="@IsFlowStarted"
                                  Style="flex-grow: 1;" />
                </MudStack>
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudText Style="min-width: 8.571rem;">Boot URL</MudText>
                    <MudTextField Required="!IsUsingExistingPasscode"
                                  @bind-Value="@urlModel.BootUrl"
                                  For="@(() => urlModel.BootUrl)"
                                  Immediate="true"
                                  Disabled="@IsFlowStarted"
                                  Style="flex-grow: 1;" />
                </MudStack>
            </MudStack>

            <MudText Typo="Typo.h6" Class="mt-4">Your Passcode</MudText>
            <MudStack Class="ml-4">
                <MudRadioGroup T="Boolean" Value="@(!IsUsingExistingPasscode)" Style="margin-left:-0.9rem;" Disabled="@IsPasscodeUsed" ValueChanged="async (bool v) => await SetIsNewAccount(v)">
                    <MudRadio Value="false">
                        Use existing
                    </MudRadio>
                    <MudRadio Value="true">
                        Create new random
                    </MudRadio>
                </MudRadioGroup>
                @if (IsUsingExistingPasscode)
                {
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                        <MudText Style="min-width: 8.571rem;">Passcode</MudText>
                        <MudTextField T="string"
                                      InputType="InputType.Password"
                                      Value="@configuredPasscodeModel.Passcode"
                                      ValueChanged="@OnPasscodeChanged"
                                      OnKeyDown="@HandlePasscodeKeyDown"
                                      For="@(() => configuredPasscodeModel.Passcode)"
                                      Immediate="true"
                                      Disabled="@IsPasscodeUsed"
                                      AutoFocus="@ShouldFocusPasscode"
                                      Style="flex-grow: 1;" />
                    </MudStack>
                    <MudButton @ref="connectButton" Variant="Variant.Filled" Style="width:fit-content;" OnClick="UnifiedOnboardingFlow" Disabled="@(!IsValidNewInfo || IsKeriaConfigured || IsPasscodeUsed)" Color="Color.Primary">Connect</MudButton>
                }
                else // create a new passcode
                {
                    <MudStack Row="true" AlignItems="AlignItems.Center">
                        <MudText Style="min-width: 8.571rem;">Generated random passcode</MudText>
                        <MudTextField @ref="_newPasscodeTextField" InputType="@(IsRandomPasscodeRevealed? InputType.Text: InputType.Password)"
                                      @bind-Value="@RandomPasscode"
                                      ReadOnly="true"
                                      Disabled="@IsPasscodeUsed"
                                      Class="pl-1"
                                      Immediate="true"
                                      @onclick="SelectNewPasscodeText"
                                      Style="min-width:15rem; font-family: monospace;" />
                        <MudTooltip Text="@(IsRandomPasscodeRevealed ? "Hide passcode" : "Reveal passcode")">
                            <MudIconButton Icon="@(IsRandomPasscodeRevealed? Icons.Material.Filled.VisibilityOff : Icons.Material.Filled.Visibility)"
                                           Disabled="@IsPasscodeUsed"
                                           OnClick="@(() => IsRandomPasscodeRevealed = !IsRandomPasscodeRevealed)" />
                        </MudTooltip>
                    </MudStack>
                    <MudCheckBox T="bool" Value="IsPasscodeCopyConfirmed" Disabled="@IsPasscodeUsed" ValueChanged="@OnPasscodeCopyConfirmedChanged" Style="margin-left:-0.9rem; overflow-wrap:break-word;">I have copied and stored this passcode in a secure place</MudCheckBox>
                    @if (IsPasscodeCopyConfirmed)
                    {
                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                            <MudText Style="min-width: 8.571rem;">Confirm your passcode</MudText>
                            <MudTextField T="string"
                                          Class="pl-1"
                                          InputType="InputType.Password"
                                          Value="@configuredPasscodeModel.Passcode"
                                          ValueChanged="@OnPasscodeChanged"
                                          OnKeyDown="@HandlePasscodeKeyDown"
                                          For="@(() => configuredPasscodeModel.Passcode)"
                                          Immediate="true"
                                          Disabled="@IsPasscodeUsed"
                                          AutoFocus="@ShouldFocusConfirmPasscode"
                                          Style="flex-grow: 1;" />
                        </MudStack>
                        @if (configuredPasscodeModel.Passcode == RandomPasscode)
                        {
                            <MudIcon Icon="@Icons.Material.Filled.Check" Color="Color.Success"></MudIcon>
                            <MudButton @ref="connectButton" Variant="Variant.Filled" Style="width:fit-content;" OnClick="UnifiedOnboardingFlow" Disabled="@(IsKeriaConfigured || !IsValidNewInfo || IsPasscodeUsed)" Color="Color.Primary">Connect</MudButton>
                        }
                        else if (!string.IsNullOrEmpty(configuredPasscodeModel.Passcode))
                        {
                            <MudText Color="Color.Error">Passcodes do not match</MudText>
                        }
                    }
                }
            </MudStack>

            @if (IsFlowStarted)
            {
                <!-- Connection progress and operations. div helps ScrollToBottom because of height --> 
                <div style="min-height: 20rem;">
                <MudText Typo="Typo.h6" Class="mt-4">Connection</MudText>
                <MudStack Class="ml-4">
                    <OperationDisplayComponent ops="@Ops1CheckLiveness" StateOverride="@Ops1State" ErrorMessage="@(_failedAtStep == 1 ? _errorMessage : null)" />
                    <OperationDisplayComponent ops="@Ops2CheckHealth" StateOverride="@Ops2State" ErrorMessage="@(_failedAtStep == 2 ? _errorMessage : null)" />
                    <OperationDisplayComponent ops="@Ops3Connect" StateOverride="@Ops3State" ErrorMessage="@(_failedAtStep == 3 ? _errorMessage : null)" />
                    <OperationDisplayComponent ops="@Ops4ListAids" StateOverride="@Ops4State" ErrorMessage="@(_failedAtStep == 4 ? _errorMessage : null)" />
                    <OperationDisplayComponent ops="@Ops5CreatePersonalAid" StateOverride="@Ops5State" ErrorMessage="@(_failedAtStep == 5 ? _errorMessage : null)" />
                    <OperationDisplayComponent ops="@Ops6AllDone" StateOverride="@Ops6State" />
                </MudStack>
                </div>
            }
        </MudStack>
    </div>
    <MudStack Row="true" class="bt-button-tray">
        <MudButton @ref="resetButton" Variant="Variant.Outlined" Color="Color.Secondary" OnClick="RetryResetConfiguration" data-testid="retry">Retry</MudButton>
        <MudSpacer />
        <MudButton @ref="nextButton" Disabled="@(!IsKeriaConfigured)" Variant="Variant.Filled" Color="Color.Primary" OnClick="@(() => navManager.NavigateTo(Routes.PathFor<Index>()))" Class="justify-start" data-testid="next">Next</MudButton>
    </MudStack>
</div>
