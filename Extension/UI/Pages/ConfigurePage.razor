@page "/Configure.html"
@using Extension.Models
@using Extension.Models.Storage
@using Extension.Services.Storage
@using Extension.Utilities

@inject IStorageService storageService
@inject ILogger<ConfigurePage> logger
@inject HttpClient httpClient
@inject NavigationManager navManager
@inject IJSRuntime js
@inject ISignifyClientService signifyClientService
@inject ISnackbar snackbar
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject AppCache appCache  // Non-reactive here unless/until SubscribeToAppCache() is added in OnInitializedAsync
@using FluentResults

@code {
    // TODO P2 restructure as a record?
    struct Preset
    {
        public string ProviderName { get; init; }
        public string AgentUrl { get; init; }
        public string BootUrl { get; init; }
        public Preset(string provider, string adminUrl, string bootUrl)
        {
            ProviderName = provider;
            AgentUrl = adminUrl;
            BootUrl = bootUrl;
        }
    }

    class UrlModel
    {
        // TODO P2 add setters that validate these values are a URL.  If not equal to the selected preset, set the preset to "Custom"
        [Required]
        [Url(ErrorMessage = "Enter KERIA Agent Admin URL")]
        public string AdminUrl { get; set; } = presetAgents[0].AgentUrl;

        // TODO P2 see potential password needed for the boot endpoint: https://github.com/WebOfTrust/keria/issues/327
        public string? BootUrl { get; set; } = presetAgents[0].BootUrl;
    }

    // TODO P3 DRY with UnlockView
    class PasscodeFormModel
    {
        [Required]
        [StringLength(21, ErrorMessage = "Passcode must be 21 characters long", MinimumLength = 21)]
        [DataType(DataType.Password)]
        public string Passcode { get; set; } = "";
    }

    // fields
    KeriaConnectConfig defaultKeriaConnectConfig => new KeriaConnectConfig(defaultPreset.ProviderName, defaultPreset.AgentUrl, defaultPreset.BootUrl, 0);
    static readonly OperationDisplay ops1CheckLiveness = new OperationDisplay("Checking KERIA Cloud Service liveness", "Established KERIA connection");
    static readonly OperationDisplay ops2CheckHealth = new OperationDisplay("Checking KERIA Cloud Service health", "Confirmed healthy connection");
    static readonly OperationDisplay ops3Connect = new OperationDisplay("Connecting", "Connected");
    static readonly OperationDisplay ops4ListAids = new OperationDisplay("Retrieving your identifiers", "Retrieved identifiers");
    static readonly OperationDisplay ops5CreatePersonalAid = new OperationDisplay("Creating personal identifier", "Created new identifier");
    // TODO P2 load presets from AppConfig or external source
    static List<Preset> presetAgents = new List<Preset>
    {
        new Preset("KERI Auth Test Cloud", "https://keria.cloud.keriauth.com", "https://keria-boot.cloud.keriauth.com"),
        new Preset("localhost", AppConfig.LocalhostKeriaAdminUrl, AppConfig.LocalhostKeriaBootUrl),
        new Preset("GLEIF Testnet", "https://keria.testnet.gleif.org:3901", "https://keria.testnet.gleif.org:3903"),
        new Preset("Custom", "", "")
    };
    private MudTextField<string>? _newPasscodeTextField;
    WebExtensionsApi? webExtensionsApi;
    Preset _presetChoice = presetAgents[0];
    UrlModel urlModel = new UrlModel()
    {
        AdminUrl = presetAgents[0].AgentUrl,
        BootUrl = presetAgents[0].BootUrl,
    };
    PasscodeFormModel configuredPasscodeModel = new PasscodeFormModel();
    private MudButton? nextButton;
    private MudButton? connectButton;

    // properties
    KeriaConnectConfig? KeriaConnectConfig { get; set; }
    string RandomPasscode { get; set; } = "";
    bool IsRandomPasscodeRevealed { get; set; } = false;
    bool IsPasscodeCopyConfirmed { get; set; }
    bool IsUsingExistingPasscode { get; set; } = true;
    bool IsProcessing { get; set; }
    bool IsConnected { get; set; }
    bool IsReadyForNext { get; set; }
    Preset PresetChoice
    {
        get
        {
            return _presetChoice;
        }
        set
        {
            _presetChoice = value;
            urlModel.AdminUrl = value.AgentUrl;
            urlModel.BootUrl = value.BootUrl;
        }
    }

    // reactive properties
    Preset defaultPreset => presetAgents[0];
    bool IsValidAdminURL =>
        !string.IsNullOrWhiteSpace(urlModel.AdminUrl) &&
        Uri.IsWellFormedUriString(urlModel.AdminUrl, UriKind.Absolute);
    bool IsValidBootURL =>
        !string.IsNullOrWhiteSpace(urlModel.BootUrl) &&
        Uri.IsWellFormedUriString(urlModel.BootUrl, UriKind.Absolute);
    bool IsValidNewInfo =>
        IsValidAdminURL
        && !string.IsNullOrWhiteSpace(configuredPasscodeModel.Passcode)
        && configuredPasscodeModel.Passcode.Length == 21
        && (IsUsingExistingPasscode
            || (IsValidBootURL
                && RandomPasscode == configuredPasscodeModel.Passcode
                && IsPasscodeCopyConfirmed)
        );
    bool IsKeriaConfigured => (KeriaConnectConfig is not null) && KeriaConnectConfig.ValidateConfiguration().IsSuccess;
    string BootUrlLabel => IsUsingExistingPasscode ? "Boot URL (optional if you have established KERIA connection passcode)" : "Boot URL";

    // Focus state - determines which element should have focus
    enum FocusTarget { None, Passcode, ConfirmPasscode, Connect, Next }
    FocusTarget _focusTarget = FocusTarget.Passcode;
    bool ShouldFocusPasscode => _focusTarget == FocusTarget.Passcode && IsUsingExistingPasscode;
    bool ShouldFocusConfirmPasscode => _focusTarget == FocusTarget.ConfirmPasscode && !IsUsingExistingPasscode && IsPasscodeCopyConfirmed;
    bool ShouldFocusConnect => _focusTarget == FocusTarget.Connect;


    protected override async Task OnInitializedAsync()
    {
        webExtensionsApi = new WebExtensionsApi(jsRuntimeAdapter);
    }

    protected override async Task OnAfterRenderAsync(bool isFirstRender)
    {
        // Handle button focus imperatively (MudButton doesn't support AutoFocus)
        if (_focusTarget == FocusTarget.Connect && connectButton is not null)
        {
            _focusTarget = FocusTarget.None;
            await connectButton.FocusAsync();
        }
        else if (_focusTarget == FocusTarget.Next && nextButton is not null)
        {
            _focusTarget = FocusTarget.None;
            await nextButton.FocusAsync();
        }
        else if (_focusTarget == FocusTarget.Passcode || _focusTarget == FocusTarget.ConfirmPasscode)
        {
            // Text fields use AutoFocus attribute - reset after first render so it triggers
            _focusTarget = FocusTarget.None;
        }
    }

    void OnPasscodeChanged(string value)
    {
        configuredPasscodeModel.Passcode = value;
        if (value.Length == 21)
        {
            if (IsUsingExistingPasscode || value == RandomPasscode && IsPasscodeCopyConfirmed)
            {
                _focusTarget = FocusTarget.ConfirmPasscode;
            }
            StateHasChanged();
        }
    }

    async Task HandlePasscodeKeyDown(KeyboardEventArgs args)
    {
        if (args.Key == "Enter" && IsValidNewInfo && !IsKeriaConfigured)
        {
            await UnifiedOnboardingFlow();
        }
    }

    void OnPasscodeCopyConfirmedChanged(bool value)
    {
        IsPasscodeCopyConfirmed = value;
        if (value)
        {
            _focusTarget = FocusTarget.ConfirmPasscode;
        }
    }

    async Task SetIsNewAccount(bool isNewAccount)
    {
        IsUsingExistingPasscode = !isNewAccount;
        RandomPasscode = RandomStringGenerator.GenerateRandomString(21);
        // clear in case radio is toggled after passcode is copied, entered
        configuredPasscodeModel.Passcode = "";
        IsPasscodeCopyConfirmed = false;
        await ResetOps();
        // intentionally NOT copying to clipboard since the user may prefer to only write it down manually due to security concerns
    }

    async Task ResetOps()
    {
        IsProcessing = false;
        ops1CheckLiveness.Reset();
        ops2CheckHealth.Reset();
        ops3Connect.Reset();
        ops4ListAids.Reset();
        ops5CreatePersonalAid.Reset();
        IsReadyForNext = false;
        StateHasChanged();
    }

    // TODO P2 could return Result to indicate success/failure, and do some DRY then
    async Task UnifiedOnboardingFlow()
    {
        await ResetOps();
        logger.LogInformation("UnifiedOnboardingFlow starting...");
        IsProcessing = true;
        StateHasChanged();

        // Validate preconditions
        if (!(IsValidNewInfo || IsKeriaConfigured))
        {
            snackbar.Add("Please complete all required fields", Severity.Error);
            IsProcessing = false;
            return;
        }

        // Step 0: Validate BootUrl for "Create new" flow
        if (!IsUsingExistingPasscode && !IsValidBootURL)
        {
            snackbar.Add("Boot URL is required for creating a new account", Severity.Error);
            IsProcessing = false;
            return;
        }

        // Step 1: Check KERIA liveness (if BootUrl is provided)
        if (IsValidBootURL)
        {
            // Check if BootUrl is reachable
            ops1CheckLiveness.SetIsRunning();
            StateHasChanged();

            var baseUri = new Uri(urlModel.BootUrl!);
            var healthUri = new Uri(baseUri, "health");
            var healthUriBuilder = new UriBuilder(healthUri);

            var healthCheckResult = await signifyClientService.HealthCheck(healthUriBuilder.Uri);
            if (!healthCheckResult.IsSuccess)
            {
                const string message = "KERIA service is not reachable";
                ops1CheckLiveness.SetCompletedWithError(message);
                snackbar.Add(message, Severity.Error);
                await Task.Delay(6000);
                IsProcessing = false;
                return;
            }
            ops1CheckLiveness.SetCompletedWithoutErrors();

            // Check if KERIA is reporting as healthy
            ops2CheckHealth.SetIsRunning();
            StateHasChanged();
            var httpClientService2 = new HttpClientService(new HttpClient());
            var healthStatusResult = await httpClientService2.GetJsonAsync<String>(healthUriBuilder.Uri.ToString());
            if (!healthStatusResult.IsSuccess || healthStatusResult.Value.StatusCode != System.Net.HttpStatusCode.OK)
            {
                string errorMsg = healthStatusResult.Reasons.FirstOrDefault()?.Message ?? "KERIA health check failed";
                ops2CheckHealth.SetCompletedWithError(errorMsg);
                snackbar.Add(errorMsg, Severity.Error);
                await Task.Delay(6000);
                IsProcessing = false;
                return;
            }
            ops2CheckHealth.SetCompletedWithoutErrors();
            // await Task.Delay(100);
        }

        // Step 2: Store partial KeriaConnectConfig with passcodeHash
        // Use 'with' expression to preserve IsStored from skeleton record created by BackgroundWorker
        int passcodeHash = DeterministicHash.ComputeHash(configuredPasscodeModel.Passcode);
        var partialConfig = appCache.MyKeriaConnectConfig with
        {
            ProviderName = _presetChoice.ProviderName,
            Alias = _presetChoice.ProviderName, // Use provider name as default alias
            AdminUrl = urlModel.AdminUrl,
            BootUrl = urlModel.BootUrl,
            PasscodeHash = passcodeHash,
            ClientAidPrefix = null, // will be set after Connect
            AgentAidPrefix = null   // will be set after Connect
        };

        var storePartialConfigResult = await storageService.SetItem<KeriaConnectConfig>(partialConfig);
        if (storePartialConfigResult.IsFailed)
        {
            logger.LogError("Failed to store partial connection config: {Errors}", string.Join(", ", storePartialConfigResult.Errors));
            snackbar.Add("Failed to store connection configuration", Severity.Error);
            await Task.Delay(6000);
            IsProcessing = false;
            return;
        }

        // Wait for AppCache to reflect the partial config
        await appCache.WaitForAppCache([() => appCache.MyKeriaConnectConfig.PasscodeHash != 0]);

        // Step 3: Connect to KERIA
        ops3Connect.SetIsRunning();
        StateHasChanged();
        // await Task.Delay(100);

        logger.LogInformation("Connecting to KERIA at {url}...", urlModel.AdminUrl);
        var connectResult = await signifyClientService.Connect(
            urlModel.AdminUrl,
            configuredPasscodeModel.Passcode,
            urlModel.BootUrl,
            !IsUsingExistingPasscode
        );

        if (connectResult.IsFailed)
        {
            ops3Connect.SetCompletedWithError(connectResult.Reasons.First().Message);
            snackbar.Add($"Connection failed: {connectResult.Reasons.First().Message}", Severity.Error);
            await Task.Delay(6000);
            IsProcessing = false;
            return;
        }
        ops3Connect.SetCompletedWithoutErrors();

        // Extract agent and client prefixes from Connect result
        string clientAidPrefix = connectResult.Value.Controller!.State!.I;
        string agentAidPrefix = connectResult.Value.Agent!.I;

        // Step 4: Store PasscodeModel to Session storage
        var sessionExpiry = DateTime.UtcNow.AddMinutes(appCache.MyPreferences.InactivityTimeoutMinutes);
        var passcodeModel = new PasscodeModel
        {
            Passcode = configuredPasscodeModel.Passcode,
            SessionExpirationUtc = sessionExpiry
        };

        var storePasscodeResult = await storageService.SetItem<PasscodeModel>(passcodeModel, StorageArea.Session);
        if (storePasscodeResult.IsFailed)
        {
            logger.LogError("Failed to store passcode: {Errors}", string.Join(", ", storePasscodeResult.Errors));
            snackbar.Add("Failed to store session passcode", Severity.Error);
            await Task.Delay(6000);
            IsProcessing = false;
            return;
        }

        // Wait for PasscodeModel to be reflected in AppCache
        await appCache.WaitForAppCache([() => appCache.IsSessionPasscodeSet, () => appCache.IsSessionNotExpired]);

        // Step 5: Update KeriaConnectConfig with complete information
        var completeConfig = partialConfig with
        {
            ClientAidPrefix = clientAidPrefix,
            AgentAidPrefix = agentAidPrefix
        };

        var storeCompleteConfigResult = await storageService.SetItem<KeriaConnectConfig>(completeConfig);
        if (storeCompleteConfigResult.IsFailed)
        {
            logger.LogError("Failed to update connection config: {Errors}", string.Join(", ", storeCompleteConfigResult.Errors));
            snackbar.Add("Failed to update connection configuration", Severity.Error);
            await Task.Delay(6000);
            IsProcessing = false;
            return;
        }

        // Wait for complete config to be reflected in AppCache
        await appCache.WaitForAppCache([() => appCache.IsConfigured]);
        KeriaConnectConfig = completeConfig;

        // Step 6: Get Identifiers
        ops4ListAids.SetIsRunning();
        StateHasChanged();
        // await Task.Delay(100);

        var identifiersRes = await signifyClientService.GetIdentifiers();
        if (identifiersRes.IsFailed)
        {
            ops4ListAids.SetCompletedWithError(identifiersRes.Reasons.First().Message);
            snackbar.Add($"Failed to retrieve identifiers: {identifiersRes.Reasons.First().Message}", Severity.Error);
            await Task.Delay(6000);
            IsProcessing = false;
            return;
        }

        var identifiers = identifiersRes.Value;
        ops4ListAids.SetCompletedWithoutErrors();
        // await Task.Delay(100);

        // Step 7: Create identifier if none exist
        if (identifiers.Aids.Count == 0)
        {
            ops5CreatePersonalAid.SetIsRunning();
            StateHasChanged();

            var createAidResult = await signifyClientService.RunCreateAid("Alias1");
            if (createAidResult.IsFailed)
            {
                ops5CreatePersonalAid.SetCompletedWithError(createAidResult.Reasons.First().Message);
                snackbar.Add($"Failed to create identifier: {createAidResult.Reasons.First().Message}", Severity.Error);
                await Task.Delay(6000);
                IsProcessing = false;
                return;
            }
            ops5CreatePersonalAid.SetCompletedWithoutErrors();

            // Re-fetch identifiers after creating
            var refreshedIdentifiersRes = await signifyClientService.GetIdentifiers();
            if (refreshedIdentifiersRes.IsFailed)
            {
                snackbar.Add("Failed to refresh identifiers after creation", Severity.Error);
                await Task.Delay(6000);
                IsProcessing = false;
                return;
            }
            identifiers = refreshedIdentifiersRes.Value;
        }

        // Step 8: Store Preferences with SelectedPrefix
        if (identifiers.Aids.Count == 0)
        {
            snackbar.Add("No identifiers available after creation", Severity.Error);
            await Task.Delay(6000);
            IsProcessing = false;
            return;
        }

        var selectedPrefix = identifiers.Aids.First().Prefix;
        // Use 'with' to preserve existing preferences (theme, timeouts, etc.) when setting SelectedPrefix
        var preferences = appCache.MyPreferences with { SelectedPrefix = selectedPrefix };

        var storePreferencesResult = await storageService.SetItem<Preferences>(preferences);
        if (storePreferencesResult.IsFailed)
        {
            logger.LogError("Failed to store preferences: {Errors}", string.Join(", ", storePreferencesResult.Errors));
            snackbar.Add("Failed to store preferences", Severity.Error);
            await Task.Delay(6000);
            IsProcessing = false;
            return;
        }

        // Wait for Preferences to be reflected in AppCache
        await appCache.WaitForAppCache([() => !string.IsNullOrWhiteSpace(appCache.MyPreferences.SelectedPrefix)]);

        // Step 9: Store KeriaConnectionInfo to Session storage
        var connectionInfo = new KeriaConnectionInfo
        {
            Config = completeConfig,
            IdentifiersList = [identifiers],
            AgentPrefix = agentAidPrefix
        };

        var storeConnectionInfoResult = await storageService.SetItem<KeriaConnectionInfo>(connectionInfo, StorageArea.Session);
        if (storeConnectionInfoResult.IsFailed)
        {
            logger.LogError("Failed to cache connection info: {Errors}", string.Join(", ", storeConnectionInfoResult.Errors));
            snackbar.Add("Failed to cache connection info", Severity.Error);
            await Task.Delay(6000);
            IsProcessing = false;
            return;
        }

        // Wait for KeriaConnectionInfo to be reflected in AppCache
        await appCache.WaitForAppCache([() => appCache.MyKeriaConnectionInfo.Config.PasscodeHash != 0]);

        // Step 10: Final confirmation and navigation
        await appCache.WaitForAppCache([() => appCache.IsConnectedToKeria]);

        IsConnected = true;
        IsProcessing = false;
        snackbar.Add("Connection to KERIA Service successful", Severity.Success);

        _focusTarget = FocusTarget.Next;
        StateHasChanged();

        logger.LogInformation("UnifiedOnboardingFlow completed successfully, navigating to passkey offer");
    }

    private async Task SelectNewPasscodeText(MouseEventArgs args)
    {
        await _newPasscodeTextField!.SelectAsync();
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    <div class="d-flex gap-2 bt-main">
        <MudStack Style="min-width: 24.286rem; width:100%; margin-right:1.143rem;">
            <MudText Class="bt-page-title">Connect with KERIA Cloud Service</MudText>

            <MudText Typo="Typo.h6">Service</MudText>
            <MudStack Class="ml-4">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudText Style="min-width: 8.571rem;">Provider</MudText>
                    <MudSelect T="Preset" @bind-Value="@PresetChoice" Style="flex-grow: 1;">
                        @foreach (var preset in presetAgents)
                        {
                            <MudSelectItem Value="@preset">@preset.ProviderName</MudSelectItem>
                        }
                    </MudSelect>
                </MudStack>
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudText Style="min-width: 8.571rem;">Agent URL</MudText>
                    <MudTextField @bind-Value="@urlModel.AdminUrl"
                                  For="@(() => urlModel.AdminUrl)"
                                  Immediate="true"
                                  Style="flex-grow: 1;" />
                </MudStack>
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudText Style="min-width: 8.571rem;">Boot URL</MudText>
                    <MudTextField Required="!IsUsingExistingPasscode"
                                  @bind-Value="@urlModel.BootUrl"
                                  For="@(() => urlModel.BootUrl)"
                                  Immediate="true"
                                  Style="flex-grow: 1;" />
                </MudStack>
            </MudStack>

            <MudText Typo="Typo.h6" Class="mt-4">Your Passcode</MudText>
            <MudStack Class="ml-4">
                <MudRadioGroup T="Boolean" Style="margin-left:-0.9rem;" ValueChanged="async (bool v) => await SetIsNewAccount(v)">
                    <MudRadio Value="false">
                        Use existing
                    </MudRadio>
                    <MudRadio Value="true">
                        Create new random
                    </MudRadio>
                </MudRadioGroup>
                @if (IsUsingExistingPasscode)
                {
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                        <MudText Style="min-width: 8.571rem;">Passcode</MudText>
                        <MudTextField T="string"
                                      InputType="InputType.Password"
                                      Value="@configuredPasscodeModel.Passcode"
                                      ValueChanged="@OnPasscodeChanged"
                                      OnKeyDown="@HandlePasscodeKeyDown"
                                      For="@(() => configuredPasscodeModel.Passcode)"
                                      Immediate="true"
                                      AutoFocus="@ShouldFocusPasscode"
                                      Style="flex-grow: 1;" />
                    </MudStack>
                    <MudButton @ref="connectButton" Variant="Variant.Filled" Style="width:fit-content;" OnClick="UnifiedOnboardingFlow" Disabled="@(!IsValidNewInfo || IsKeriaConfigured)" Color="Color.Primary">Connect</MudButton>
                }
                else // create a new passcode
                {
                    <MudStack Row="true" AlignItems="AlignItems.Center">
                        <MudText Style="min-width: 8.571rem;">Generated random passcode</MudText>
                        <MudTextField @ref="_newPasscodeTextField" InputType="@(IsRandomPasscodeRevealed ? InputType.Text : InputType.Password)"
                                      @bind-Value="@RandomPasscode"
                                      ReadOnly="true"
                                      Class="pl-1"
                                      Immediate="true"
                                      @onclick="SelectNewPasscodeText"
                                      Style="min-width:15rem;" />
                        <MudTooltip Text="@(IsRandomPasscodeRevealed ? "Hide passcode" : "Reveal passcode")">
                            <MudIconButton Icon="@(IsRandomPasscodeRevealed? Icons.Material.Filled.VisibilityOff : Icons.Material.Filled.Visibility)"
                                           OnClick="@(() => IsRandomPasscodeRevealed = !IsRandomPasscodeRevealed)" />
                        </MudTooltip>
                    </MudStack>
                    <MudCheckBox T="bool" Value="IsPasscodeCopyConfirmed" ValueChanged="@OnPasscodeCopyConfirmedChanged" Style="margin-left:-0.9rem; overflow-wrap:break-word;">I have copied and stored this passcode in a secure place</MudCheckBox>
                    @if (IsPasscodeCopyConfirmed)
                    {
                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                            <MudText Style="min-width: 8.571rem;">Confirm your passcode</MudText>
                            <MudTextField T="string"
                                          Class="pl-1"
                                          InputType="InputType.Password"
                                          Value="@configuredPasscodeModel.Passcode"
                                          ValueChanged="@OnPasscodeChanged"
                                          OnKeyDown="@HandlePasscodeKeyDown"
                                          For="@(() => configuredPasscodeModel.Passcode)"
                                          Immediate="true"
                                          AutoFocus="@ShouldFocusConfirmPasscode"
                                          Style="flex-grow: 1;" />
                        </MudStack>
                        @if (configuredPasscodeModel.Passcode == RandomPasscode)
                        {
                            <MudIcon Icon="@Icons.Material.Filled.Check" Color="Color.Success"></MudIcon>
                            <MudButton @ref="connectButton" Variant="Variant.Filled" Style="width:fit-content;" OnClick="UnifiedOnboardingFlow" Disabled="@(IsKeriaConfigured || !IsValidNewInfo)" Color="Color.Primary">Connect</MudButton>
                        }
                        else if (!string.IsNullOrEmpty(configuredPasscodeModel.Passcode))
                        {
                            <MudText Color="Color.Error">Passcodes do not match</MudText>
                        }
                    }
                }
            </MudStack>

            @if (IsProcessing || IsConnected)
            {
                <MudText Typo="Typo.h6" Class="mt-4">Connection</MudText>
                <MudStack Class="ml-4">
                    @if (IsValidBootURL)
                    {
                        <OperationDisplayComponent ops="@ops1CheckLiveness"></OperationDisplayComponent>
                        <OperationDisplayComponent ops="@ops2CheckHealth"></OperationDisplayComponent>
                    }
                    <OperationDisplayComponent ops="@ops3Connect"></OperationDisplayComponent>
                    <OperationDisplayComponent ops="@ops4ListAids"></OperationDisplayComponent>
                    @if (ops5CreatePersonalAid.IsRunning || ops5CreatePersonalAid.CompletedSuccessfully || !string.IsNullOrEmpty(ops5CreatePersonalAid.ErrorMessage))
                    {
                        <OperationDisplayComponent ops="@ops5CreatePersonalAid"></OperationDisplayComponent>
                    }
                </MudStack>
            }
        </MudStack>
    </div>
    <MudStack Row="true" class="bt-button-tray">
        <!-- Intentionally no back button here -->
        <MudSpacer />
        <MudButton @ref="nextButton" Disabled="@(!IsKeriaConfigured)" Variant="Variant.Filled" Color="Color.Primary" OnClick="@(() => navManager.NavigateTo(Routes.PathFor<OfferPasskeyPage>()))" Class="justify-start" data-testid="next">Next</MudButton>
    </MudStack>
</div>
