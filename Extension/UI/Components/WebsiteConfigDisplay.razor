@using Newtonsoft.Json
@using Extension.Models
@using Extension.Services.Storage
@using Extension.Models.Messages.AppBw
@using Extension.Models.Messages.Port

@implements IDisposable

@inject ILogger<WebsiteConfigDisplay> logger
@inject IWebsiteConfigService websiteConfigService
@inject IStorageService storageService
@inject IDialogService dialogService
@inject ISnackbar snackbar
@inject IAppBwPortService appBwPortService
@using Extension.Services.Port
@inject IJSRuntime jsRuntime
@inject NavigationManager navManager
@inject AppCache appCache

@using Extension.Services.SignifyService.Models

@code {
    [Parameter] public required string? OriginStr { get; init; }
    [Parameter] public required bool IsCredentialShown { get; init; }
    [Parameter] public required bool IsOriginShown { get; init; }
    [Parameter] public required bool IsAutoSignShown { get; init; }
    [Parameter] public bool IsCredentialRequired { get; init; } = true;
    [Parameter] public string Heading { get; init; } = "Profile";
    [Parameter] public EventCallback<(string? selectedPrefix, string? selectedAlias, RecursiveDictionary? selectedCredential, WebsiteConfig? websiteConfig)> ValueChanged { get; init; }

    // properties
    bool IsCredListExpanded { get; set; }
    string? SelectedPrefix { get; set; }
    WebsiteConfig? ThisWebsiteConfig { get; set; }
    List<RecursiveDictionary>? CredentialsDict { get; set; }

    // Track port connection state for refresh logic
    private bool _wasDisconnected;
    private bool _isRefreshing;

    // computed properties
    List<Aid> Identifiers => appCache.MyKeriaConnectionInfo.IdentifiersList.Count > 0
        ? appCache.MyKeriaConnectionInfo.IdentifiersList[0].Aids.OrderBy(a => a.Name).ToList()
        : new List<Aid>();
    RecursiveDictionary? SelectedCredentialOrNothing => (SelectedCredSaidOrNothing is null || CredentialsDict is null) ? null : CredentialsDict.FirstOrDefault(c => c.GetValueByPath("sad.d")?.Value as string == SelectedCredSaidOrNothing);
    string? SelectedCredSaidOrNothing => (ThisWebsiteConfig is null) ? null : ThisWebsiteConfig.RememberedCredSaidOrNothing;
    List<RecursiveDictionary> IssueeCredentials => (CredentialsDict is null || SelectedPrefix is null) ? new List<RecursiveDictionary>() : CredentialHelper.FilterCredentials(CredentialsDict, [("sad.a.i", SelectedPrefix)]);
    string ExpandIcon => IsCredListExpanded ? Icons.Material.Filled.ExpandLess : Icons.Material.Filled.ExpandMore;
    bool IsAutoSignSafeHeaders => ThisWebsiteConfig?.IsAutoSignSafeHeaders ?? false;
    Uri? OriginUri => OriginStr is null ? null : tryCreateUri(OriginStr);

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation("OnInitializedAsync...");

        // Subscribe to port disconnect to track when we need to refresh on reconnect
        appBwPortService.Disconnected += OnPortDisconnected;
        appBwPortService.MessageReceived += OnPortMessageReceived;

        // Subscribe to AppCache changes so credentials refresh reactively when BackgroundWorker updates session storage
        await this.SubscribeToAppCache(appCache, onChanged: async () => await getCredentials());

        await getCredentials();
        // Load website config after credentials so auto-select has data to work with
        if (OriginUri is not null)
        {
            await refreshFromWebsiteConfig(OriginUri);
        }
        // inform parent so it can enable or disable Sign In button, for example
        await sendValueToParent();
    }

    private void OnPortDisconnected(object? sender, EventArgs e)
    {
        logger.LogInformation("WebsiteConfigDisplay: Port disconnected, will refresh on reconnect");
        _wasDisconnected = true;
        InvokeAsync(StateHasChanged);
    }

    private void OnPortMessageReceived(object? sender, PortMessage message)
    {
        // When we receive READY message after reconnect, refresh credentials
        if (message is ReadyMessage && _wasDisconnected && !_isRefreshing)
        {
            logger.LogInformation("WebsiteConfigDisplay: Port reconnected, refreshing credentials");
            _wasDisconnected = false;
            _ = RefreshAfterReconnectAsync();
        }
    }

    private async Task RefreshAfterReconnectAsync()
    {
        if (_isRefreshing) return;
        _isRefreshing = true;

        try
        {
            await appCache.WaitForAppCache([() => appCache.IsBwReady]);

            await getCredentials();
            if (OriginUri is not null)
            {
                await refreshFromWebsiteConfig(OriginUri);
            }
            await sendValueToParent();
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "WebsiteConfigDisplay: Error refreshing after reconnect");
        }
        finally
        {
            _isRefreshing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // logger.LogInformation("OnParametersSetAsync");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // refreshFromWebsiteConfig is now called in OnInitializedAsync (after getCredentials)
        // to ensure credentials are available for auto-selection.
    }

    Uri? tryCreateUri(string origin)
    {
        try
        {
            return new Uri(origin);
        }
        catch (Exception ex)
        {
            logger.LogError("Error parsing OriginStr '{OriginStr}': {Error}", origin, ex);
            return null;
        }
    }

    /*
    * Send data back to host of this component, such as the RequestSignInPage or RequestSignPage.
    */
    async Task sendValueToParent()
    {
        StateHasChanged(); // update reactive properties
        logger.LogInformation($"SendValueToParent prefix: {SelectedPrefix} | SelectedCredential {SelectedCredentialOrNothing is not null}");

        if (ValueChanged.HasDelegate && Identifiers is not null)
        {
            var selectedAid = Identifiers.Find(x => x.Prefix == SelectedPrefix);
            if (selectedAid is not null)
            {
                var selectedAlias = selectedAid.Name;
                await ValueChanged.InvokeAsync((SelectedPrefix, selectedAlias, SelectedCredentialOrNothing, ThisWebsiteConfig));
            }
        }
    }

    async Task refreshFromWebsiteConfig(Uri? originUri)
    {
        logger.LogInformation("RefreshFromWebsiteConfig: originUri: {i}", originUri!.OriginalString);
        if (originUri is null)
        {
            ThisWebsiteConfig = null;
            SelectedPrefix = null;
        }
        else
        {
            try
            {
                var getOrCreateWebsiteRes = await websiteConfigService.GetOrCreateWebsiteConfig(originUri);
                if (getOrCreateWebsiteRes.IsFailed)
                {
                    throw new Exception($"Error from websiteService {getOrCreateWebsiteRes.Errors}");
                }
                var (newWebsite, isConfigNew) = getOrCreateWebsiteRes.Value;
                ThisWebsiteConfig = newWebsite;

                if (isConfigNew)
                {
                    SelectedPrefix = appCache.SelectedPrefix;
                    if (SelectedPrefix is null && Identifiers.Count > 0)
                    {
                        SelectedPrefix = Identifiers[0].Prefix;
                    }
                    ThisWebsiteConfig = ThisWebsiteConfig with { RememberedPrefixOrNothing = SelectedPrefix };
                    await updateWebsiteConfigAndParent(ThisWebsiteConfig);
                    // Note above includes StateHasChanged.
                    await autoSelectCredentialIfNeeded();
                    return;
                }
                else
                {
                    SelectedPrefix = ThisWebsiteConfig.RememberedPrefixOrNothing;
                    if (SelectedPrefix is null && Identifiers.Count > 0)
                    {
                        SelectedPrefix = Identifiers[0].Prefix;
                        ThisWebsiteConfig = ThisWebsiteConfig with { RememberedPrefixOrNothing = SelectedPrefix };
                        await updateWebsiteConfigAndParent(ThisWebsiteConfig);
                    }
                    StateHasChanged();
                    await autoSelectCredentialIfNeeded();
                    return;
                }
            }
            catch
            {
                throw new Exception("could not RefreshFromWebsiteConfig");
            }
        }
        logger.LogInformation("RefreshFromWebsiteConfig: done");
    }



    async Task autoSelectCredentialIfNeeded()
    {
        if (IsCredentialShown && IsCredentialRequired && SelectedCredentialOrNothing is null && IssueeCredentials.Count > 0)
        {
            await updateSelectedCredential(IssueeCredentials[0]);
        }
    }

    async Task updateSelectedPrefix(string prefix)
    {
        logger.LogInformation("updateSelectedPrefix set prefix to {p}", prefix);
        IsCredListExpanded = false;
        SelectedPrefix = prefix;

        if (ThisWebsiteConfig is null)
        {
            throw new Exception($"updateSelectedPrefix: ThisWebsiteConfig should not be null here.");
        }
        // when changing the Prefix, any prior selection of RememberedCred will not be relevant
        ThisWebsiteConfig = ThisWebsiteConfig with
            {
                RememberedPrefixOrNothing = prefix,
                RememberedCredSaidOrNothing = null,
                IsAutoSignInCredential = false,
                IsAutoSignInIdentifier = false,
                IsAutoSignSafeHeaders = false
            };
        await updateWebsiteConfigAndParent(ThisWebsiteConfig);
        if (OriginUri is not null)
        {
            // Re-sync from storage in case another tab modified the config
            await refreshFromWebsiteConfig(OriginUri);
        }
    }

    async Task updateSelectedCredential(RecursiveDictionary? newSelectedCredential)
    {
        if (newSelectedCredential is null || !newSelectedCredential.Any())
        {
            logger.LogError($"updateSelectedCredential: credential should not be null or empty here.");
            return;
        }
        if (ThisWebsiteConfig is null)
        {
            logger.LogError("updateSelectedCredential: ThisWebsiteConfig should not be null here.");
            return;
        }
        if (newSelectedCredential is null || !newSelectedCredential.Any())
        {
            logger.LogError("unexpected null newSelectedCredential");
            return;
        }

        var newCredSaidOrNothing = newSelectedCredential.GetValueByPath("sad.d")?.Value?.ToString() ?? null;
        if (newCredSaidOrNothing is null)
        {
            string json = JsonConvert.SerializeObject(newSelectedCredential, Formatting.Indented);
            logger.LogInformation("updateSelectedCredential set to ~ ", json);
            logger.LogError($"updateSelectedCredential: Could not find SAID of credential");
            return;
        }
        // logger.LogWarning("updateSelectedCredential credSaid: ", newCredSaidOrNothing);

        ThisWebsiteConfig = ThisWebsiteConfig with
            {
                RememberedCredSaidOrNothing = newCredSaidOrNothing,
                RememberedPrefixOrNothing = SelectedPrefix,
            };

        await updateWebsiteConfigAndParent(ThisWebsiteConfig);

        IsCredListExpanded = false;
        if (OriginUri is not null)
        {
            // Re-sync from storage in case another tab modified the config
            await refreshFromWebsiteConfig(OriginUri);
        }
    }

    async Task clearSelectedCredential()
    {
        if (ThisWebsiteConfig is null) return;
        ThisWebsiteConfig = ThisWebsiteConfig with { RememberedCredSaidOrNothing = null };
        await updateWebsiteConfigAndParent(ThisWebsiteConfig);
        IsCredListExpanded = false;
        if (OriginUri is not null)
        {
            await refreshFromWebsiteConfig(OriginUri);
        }
    }

    async Task getCredentials()
    {
        // Read credentials from session storage (cached by BackgroundWorker)
        try
        {
            var cached = await storageService.GetItem<CachedCredentials>(StorageArea.Session);
            if (cached.IsSuccess && cached.Value?.RawJson is not null)
            {
                CredentialsDict = Helper.CredentialHelper.DeserializeCredentialsRawJson(cached.Value.RawJson);
                logger.LogInformation("Loaded {Count} credentials from session storage", CredentialsDict.Count);
            }
            else
            {
                CredentialsDict = [];
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error reading credentials from session storage");
            CredentialsDict = [];
        }
        StateHasChanged();
    }

    async Task updateIsAutoSign(bool isChecked)
    {
        // IsAutoSign = isChecked;
        logger.LogInformation("updateIsAutoSignInCred isChecked: {b} WebsiteConfig: {w}", isChecked, ThisWebsiteConfig);
        if (ThisWebsiteConfig is not null && ThisWebsiteConfig.IsAutoSignSafeHeaders != isChecked)
        {
            ThisWebsiteConfig = ThisWebsiteConfig with { IsAutoSignSafeHeaders = isChecked };
            await updateWebsiteConfigAndParent(ThisWebsiteConfig);
        }
        StateHasChanged(); // needed?
    }

    string getCredentialItemClass(RecursiveDictionary item)
    {
        return item == SelectedCredentialOrNothing ? "selected-item pa-1 ml-1 mr-1" : "pa-1 ml-2 mr-1";
    }

    string getIdentifierItemClass(string prefix)
    {
        return prefix == SelectedPrefix ? "selected-item" : String.Empty;
    }

    async Task updateWebsiteConfigAndParent(WebsiteConfig wc)
    {
        var res = await websiteConfigService.Update(wc);
        if (res.IsFailed)
        {
            logger.LogWarning("Failed to update website config for {Origin}: {Errors}",
                wc.Origin, string.Join(", ", res.Errors.Select(e => e.Message)));
            snackbar.Add("Failed to save website configuration", Severity.Warning);
        }
        await sendValueToParent();
    }

    public void Dispose()
    {
        appBwPortService.Disconnected -= OnPortDisconnected;
        appBwPortService.MessageReceived -= OnPortMessageReceived;
        this.UnsubscribeFromAppCache();
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    @if (IsOriginShown)
    {
        <MudText Typo="Typo.body1"><em>@OriginStr</em></MudText>
    }

    @if (Identifiers is not null && Identifiers.Any())
    {
        <!-- Select Identifier — available immediately from AppCache -->
        <MudStack Style="gap:0;">
            <MudText Class="bt-section-title" Style="margin-top:0; margin-bottom:0;">@Heading</MudText>
            <MudStack Class="ml-0" Style="gap:0;">
                <MudSelect T="string" Value="SelectedPrefix" ValueChanged="async (string v) => await updateSelectedPrefix(v)" Placeholder="Select">
                    @foreach (var aid in Identifiers)
                    {
                        <MudSelectItem T="string" Value="aid.Prefix" Class="@getIdentifierItemClass(aid.Prefix)">
                            <AidPrefixDisplay Prefix="@aid.Prefix" Name="@aid.Name" ShowCopyButton="false" />
                        </MudSelectItem>
                    }
                </MudSelect>
            </MudStack>
        </MudStack>

        @if (IsCredentialShown && SelectedPrefix is not null)
        {
            @if (CredentialsDict is null)
            {
                <!-- Credentials loading from session storage -->
                <MudStack Class="gap-0">
                    <MudText Class="bt-section-title">Credential</MudText>
                    <MudStack Row="true" AlignItems="AlignItems.Center" Class="ml-2" Style="min-height: 48px;">
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                        <MudText Typo="Typo.body2">Loading...</MudText>
                    </MudStack>
                </MudStack>
            }
            else if (CredentialsDict.Any())
            {
                <!-- Select Credential --->
                <MudStack Class="gap-0">
                    <MudText Class="bt-section-title">Credential</MudText>
                    <MudStack Class="ml-0" Style="gap:0;">
                        <!-- Display Selected Credential or Selection List -->
                        @if (IssueeCredentials.Count == 0)
                        {
                            <MudText Class="ml-3">No credentials held.</MudText>
                        }
                        else if (!IsCredListExpanded)
                        {
                            <MudPaper Elevation="0" Class="d-flex align-items-center" @onclick="() => IsCredListExpanded = !IsCredListExpanded" Style="cursor: pointer;">
                                @if (SelectedCredentialOrNothing is null)
                                {
                                    <div style="width:100%; align-content:center;">
                                        <MudText Class="ml-3">Select@(IsCredentialRequired ? "" : " (optional)")</MudText>
                                    </div>
                                }
                                else
                                {
                                    <CredentialPanelCompact Credential="@SelectedCredentialOrNothing" IsSelected="true" />
                                }
                                <MudSpacer />
                                <MudIconButton Style="padding: 0;" Icon="@ExpandIcon" OnClick="() => IsCredListExpanded = !IsCredListExpanded" />
                            </MudPaper>
                        }
                        else
                        {
                            <MudStack Spacing="1">
                                @if (!IsCredentialRequired)
                                {
                                    var isNoneSelected = SelectedCredentialOrNothing is null;
                                    <div @onclick="async () => await clearSelectedCredential()" style="cursor: pointer;">
                                        <MudPaper Elevation="0" Class="@(isNoneSelected ? "selected-item pa-1 ml-1 mr-1" : "pa-1 ml-2 mr-1")">
                                            <MudText Class="ml-2" Style="font-style: italic;">None</MudText>
                                        </MudPaper>
                                    </div>
                                }
                                @foreach (RecursiveDictionary credential in IssueeCredentials)
                                {
                                    var isSelected = credential.GetValueByPath("sad.d")?.Value as string == SelectedCredSaidOrNothing;
                                    <div @onclick="async () => await updateSelectedCredential(credential)" style="cursor: pointer;">
                                        <CredentialPanelCompact Credential="@credential" IsSelected="@isSelected" />
                                    </div>
                                }
                            </MudStack>
                        }
                        @if (IsAutoSignShown)
                        {
                            <MudCheckBox Label="Auto-sign Http Request Headers that have no side effects" Disabled="@(SelectedCredentialOrNothing is null)" style="height: 28px;" Value="IsAutoSignSafeHeaders" ValueChanged="async (bool b) => await updateIsAutoSign(b)" />
                        }
                    </MudStack>
                </MudStack>
            }
            else
            {
                <MudStack Class="gap-0">
                    <MudText Class="bt-section-title">Credential</MudText>
                    <MudText Class="ml-3">No available credentials.</MudText>
                </MudStack>
            }
        }
    }
    else
    {
        <MudStack Class="gap-0">
            <MudText Class="bt-section-title">@Heading</MudText>
            <MudStack Row="true" AlignItems="AlignItems.Center" Class="ml-2" Style="min-height: 48px;">
                <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                <MudText Typo="Typo.body2">Loading...</MudText>
            </MudStack>
        </MudStack>
    }
</div>

