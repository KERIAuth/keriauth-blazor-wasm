@using Newtonsoft.Json
@using Extension.Services.Storage
@using Extension.Models.Messages.AppBw
@using Extension.Models.Messages.Port

@implements IDisposable

@inject ILogger<WebsiteConfigDisplay> logger
@inject IWebsiteConfigService websiteConfigService
@inject IStorageService storageService
@inject IDialogService dialogService
@inject ISnackbar snackbar
@inject IAppBwPortService appBwPortService
@using Extension.Services.Port
@inject IJSRuntime jsRuntime
@inject NavigationManager navManager
@inject AppCache appCache

@using Extension.Services.SignifyService.Models

@code {
    [Parameter] public required string? OriginStr { get; init; }
    [Parameter] public required bool IsCredentialShown { get; init; }
    [Parameter] public required bool IsOriginShown { get; init; }
    [Parameter] public required bool IsAutoSignShown { get; init; }
    [Parameter] public EventCallback<(string? selectedPrefix, string? selectedAlias, RecursiveDictionary? selectedCredential, WebsiteConfig? websiteConfig)> ValueChanged { get; init; }

    // properties
    bool IsCredListExpanded { get; set; }
    bool IsAutoSignInIdentifier { get; set; }
    string? SelectedPrefix { get; set; }
    WebsiteConfig? ThisWebsiteConfig { get; set; }
    List<RecursiveDictionary>? CredentialsDict { get; set; }

    // Track port connection state for refresh logic
    private bool _wasDisconnected;
    private bool _isRefreshing;

    // computed properties
    // TODO P2 optimize SelectedCredentialOrNothing expression to use FilteredCredentials
    List<Aid> Identifiers => appCache.MyKeriaConnectionInfo.IdentifiersList.Count > 0
        ? appCache.MyKeriaConnectionInfo.IdentifiersList[0].Aids.OrderBy(a => a.Name).ToList()
        : new List<Aid>();
    RecursiveDictionary? SelectedCredentialOrNothing => (SelectedCredSaidOrNothing is null || CredentialsDict is null) ? null : filterCredentials(CredentialsDict, [("sad.d", SelectedCredSaidOrNothing)])?.FirstOrDefault();
    string? SelectedCredSaidOrNothing => (ThisWebsiteConfig is null) ? null : ThisWebsiteConfig.RememberedCredSaidOrNothing;
    List<RecursiveDictionary> IssueeCredentials => (CredentialsDict is null || SelectedPrefix is null) ? new List<RecursiveDictionary>() : filterCredentials(CredentialsDict, [("sad.a.i", SelectedPrefix)]);
    string ExpandIcon => IsCredListExpanded ? Icons.Material.Filled.ExpandLess : Icons.Material.Filled.ExpandMore;
    bool IsAutoSignSafeHeaders => ThisWebsiteConfig?.IsAutoSignSafeHeaders ?? false;
    Uri? OriginUri => OriginStr is null ? null : tryCreateUri(OriginStr);

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation("OnInitializedAsync...");

        // Subscribe to port disconnect to track when we need to refresh on reconnect
        appBwPortService.Disconnected += OnPortDisconnected;
        appBwPortService.MessageReceived += OnPortMessageReceived;

        await getCredentials();
        // inform parent so it can enable or disable Sign In button, for example
        await sendValueToParent();
    }

    private void OnPortDisconnected(object? sender, EventArgs e)
    {
        logger.LogInformation("WebsiteConfigDisplay: Port disconnected, will refresh on reconnect");
        _wasDisconnected = true;
        InvokeAsync(StateHasChanged);
    }

    private void OnPortMessageReceived(object? sender, PortMessage message)
    {
        // When we receive READY message after reconnect, refresh credentials
        if (message is ReadyMessage && _wasDisconnected && !_isRefreshing)
        {
            logger.LogInformation("WebsiteConfigDisplay: Port reconnected, refreshing credentials");
            _wasDisconnected = false;
            _ = RefreshAfterReconnectAsync();
        }
    }

    private async Task RefreshAfterReconnectAsync()
    {
        if (_isRefreshing) return;
        _isRefreshing = true;

        try
        {
            // Small delay to ensure BW is fully ready
            // TODO P2 should invoke WaitForAppCacheReady or similar instead of arbitrary delay...
            await Task.Delay(100);

            await getCredentials();
            if (OriginUri is not null)
            {
                await refreshFromWebsiteConfig(OriginUri);
            }
            await sendValueToParent();
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "WebsiteConfigDisplay: Error refreshing after reconnect");
        }
        finally
        {
            _isRefreshing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // logger.LogInformation("OnParametersSetAsync");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            logger.LogInformation("OnAfterRenderAsync");
            if (OriginUri is not null)
            {
                await refreshFromWebsiteConfig(OriginUri);
            }
        }
    }

    Uri? tryCreateUri(string origin)
    {
        try
        {
            return new Uri(origin);
        }
        catch (Exception ex)
        {
            logger.LogError("Error parsing OriginStr '{OriginStr}': {Error}", origin, ex);
            return null;
        }
    }

    /*
    * Send data back to host of this component, such as the RequestSignInPage or RequestSignPage.
    */
    async Task sendValueToParent()
    {
        StateHasChanged(); // update reactive properties
        logger.LogInformation($"SendValueToParent prefix: {SelectedPrefix} | SelectedCredential {SelectedCredentialOrNothing is not null}");

        if (ValueChanged.HasDelegate && Identifiers is not null)
        {
            var selectedAid = Identifiers.Find(x => x.Prefix == SelectedPrefix);
            if (selectedAid is not null)
            {
                var selectedAlias = selectedAid.Name;
                await ValueChanged.InvokeAsync((SelectedPrefix, selectedAlias, SelectedCredentialOrNothing, ThisWebsiteConfig));
            }
        }
    }

    async Task refreshFromWebsiteConfig(Uri? originUri)
    {
        logger.LogInformation("RefreshFromWebsiteConfig: originUri: {i}", originUri!.OriginalString);
        if (originUri is null)
        {
            ThisWebsiteConfig = null;
            SelectedPrefix = null;
        }
        else
        {
            try
            {
                var getOrCreateWebsiteRes = await websiteConfigService.GetOrCreateWebsiteConfig(originUri);
                if (getOrCreateWebsiteRes.IsFailed)
                {
                    throw new Exception($"Error from websiteService {getOrCreateWebsiteRes.Errors}");
                }
                var (newWebsite, isConfigNew) = getOrCreateWebsiteRes.Value;
                ThisWebsiteConfig = newWebsite;

                if (isConfigNew)
                {
                    SelectedPrefix = appCache.SelectedPrefix;
                    ThisWebsiteConfig = ThisWebsiteConfig with { RememberedPrefixOrNothing = SelectedPrefix };
                    await updateWebsiteConfigAndParent(ThisWebsiteConfig);
                    // Note above includes StateHasChanged.
                    return;
                }
                else
                {
                    SelectedPrefix = ThisWebsiteConfig.RememberedPrefixOrNothing!;
                    // Required: SelectedPrefix was just set from storage, so the UI must re-render
                    // to reflect the selected profile in the MudSelect dropdown.
                    StateHasChanged();
                    return;
                }
            }
            catch
            {
                throw new Exception("could not RefreshFromWebsiteConfig");
            }
        }
        logger.LogInformation("RefreshFromWebsiteConfig: done");
    }

    // TODO P2 DRY move this filterCredentials to a helper
    // TODO P2 Incorporate this use into the Credentials display to (checkbox) Show selected Identifier only, default true
    public static List<RecursiveDictionary> filterCredentials(List<RecursiveDictionary> credentialDictList, List<(string filterPath, string match)> filters)
    {
        if (!filters.Any())
        {
            throw new Exception("filterCredentials must have at least one filter string");
        }
        List<RecursiveDictionary> filteredCredentials = new();
        foreach (var credDict in credentialDictList)
        {
            foreach (var filter in filters)
            {
                // include filtered value if any of the filters match (versus all)
                var value = credDict.GetValueByPath(filter.filterPath)?.Value as string;
                if (value != null && value == filter.match)
                {
                    filteredCredentials.Add(credDict);
                    break;
                }
            }
        }
        // logger.LogWarning("filteredCredentials: count: {c} ", filteredCredentials.Count);
        return filteredCredentials;
    }

    async Task updateSelectedPrefix(string prefix)
    {

        logger.LogInformation("updateSelectedPrefix set prefix to {p}", prefix);
        IsCredListExpanded = false;

        if (ThisWebsiteConfig is null)
        {
            throw new Exception($"updateSelectedPrefix: ThisWebsiteConfig should not be null here.");
        }
        // when changing the Prefix, any prior selection of RememberedCred will not be relevant
        var newWebsiteConfig = ThisWebsiteConfig with
            {
                RememberedPrefixOrNothing = prefix,
                RememberedCredSaidOrNothing = null,
                IsAutoSignInCredential = false,
                IsAutoSignInIdentifier = false,
                IsAutoSignSafeHeaders = false
            };
        logger.LogInformation("updateSelectedPrefix 2");
        // _ = newWebsiteConfig.Validate();
        logger.LogInformation("updateSelectedPrefix 3");
        await updateWebsiteConfigAndParent(newWebsiteConfig);
        logger.LogInformation("updateSelectedPrefix updated ConfigAndParent");
        if (OriginUri is not null)
        {
            StateHasChanged(); // update reactive properties
            await refreshFromWebsiteConfig(OriginUri);
            // Note, if changing selection like Prefix, the parent's Sign In button may need to be disabled
            await sendValueToParent();
        }
        logger.LogInformation("updateSelectedPrefix 4");
        StateHasChanged(); // update reactive properties
        SelectedPrefix = prefix;
    }

    async Task updateSelectedCredential(RecursiveDictionary? newSelectedCredential)
    {
        if (newSelectedCredential is null || !newSelectedCredential.Any())
        {
            logger.LogError($"updateSelectedCredential: credential should not be null or empty here.");
            return;
        }
        if (ThisWebsiteConfig is null)
        {
            logger.LogError("updateSelectedCredential: ThisWebsiteConfig should not be null here.");
            return;
        }
        if (newSelectedCredential is null || !newSelectedCredential.Any())
        {
            logger.LogError("unexpected null newSelectedCredential");
            return;
        }

        var newCredSaidOrNothing = newSelectedCredential.GetValueByPath("sad.d")?.Value?.ToString() ?? null;
        if (newCredSaidOrNothing is null)
        {
            string json = JsonConvert.SerializeObject(newSelectedCredential, Formatting.Indented);
            logger.LogInformation("updateSelectedCredential set to ~ ", json);
            logger.LogError($"updateSelectedCredential: Could not find SAID of credential");
            return;
        }
        // logger.LogWarning("updateSelectedCredential credSaid: ", newCredSaidOrNothing);

        var newWebsiteConfig = ThisWebsiteConfig with
            {
                RememberedCredSaidOrNothing = newCredSaidOrNothing,
                RememberedPrefixOrNothing = SelectedPrefix,
            };

        await updateWebsiteConfigAndParent(newWebsiteConfig);

        IsCredListExpanded = false;
        // TODO P3 why is any of the following needed?
        if (OriginUri is not null)
        {
            await refreshFromWebsiteConfig(OriginUri);
            StateHasChanged(); // update reactive properties
            await sendValueToParent(); // needed?
        }
        return;
    }

    async Task getCredentials()
    {
        // Fetch credentials from BackgroundWorker via RPC
        if (!appCache.IsConnectedToKeria)
        {
            logger.LogDebug("Not connected to KERIA, skipping credentials fetch");
            CredentialsDict = [];
            StateHasChanged();
            return;
        }

        try
        {
            var response = await appBwPortService.SendRpcRequestAsync(
                AppBwMessageType.Values.RequestGetCredentials,
                new { });

            if (!response.Ok)
            {
                logger.LogWarning("Failed to fetch credentials via RPC: {Error}", response.Error);
                CredentialsDict = [];
                StateHasChanged();
                return;
            }

            // Parse the response payload (use PortMessaging for RecursiveDictionary support)
            var credentialsResult = response.Result is System.Text.Json.JsonElement jsonEl
                ? System.Text.Json.JsonSerializer.Deserialize<GetCredentialsResponsePayload>(jsonEl.GetRawText(), Helper.JsonOptions.PortMessaging)
                : null;

            if (credentialsResult is not null && credentialsResult.Success && credentialsResult.Credentials is not null)
            {
                CredentialsDict = credentialsResult.Credentials;
                logger.LogInformation("Fetched {Count} credentials via RPC", CredentialsDict.Count);
            }
            else
            {
                logger.LogWarning("Failed to fetch credentials: {Error}", credentialsResult?.Error ?? "Unknown error");
                CredentialsDict = [];
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error fetching credentials via RPC");
            CredentialsDict = [];
        }
        StateHasChanged();
    }

    async Task updateIsAutoSign(bool isChecked)
    {
        // IsAutoSign = isChecked;
        logger.LogInformation("updateIsAutoSignInCred isChecked: {b} WebsiteConfig: {w}", isChecked, ThisWebsiteConfig);
        if (ThisWebsiteConfig is not null && ThisWebsiteConfig.IsAutoSignSafeHeaders != isChecked)
        {
            ThisWebsiteConfig = ThisWebsiteConfig with { IsAutoSignSafeHeaders = isChecked };
            await updateWebsiteConfigAndParent(ThisWebsiteConfig);
        }
        StateHasChanged(); // needed?
    }

    string getCredentialItemClass(RecursiveDictionary item)
    {
        return item == SelectedCredentialOrNothing ? "selected-item pa-1 ml-1 mr-1" : "pa-1 ml-2 mr-1";
    }

    string getIdentifierItemClass(string prefix)
    {
        return prefix == SelectedPrefix ? "selected-item" : String.Empty;
    }

    async Task updateWebsiteConfigAndParent(WebsiteConfig wc)
    {
        // TODO P2 evaluate results
        var res = await websiteConfigService.Update(wc);
        logger.LogInformation("UpdateWebsiteConfigAndParent success: {r}", res.IsSuccess);
        await sendValueToParent();
    }

    public void Dispose()
    {
        appBwPortService.Disconnected -= OnPortDisconnected;
        appBwPortService.MessageReceived -= OnPortMessageReceived;
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    @if (IsOriginShown)
    {
        <MudText Typo="Typo.body1"><em>@OriginStr</em></MudText>
    }

    @if (Identifiers is not null && Identifiers.Any() && CredentialsDict is not null)
    {
        <!-- Select Identifier -->
        <MudStack Style="gap:0;">
            <MudText Class="bt-section-title" Style="margin-top:0; margin-bottom:0;">Profile</MudText>
            <MudStack Class="ml-0" Style="gap:0;">
                <MudSelect T="string" Value="SelectedPrefix" ValueChanged="async (string v) => await updateSelectedPrefix(v)" Placeholder="Select">
                    @foreach (var aid in Identifiers)
                    {
                        <MudSelectItem T="string" Value="aid.Prefix" Class="@getIdentifierItemClass(aid.Prefix)">
                            <AidPrefixDisplay Prefix="@aid.Prefix" Name="@aid.Name" ShowCopyButton="false" />
                        </MudSelectItem>
                    }
                </MudSelect>
            </MudStack>
        </MudStack>

        @if (IsCredentialShown && CredentialsDict.Any() && SelectedPrefix is not null)
        {
            <!-- Select Credential --->
            <MudStack Class="gap-0">
                <MudText Class="bt-section-title">Credential</MudText>
                <MudStack Class="ml-0" Style="gap:0;">
                    <!-- Display Selected Credential or Selection List -->
                    @if (!IsCredListExpanded)
                    {
                        <MudPaper Elevation="0" Class="d-flex align-items-center" @onclick="() => IsCredListExpanded = !IsCredListExpanded" Style="cursor: pointer;">
                            @if (SelectedCredentialOrNothing is null)
                            {
                                // TODO P1: distinguish label for optional versus required credential selection, e.g. "Select credential (optional)" vs "Select credential (required)"
                                <div style="width:100%; align-content:center;">
                                    <MudText Class="ml-3">Select</MudText>
                                </div>
                            }
                            else
                            {
                                <CredentialPanelCompact Credential="@SelectedCredentialOrNothing" IsSelected="true" />
                            }
                            <MudSpacer />
                            <MudIconButton Style="padding: 0;" Icon="@ExpandIcon" OnClick="() => IsCredListExpanded = !IsCredListExpanded" />
                        </MudPaper>
                    }
                    else
                    {
                        @if (IssueeCredentials is not null && IssueeCredentials.Any())
                        {
                            <MudStack Spacing="1">
                                @foreach (RecursiveDictionary credential in IssueeCredentials)
                                {
                                    var isSelected = credential == SelectedCredentialOrNothing;
                                    <div @onclick="async () => await updateSelectedCredential(credential)" style="cursor: pointer;">
                                        <CredentialPanelCompact Credential="@credential" IsSelected="@isSelected" />
                                    </div>
                                }
                            </MudStack>
                        }
                        else
                        {
                            <MudText>No credentials issued to this profile.</MudText>
                        }
                    }
                    @if (IsAutoSignShown)
                    {
                        <MudCheckBox Label="Auto-sign Http Request Headers that have no side effects" Disabled="@(SelectedCredentialOrNothing is null)" style="height: 28px;" Value="IsAutoSignSafeHeaders" ValueChanged="async (bool b) => await updateIsAutoSign(b)" />
                    }
                </MudStack>
            </MudStack>
        }
    }
    else
    {
        <MudStack Class="gap-0">
            <MudText Class="bt-section-title">Profile</MudText>
            <MudStack Row="true" AlignItems="AlignItems.Center" Class="ml-2" Style="min-height: 48px;">
                <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                <MudText Typo="Typo.body2">Loading...</MudText>
            </MudStack>
        </MudStack>
    }
</div>

