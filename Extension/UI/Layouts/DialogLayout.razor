@inherits BaseLayout

@inject IJSRuntime jsRuntime
@inject AppCache appCache  // Reactive: inherits subscription from BaseLayout
@inject ILogger<DialogLayout> logger
@inject NavigationManager navManager

<MudThemeProvider Theme="@AppConfig.MyCustomTheme" IsDarkMode="@appCache.MyPreferences.IsDarkTheme" />

@* Action spinner overlay - shown after delay when action is in progress *@
@if (ShowActionSpinner) {
    <div class="action-spinner-overlay">
        <MudProgressCircular Indeterminate="true" Size="Size.Large" />
    </div>
}
<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider Style="z-index:9999; position:absolute;" />

<CascadingValue Value="this">
    <MudLayout id="@this.GetType().Name" Style="overflow-y:hidden; overflow-x:hidden; box-sizing: border-box; position:absolute; top:0; width:100vw;">
        <MudAppBar Class="bt-appbar">
            <MudStack Style="height:inherit; width: 100%; padding:0 0.5rem 0 0.25rem;" Class="d-flex" Row="true">
                <LogoButton />
                
                <MudSpacer />

                <SessionStatusIndicator IsAuthenticated="@appCache.IsAuthenticated"
                                        IsIdentifierFetched="@appCache.IsIdentifierFetched"
                                        IsConfigured="@appCache.IsConfigured"
                                        IsHovered="@isTimeoutHovered"
                                        TimeoutInfo="@TimeoutText"
                                        TimeoutTooltip="@TimeoutTooltip"
                                        SessionPercentageRemaining="@SessionPercentageRemaining"
                                        SessionDurationRemainingSeconds="@SessionDurationRemainingSeconds"
                                        OnHoverChanged="@((hovered) => isTimeoutHovered = hovered)"
                                        OnRefreshConnect="@RefreshConnect"
                                        OnLockClick="@(() => navManager.NavigateTo(Routes.PathFor<UnlockPage>()))"
                                        KeriaAlias="@KeriaAlias"
                                        IsMultiKeriaConfigEnabled="@IsMultiKeriaConfigEnabled" />

            </MudStack>
        </MudAppBar>
        <MudMainContent Class="bt-main-content" Style="left:0; top:4.357rem;">
            <MudContainer MaxWidth="MaxWidth.Large" Style="height:inherit; min-height:inherit; padding-left:0; padding-right:0;">
                @Body
            </MudContainer>
        </MudMainContent>
    </MudLayout>
</CascadingValue>

@code {
    // Computed properties for SessionStatusIndicator
    string? KeriaAlias => appCache.GetSelectedKeriaConnectConfig()?.Alias;
    bool IsMultiKeriaConfigEnabled => appCache.MyPreferences.IsMultiKeriaConfigEnabled;

    #region Action Spinner

    /// <summary>
    /// Whether the spinner overlay is currently visible.
    /// Set to true after SpinnerDelayMs when an action is in progress.
    /// </summary>
    public bool ShowActionSpinner { get; private set; }

    /// <summary>
    /// Whether an action is currently in progress (button clicked, waiting for completion).
    /// </summary>
    public bool IsActionInProgress { get; private set; }

    /// <summary>
    /// Delay in milliseconds before showing the spinner.
    /// Prevents flashing for fast operations.
    /// </summary>
    private const int SpinnerDelayMs = 100;

    private CancellationTokenSource? _spinnerDelayCts;

    /// <summary>
    /// Call when starting a potentially slow action (Cancel, Approve, etc.).
    /// Shows spinner after SpinnerDelayMs if action is still in progress.
    /// </summary>
    public async Task BeginActionAsync() {
        if (IsActionInProgress) return;

        IsActionInProgress = true;
        _spinnerDelayCts = new CancellationTokenSource();
        StateHasChanged();

        // Start timer to show spinner after delay
        _ = ShowSpinnerAfterDelayAsync(_spinnerDelayCts.Token);
        await Task.CompletedTask;
    }

    private async Task ShowSpinnerAfterDelayAsync(CancellationToken ct) {
        try {
            await Task.Delay(SpinnerDelayMs, ct);
            if (!ct.IsCancellationRequested) {
                ShowActionSpinner = true;
                StateHasChanged();
            }
        }
        catch (TaskCanceledException) {
            // Expected when action completes before delay
        }
    }

    /// <summary>
    /// Call when action completes. Cancels spinner timer and hides spinner.
    /// Note: Usually not needed since navigation/close will dispose the component.
    /// </summary>
    public void EndAction() {
        _spinnerDelayCts?.Cancel();
        _spinnerDelayCts?.Dispose();
        _spinnerDelayCts = null;
        IsActionInProgress = false;
        ShowActionSpinner = false;
        StateHasChanged();
    }

    #endregion

    /// <summary>
    /// Closes the popup window (when DialogLayout is rendered in popup context)
    /// </summary>
    public async Task ClosePopupAsync() {
        try {
            await jsRuntime.InvokeVoidAsync("window.close");
        }
        catch (Exception ex) {
            logger.LogError(ex, "DialogLayout.ClosePopupAsync: Failed to close popup window");
        }
    }

    protected override async Task HandleAppCacheChanged()
    {
        await base.HandleAppCacheChanged();
        logger.LogInformation("HandleAppCacheChanged");
        // Note: StateHasChanged() is called by base.HandleAppCacheChanged()
    }

    public override async ValueTask DisposeAsync()
    {
        _spinnerDelayCts?.Cancel();
        _spinnerDelayCts?.Dispose();
        await base.DisposeAsync();
    }

    public async Task ReturnToPriorUI()
    {
        logger.LogInformation("ReturnToPriorUI: Returning to prior UI context: {AppContextType}", App.AppContext);
        switch (App.AppContext)
        {
            case ContextType.POPUP:
                await ClosePopupAsync();
                break;
            case ContextType.SIDEPANEL:
                navManager.NavigateTo(Routes.PathFor<Extension.UI.Pages.Index>());
                break;
            case ContextType.TAB:
                navManager.NavigateTo(Routes.PathFor<Extension.UI.Pages.Index>());
                break;
            default:
                logger.LogWarning("ReturnToPriorUI: Unknown AppContextType {AppContextType}", App.AppContext);
                break;
        }
    }
}

<style>
    #DialogLayout {
        margin: 0;
    }

    .action-spinner-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.7);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    }
</style>
