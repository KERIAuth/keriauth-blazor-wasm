@inherits LayoutComponentBase
@using Extension.Models.Messages.BwApp
@using Extension.Services.Storage
@using System.Reactive.Linq

@inject HttpClient http
@inject IJSRuntime js
@inject NavigationManager navManager
@inject IStorageService storageService
@inject ISnackbar snackbar
@inject ILogger<BaseLayout> logger
@inject ISignifyClientService signifyClientService
@inject AppCache appCache  // Reactive: subscribes in OnInitializedAsync via SubscribeToAppCache()
@inject IUserActivityService userActivityService

@implements IAsyncDisposable

<!-- Note that @Body and other body content will be provided by specialized layouts inheriting from this BaseLayout -->
@code {
    protected Timer? appBarRefreshTimer;
    protected bool isTimeoutHovered = false;

    // Session timeout properties - available to all layouts
    protected TimeSpan SessionDurationRemaining => appCache.MyPasscodeModel.SessionExpirationUtc - DateTime.UtcNow;
    protected int SessionDurationRemainingSeconds => (int)SessionDurationRemaining.TotalSeconds + 1; // round up for display
    protected int SessionPercentageRemaining => (int)((SessionDurationRemaining.TotalSeconds / AppConfig.DisplaySessionExpirationAtSecondsRemaining) * 100);

    // When session is unlocked and about to expire, provide countdown tuple for display
    protected (bool IsShown, string Text, string Style) TimeoutText => (
            appCache.IsAuthenticated &&
            (int)SessionDurationRemaining.TotalSeconds < AppConfig.DisplaySessionExpirationAtSecondsRemaining &&
            (int)SessionDurationRemaining.TotalSeconds > 0)
            ? (true, $"Timeout in {SessionDurationRemaining.Seconds:D}", "color:var(--mud-palette-warning);")
            : (false, "", "color:var(--mud-palette-warning);");

    // Tooltip showing the time remaining
    protected string TimeoutTooltip => appCache.IsAuthenticated
        ? $"{SessionDurationRemaining.Minutes:D}:{SessionDurationRemaining.Seconds:D2}"
        : "Locked";

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        await appCache.Initialize();
        await AssertHydratedCache();

        await this.SubscribeToAppCache(appCache, HandleAppCacheChanged);

        CreateAppBarRefreshTimer();

        // Start user activity detection if session is unlocked
        if (appCache.IsSessionUnlocked)
        {
            await userActivityService.StartListeningAsync();
        }
    }

    protected virtual async Task HandleAppCacheChanged()
    {
        logger.LogInformation("HandleAppCacheChanged invoked");
        await AssertHydratedCache();
        // If we're on a page that requires auth (unlocked), and we're no longer authenticated, navigate to IndexPage for redirection, e.g. to UnlockPage
        if (!appCache.IsAuthenticated)
        {
            if (Routes.PathRequiresAuth("/" + navManager.ToBaseRelativePath(navManager.Uri)))
            {
                logger.LogInformation("HandleAppCacheChanged: Navigating to IndexPage since no longer authenticated");
                navManager.NavigateTo(Routes.PathFor<Extension.UI.Pages.Index>());
                return;
            }
        }

        // Start/stop user activity detection based on session state
        if (appCache.IsSessionUnlocked && !userActivityService.IsListening)
        {
            await userActivityService.StartListeningAsync();
        }
        else if (!appCache.IsSessionUnlocked && userActivityService.IsListening)
        {
            userActivityService.StopListening();
        }

        await HandleBwRequests();
        StateHasChanged();
    }

    protected async Task HandleBwRequests()
    {
        // Only process pending requests when the session is unlocked.
        // If locked, let Index.razor's routing logic handle navigation (which will show UnlockPage).
        if (!appCache.IsSessionUnlocked)
        {
            return;
        }

        // If App is in SidePanel context and there is a pending BwAppRequest, navigate to the appropriate page.
        if (App.IsInSidePanel)
        {
            var pendingRequest = appCache.NextPendingBwAppRequest;
            if (pendingRequest is not null)
            {
                logger.LogInformation("HandleBwRequests: pendingRequest Type={type}, RequestId={requestId}", pendingRequest.Type, pendingRequest.RequestId);
                switch (pendingRequest.Type)
                {
                    case BwAppMessageType.Values.RequestSelectAuthorize:
                        navManager.NavigateTo(Routes.PathFor<RequestSignInPage>());
                        break;
                    case BwAppMessageType.Values.RequestSignHeaders:
                        navManager.NavigateTo(Routes.PathFor<RequestSignHeadersPage>());
                        break;
                    case BwAppMessageType.Values.RequestSignData:
                        navManager.NavigateTo(Routes.PathFor<RequestSignDataPage>());
                        break;
                    case BwAppMessageType.Values.RequestCreateCredential:
                        navManager.NavigateTo(Routes.PathFor<RequestCreateCredentialPage>());
                        break;
                    default:
                        logger.LogWarning("HandleBwRequests: Unhandled pendingRequest Type={type}", pendingRequest.Type);
                        break;
                }
            }
        }
    }

    protected async Task RefreshConnect()
    {
        // TODO P3 not yet implemented. Intent is to refresh connection to KERIA and fetch identifier state again, etc.
        // snackbar.Add("Refreshing connection...", Severity.Info);
    }

    private async Task AssertHydratedCache()
    {
        // Ensure that AppCache is fully initialized before proceeding
        // helping assure critical records are loaded (and usually stored) before UI interaction
        // TODO P1 confirm compound assertions work in WaitForAppCache
        bool isAppCacheReady;

        // () => appCache.IsInitialized,
        logger.LogInformation("AssertHydratedCache: MyPreferences.IsStored");
        isAppCacheReady = await appCache.WaitForAppCache([() => appCache.MyPreferences.IsStored], 10000,100);
        logger.LogInformation("AssertHydratedCache: {b}", isAppCacheReady);
        logger.LogInformation("AssertHydratedCache: MyOnboardState.IsStored");
        isAppCacheReady = await appCache.WaitForAppCache([() => appCache.MyOnboardState.IsStored], 10000, 100);
        logger.LogInformation("AssertHydratedCache: {b}", isAppCacheReady);
        // logger.LogInformation("AssertHydratedCache: MyKeriaConnectConfig.IsStored");
        // isAppCacheReady = await appCache.WaitForAppCache([() => appCache.MyKeriaConnectConfig.IsStored], 10000, 100);
        // logger.LogInformation("AssertHydratedCache: {b}", isAppCacheReady);
            // () => appCache.MyKeriaConnectionInfo is not null,
            // () => appCache.MyPasscodeModel is not null

        // TODO P2: Make timeout duration configurable?
        if (!isAppCacheReady)
        {
            logger.LogError("AssertHydratedCache: AppCache not ready after waiting.");
            snackbar.Add("Application error: AppCache not ready.", Severity.Error);
            // Optionally, throw or navigate to an error page or take other actions
        }
    }

    protected void CreateAppBarRefreshTimer()
    {
        appBarRefreshTimer = new Timer(
            callback: (_) =>
            {
                // Periodically trigger a UI update of layout components only when helpful and necessary,
                // such as showing a timeout countdown when session is about to expire.
                // Note: the actual session expiration handling is done elsewhere. Search for various places of storage.clear of session storage.
                if (appCache.IsSessionNotExpired &&
                    (appCache.MyPasscodeModel.SessionExpirationUtc - DateTime.UtcNow).Seconds < AppConfig.DisplaySessionExpirationAtSecondsRemaining)
                {
                    // logger.LogInformation("RestartOrExtendAppBarUpdateTime");
                    InvokeAsync(StateHasChanged);
                }
            },
            state: null,
            dueTime: TimeSpan.FromSeconds(20), // TODO P2 calculated, but don't interfere with initialization time
            period: TimeSpan.FromSeconds(1));
    }

    public virtual async ValueTask DisposeAsync()
    {
        this.UnsubscribeFromAppCache();
        appBarRefreshTimer?.Dispose();
        userActivityService.StopListening();
        GC.SuppressFinalize(this);
    }
}
