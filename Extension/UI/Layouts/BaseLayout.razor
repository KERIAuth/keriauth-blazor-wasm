@inherits LayoutComponentBase
@using Extension.Services.Storage
@using Extension.Services.Port
@using Extension.Models.Messages.BwApp
@using System.Reactive.Linq

@inject HttpClient http
@inject IJSRuntime js
@inject NavigationManager navManager
@inject IStorageService storageService
@inject ISnackbar snackbar
@inject ILogger<BaseLayout> logger
@inject AppCache appCache
@inject IUserActivityService userActivityService
@inject IAppBwPortService appBwPortService

@implements IAsyncDisposable
@implements IObserver<BwAppMessage>

<!-- Note that @Body and other body content will be provided by specialized layouts inheriting from this BaseLayout -->
@code {
    // ============================================================================
    // LAYOUT SUBSCRIPTION ARCHITECTURE
    // ============================================================================
    // BaseLayout subscribes to AppCache and handles app-wide concerns:
    //   - Auth state changes (navigate to UnlockPage when session expires)
    //   - User activity detection (start/stop based on session state)
    //   - Pending BW requests (route to appropriate handler page)
    //
    // Derived layouts (MainLayout, DialogLayout):
    //   - Inherit subscription from BaseLayout
    //   - Override HandleAppCacheChanged for layout-specific logic
    //   - MUST call base.HandleAppCacheChanged() which calls StateHasChanged
    //   - MUST NOT call StateHasChanged again (it's already called by base)
    //
    // Pages inside layouts:
    //   - May also subscribe to ensure they receive StateHasChanged directly
    //   - Layout's StateHasChanged doesn't always re-render child pages in Blazor
    //   - See AppCache.cs documentation for subscription patterns
    // ============================================================================

    protected Timer? appBarRefreshTimer;
    protected bool isTimeoutHovered = false;
    private IDisposable? _portEventSubscription;
    private Timer? _wakeCheckTimer;

    /// <summary>
    /// Indicates whether the App is connected to the BackgroundWorker via port.
    /// When false, RPC calls will fail and the UI should show a disconnected indicator.
    /// </summary>
    protected bool IsPortConnected => appBwPortService.IsConnected;

    // Session timeout properties - available to all layouts
    protected TimeSpan SessionDurationRemaining => appCache.MyPasscodeModel.SessionExpirationUtc - DateTime.UtcNow;
    protected int SessionDurationRemainingSeconds => (int)SessionDurationRemaining.TotalSeconds + 1; // round up for display
    protected int SessionPercentageRemaining => (int)((SessionDurationRemaining.TotalSeconds / AppConfig.DisplaySessionExpirationAtSecondsRemaining) * 100);

    // When session is unlocked and about to expire, provide countdown tuple for display
    protected (bool IsShown, string Text, string Style) TimeoutText => (
            appCache.IsAuthenticated &&
            (int)SessionDurationRemaining.TotalSeconds < AppConfig.DisplaySessionExpirationAtSecondsRemaining &&
            (int)SessionDurationRemaining.TotalSeconds > 0)
            ? (true, $"Timeout in {SessionDurationRemaining.Seconds:D}", "color:var(--mud-palette-warning);")
            : (false, "", "color:var(--mud-palette-warning);");

    // Tooltip showing the time remaining
    protected string TimeoutTooltip => appCache.IsAuthenticated
        ? $"{SessionDurationRemaining.Minutes:D}:{SessionDurationRemaining.Seconds:D2}"
        : "Locked";

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        await appCache.Initialize();
        await AssertHydratedCache();

        await this.SubscribeToAppCache(appCache, HandleAppCacheChanged);

        CreateAppBarRefreshTimer();

        // Start user activity detection if session is unlocked
        if (appCache.IsSessionUnlocked)
        {
            await userActivityService.StartListeningAsync();
        }

        // Subscribe to port events from BackgroundWorker (e.g., SystemLockDetected)
        _portEventSubscription = appBwPortService.Subscribe(this);

        // Subscribe to port disconnection to update UI when BW connection is lost
        appBwPortService.Disconnected += OnPortDisconnected;
    }

    /// <summary>
    /// Called when the port connection to BackgroundWorker is lost.
    /// Starts polling for SW_APP_WAKE signal so the App can reconnect
    /// when BW has pending work.
    /// </summary>
    private void OnPortDisconnected(object? sender, EventArgs e)
    {
        logger.LogInformation("Port disconnected from BackgroundWorker, starting wake signal poll");
        StartWakeCheckTimer();
        InvokeAsync(StateHasChanged);
    }

    private void StartWakeCheckTimer()
    {
        _wakeCheckTimer?.Dispose();
        _wakeCheckTimer = new Timer(
            async _ =>
            {
                try
                {
                    await appBwPortService.CheckForWakeSignalAsync();
                    if (appBwPortService.IsConnected)
                    {
                        logger.LogInformation("Reconnected after SW_APP_WAKE, stopping wake poll");
                        StopWakeCheckTimer();
                        await InvokeAsync(StateHasChanged);
                    }
                }
                catch (Exception ex)
                {
                    logger.LogDebug(ex, "Wake signal check failed");
                }
            },
            state: null,
            dueTime: TimeSpan.FromSeconds(2),
            period: TimeSpan.FromSeconds(2));
    }

    private void StopWakeCheckTimer()
    {
        _wakeCheckTimer?.Dispose();
        _wakeCheckTimer = null;
    }

    protected virtual async Task HandleAppCacheChanged()
    {
        logger.LogInformation("HandleAppCacheChanged invoked");
        // Note: AssertHydratedCache is called in OnInitializedAsync, not here.
        // By the time HandleAppCacheChanged fires, AppCache is already initialized and receiving storage updates.

        // If we're on a page that requires auth (unlocked), and we're no longer authenticated, navigate to IndexPage for redirection, e.g. to UnlockPage
        if (!appCache.IsAuthenticated)
        {
            if (Routes.PathRequiresAuth("/" + navManager.ToBaseRelativePath(navManager.Uri)))
            {
                logger.LogInformation("HandleAppCacheChanged: Navigating to IndexPage since no longer authenticated");
                navManager.NavigateTo(Routes.PathFor<Extension.UI.Pages.Index>());
                return;
            }
        }

        // Start/stop user activity detection based on session state
        if (appCache.IsSessionUnlocked && !userActivityService.IsListening)
        {
            await userActivityService.StartListeningAsync();
        }
        else if (!appCache.IsSessionUnlocked && userActivityService.IsListening)
        {
            userActivityService.StopListening();
        }

        await HandleBwRequests();

        // IMPORTANT: StateHasChanged is called here. Derived layouts (MainLayout, DialogLayout)
        // should NOT call StateHasChanged again after calling base.HandleAppCacheChanged().
        StateHasChanged();
    }

    protected async Task HandleBwRequests()
    {
        // Navigate to Index (the routing hub) when there's a pending request that needs handling.
        // Index.razor's RedirectIfNeeded() centralizes all routing decisions, preventing race conditions
        // between multiple navigation sources (BaseLayout, ConnectingPage, etc.).

        // TODO P1: Handle active tab change for SidePanel. When user switches tabs while SidePanel shows
        // a tab-specific request (e.g., RequestSignInPage for Tab A), detect the tab change by subscribing
        // directly to chrome.tabs.onActivated via WebExtensions.Net and dismiss/update the UI that's no
        // longer relevant. This prevents showing stale request UI for a different tab.
        // See tmpMessagingArch.md Section 9 "Active tab change handling" for architecture details.

        if (!App.IsInSidePanel)
        {
            return;
        }

        if (!appCache.IsSessionUnlocked || !appCache.IsConnectedToKeria)
        {
            return;
        }

        var pendingRequest = appCache.NextPendingBwAppRequest;
        if (pendingRequest is null)
        {
            return;
        }

        // Don't navigate if already on a dialog page handling a request
        var currentPath = "/" + navManager.ToBaseRelativePath(navManager.Uri);
        if (Routes.IsDialogPage(currentPath))
        {
            return;
        }

        logger.LogInformation("HandleBwRequests: Navigating to Index for routing, pendingRequest Type={type}, RequestId={requestId}",
            pendingRequest.Type, pendingRequest.RequestId);
        navManager.NavigateTo(Routes.PathFor<Extension.UI.Pages.Index>());
    }

    protected async Task RefreshConnect()
    {
        // Force refresh connection to KERIA and fetch identifier state again, etc.
        // TODO P2 RefreshConnect not yet implemented
        snackbar.Add("Refreshing KERIA connection... not implemented", Severity.Warning);
        logger.LogWarning("RefreshConnect not yet implemented");
    }

    private async Task AssertHydratedCache()
    {
        // Ensure that AppCache is fully initialized before proceeding
        // helping assure critical records are loaded (and usually stored) before UI interaction
        bool isAppCacheReady;
        isAppCacheReady = await appCache.WaitForAppCache([() => appCache.MyPreferences.IsStored], 10000, 100);
        isAppCacheReady = await appCache.WaitForAppCache([() => appCache.MyOnboardState.IsStored], 10000, 100);
        if (!isAppCacheReady)
        {
            logger.LogError("AssertHydratedCache: AppCache not ready after waiting.");
            snackbar.Add("Application error: AppCache not ready.", Severity.Error);
            // TODO P2: alternatively, throw or navigate to an error page or take other actions
        }
    }

    protected void CreateAppBarRefreshTimer()
    {
        appBarRefreshTimer = new Timer(
            callback: (_) =>
            {
                // Periodically trigger a UI update of layout components only when helpful and necessary,
                // such as showing a timeout countdown when session is about to expire.
                // Note: the actual session expiration handling is done elsewhere. Search for various places of storage.clear of session storage.
                if (appCache.IsSessionNotExpired &&
                    (appCache.MyPasscodeModel.SessionExpirationUtc - DateTime.UtcNow).Seconds < AppConfig.DisplaySessionExpirationAtSecondsRemaining)
                {
                    InvokeAsync(StateHasChanged);
                }
            },
            state: null,
            dueTime: TimeSpan.FromSeconds(20), // TODO P2 calculated, but don't interfere with initialization time
            period: TimeSpan.FromSeconds(1));
    }

    public virtual async ValueTask DisposeAsync()
    {
        this.UnsubscribeFromAppCache();
        _portEventSubscription?.Dispose();
        appBwPortService.Disconnected -= OnPortDisconnected;
        appBarRefreshTimer?.Dispose();
        StopWakeCheckTimer();
        userActivityService.StopListening();
        GC.SuppressFinalize(this);
    }

    #region IObserver<BwAppMessage> Implementation

    /// <summary>
    /// Called when BackgroundWorker sends an event via port.
    /// Handles system-wide events like lock notifications.
    /// </summary>
    public void OnNext(BwAppMessage message)
    {
        logger.LogDebug("BaseLayout received BwAppMessage: type={Type}", message.Type);

        switch (message.Type)
        {
            case BwAppMessageType.Values.SystemLockDetected:
                logger.LogInformation("System lock detected event received - session will be locked");
                // The actual session lock is handled by BackgroundWorker clearing the session storage.
                // AppCache will detect the storage change and HandleAppCacheChanged will navigate to unlock page.
                // This event provides immediate notification for any additional UI feedback if needed.
                InvokeAsync(() =>
                {
                    snackbar.Add("Session locked due to system lock", Severity.Info);
                    StateHasChanged();
                });
                break;

            case BwAppMessageType.Values.LockApp:
                logger.LogInformation("LockApp event received");
                // Same handling as SystemLockDetected
                InvokeAsync(StateHasChanged);
                break;

            default:
                logger.LogDebug("Unhandled BwAppMessage type: {Type}", message.Type);
                break;
        }
    }

    public void OnError(Exception error)
    {
        logger.LogError(error, "Error in port event subscription");
    }

    public void OnCompleted()
    {
        logger.LogDebug("Port event subscription completed");
    }

    #endregion
}
