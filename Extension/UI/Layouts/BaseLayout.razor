@inherits LayoutComponentBase
@using Extension.Models.Messages.BwApp
@using Extension.Services.Storage
@using System.Reactive.Linq

@inject HttpClient http
@inject IJSRuntime js
@inject NavigationManager navManager
@inject IStorageService storageService
@inject ISnackbar snackbar
@inject ILogger<BaseLayout> logger
@inject ISignifyClientService signifyClientService
@inject AppCache appCache  // Reactive: subscribes in OnInitializedAsync via SubscribeToAppCache()
@inject IUserActivityService userActivityService

@implements IAsyncDisposable

<!-- Note that @Body and other body content will be provided by specialized layouts inheriting from this BaseLayout -->
@code {
    protected Timer? appBarRefreshTimer;

    // Session timeout properties - available to all layouts
    protected TimeSpan SessionDurationRemaining => appCache.MyPasscodeModel.SessionExpirationUtc - DateTime.UtcNow;

    // When session is unlocked and about to expire, provide countdown Text that alternates between two color Styles
    protected (string Text, string Style) TimeoutText => (
            appCache.IsAuthenticated &&
            (int)SessionDurationRemaining.TotalSeconds < AppConfig.DisplaySessionExpirationAtSecondsRemaining &&
            (int)SessionDurationRemaining.TotalSeconds > 1)
            ? (DateTime.UtcNow.Second % 2) == 0 ? ($"Timeout in {SessionDurationRemaining.Seconds:D}", "color:var(--mud-palette-warning);")
              : ($"Timeout in {SessionDurationRemaining.Seconds:D}", "color:var(--mud-palette-warning);") // "color:var(--mud-palette-primary);")
            : ("", "color:var(--mud-palette-warning);");

    // Tooltip showing the time remaining
    protected string TimeoutTooltip => appCache.IsAuthenticated
        ? $"Timeout in {SessionDurationRemaining.Minutes:D}:{SessionDurationRemaining.Seconds:D}"
        : "Locked";

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        await appCache.Initialize();
        await AssertHydratedCache();

        await this.SubscribeToAppCache(appCache, HandleAppCacheChanged);

        CreateAppBarRefreshTimer();

        // Start user activity detection if session is unlocked
        if (appCache.IsSessionUnlocked)
        {
            await userActivityService.StartListeningAsync();
        }
    }

    protected virtual async Task HandleAppCacheChanged()
    {
        logger.LogInformation("HandleAppCacheChanged invoked");
        await AssertHydratedCache();
        // If we're on a page that requires auth (unlocked), and we're no longer authenticated, navigate to IndexPage for redirection, e.g. to UnlockPage
        if (!appCache.IsAuthenticated)
        {
            if (!(AppConfig.PagesNotRequiringAuth.Contains("/" + navManager.ToBaseRelativePath(navManager.Uri))))
            {
                logger.LogInformation("HandleAppCacheChanged: Navigating to IndexPage since no longer authenticated");
                navManager.NavigateTo(AppConfig.RouteToIndex);
                return;
            }
        }

        // Start/stop user activity detection based on session state
        if (appCache.IsSessionUnlocked && !userActivityService.IsListening)
        {
            await userActivityService.StartListeningAsync();
        }
        else if (!appCache.IsSessionUnlocked && userActivityService.IsListening)
        {
            userActivityService.StopListening();
        }

        await HandleBwRequests();
        StateHasChanged();
    }

    protected virtual async Task HandleBwRequests() { }

    private async Task AssertHydratedCache()
    {
        // Ensure that AppCache is fully initialized before proceeding
        // helping assure critical records are loaded (and usually stored) before UI interaction

        var isAppCacheReady = await appCache.WaitForAppCache([
            // () => appCache.IsInitialized,
            () => appCache.MyPreferences.IsStored,
            () => appCache.MyOnboardState.IsStored,
            () => appCache.MyKeriaConnectConfig.IsStored,
            // () => appCache.MyKeriaConnectionInfo is not null,
            // () => appCache.MyPasscodeModel is not null
        ], 5000, 100);
        // TODO P2: Make timeout duration configurable?
        if (!isAppCacheReady)
        {
            logger.LogError("BaseLayout OnInitializedAsync: AppCache not ready after waiting.");
            snackbar.Add("Application error: AppCache not ready.", Severity.Error);
            // Optionally, throw or navigate to an error page or take other actions
        }
    }

    protected void CreateAppBarRefreshTimer()
    {
        appBarRefreshTimer = new Timer(
            callback: (_) =>
            {
                // Periodically trigger a UI update of layout components only when helpful and necessary,
                // such as showing a timeout countdown when session is about to expire.
                // Note: the actual session expiration handling is done elsewhere. Search for various places of storage.clear of session storage.
                if (appCache.IsSessionNotExpired &&
                    (appCache.MyPasscodeModel.SessionExpirationUtc - DateTime.UtcNow).Seconds < AppConfig.DisplaySessionExpirationAtSecondsRemaining)
                {
                    // logger.LogInformation("RestartOrExtendAppBarUpdateTime");
                    InvokeAsync(StateHasChanged);
                }
            },
            state: null,
            dueTime: TimeSpan.FromSeconds(20), // TODO P2 calculated, but don't interfere with initialization time
            period: TimeSpan.FromSeconds(1));
    }

    public virtual async ValueTask DisposeAsync()
    {
        this.UnsubscribeFromAppCache();
        appBarRefreshTimer?.Dispose();
        userActivityService.StopListening();
        GC.SuppressFinalize(this);
    }
}
