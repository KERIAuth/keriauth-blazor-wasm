@page "/RequestSignHeaders.html/{encodedOrigin}"
@layout Layouts.DialogLayout
@using Extension.Services.Storage


@using System.Linq
@using System.Text.Json
@using Extension.Helper
@using Extension.Layouts
@using Extension.Models
@using Extension.Models.Messages.AppBw
@using Extension.Components
@using Extension.Pages
@using Extension.Services
@using Extension.Services.SignifyService
@using Extension.Services.SignifyService.Models
@using static Extension.AppConfig
@using System.Diagnostics
@using Microsoft.AspNetCore.WebUtilities
@using MudBlazor
@using FluentResults
@using System.Web
@using System.Text.Json.Serialization
@using System;
@using System.Collections.Generic;
@using JsBind.Net
@using WebExtensions.Net

@implements IDisposable

@inject IStorageService storageService
@inject NavigationManager navManager
@using static Extension.Helper.PreviousPage
@inject ILogger<RequestSignHeadersPage> logger
@inject ISignifyClientService signifyClientService
@inject IDialogService dialogService
@inject ISnackbar snackbar
@inject IWebsiteConfigService websiteConfigService
@inject IStorageService storageService
@inject IAppBwMessagingService appBwMessagingService
@inject IJSRuntime jsRuntime
@inject IJSRuntime js
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject ISnackbar snackbar

@code {
    // TODO P2 why not expand this encodedOrigin to be a base64 encoded typed object with everything needed?
    [Parameter] public string encodedOrigin { get; set; } = "";
    [CascadingParameter] public DialogLayout? Layout { get; set; }

    // fields
    private MudButton? signRequestButton;

    static readonly HashSet<string> SafeMethods = new(StringComparer.OrdinalIgnoreCase)
    {
        "GET",
        "HEAD",
        "OPTIONS"
    };

    // properties
    string RequestId { get; set; } = "";
    int TabId { get; set; } = -1;
    string PayloadJson { get; set; } = "";
    Dictionary<string, string> HeadersDict { get; set; } = new();
    bool IsDetailShown { get; set; }
    bool IsInitialized { get; set; }
    bool IsExpanded { get; set; }
    string AppActivePrefix { get; set; } = string.Empty;
    enum SignInMode { Credential, Identifier, Prompt }
    Preferences? Prefs { get; set; }
    WebsiteConfig? ThisWebsiteConfig { get; set; }
    List<RecursiveDictionary> credentials = new();
    SignInMode RequestedSignInMode { get; set; } = SignInMode.Prompt;
    string WebsiteConfiguredPrefix { get; set; } = "unknown";
    List<Aid>? Identifiers { get; set; }

    // reactive properties
    string OriginStr => HttpUtility.UrlDecode(encodedOrigin).Trim().Trim('"');
    string AuthorityStr => (new Uri(OriginStr)).Authority;
    public bool HasSafeHttpRequestMethod => HeadersDict.Any(header =>
       string.Equals(header.Key, "method", StringComparison.OrdinalIgnoreCase) &&
       SafeMethods.Contains(header.Value));
    bool IsAutoSignIn => ThisWebsiteConfig?.IsAutoSignInCredential ?? false;
    bool IsAutoSignSafeHeaders => ThisWebsiteConfig?.IsAutoSignSafeHeaders ?? true;
    string ExpandIcon => IsExpanded ? Icons.Material.Filled.ExpandLess : Icons.Material.Filled.ExpandMore;
    string WebsiteConfiguredAlias => Identifiers?.Find(x => x.Prefix == WebsiteConfiguredPrefix)?.Name ?? "not configured";

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation($"OnInitialized");
        await RefreshFromWebsiteConfig();
        var prefsResult = await storageService.GetItem<Preferences>(StorageArea.Local);
        Prefs = prefsResult.IsSuccess && prefsResult.Value is not null ? prefsResult.Value : new Preferences();
        IsDetailShown = Prefs.ShowSignRequestDetail;
        IsInitialized = true;
        return;
    }

    protected override async Task OnParametersSetAsync()
    {
        logger.LogInformation($"OnParametersSetAsync");
        var prefsResult = await storageService.GetItem<Preferences>(StorageArea.Local);
        var prefs = prefsResult.IsSuccess && prefsResult.Value is not null ? prefsResult.Value : new Preferences();
        InitializeOrOnNextPrefs(prefs);

        logger.LogInformation("OnParametersSetAsync requestId {r}", RequestId);

        await getInitialIdentifiers();

        // TODO P1 instead use webExtensionsApi.Runtime.GetContexts
        // remove temporary code below for exploration.  Will be useful when requested to sign a specific request, such as issuing a credential
        string initialUriQuery = "TODO_not_set";
        // var initialUriQuery = extensionEnvironmentService.InitialUriQuery;
        logger.LogInformation($"URI query: {initialUriQuery}");

        // Extract tabId from query string
        if (QueryHelpers.ParseQuery(initialUriQuery).TryGetValue("tabId", out var tabIdStr))
        {
            if (int.TryParse(tabIdStr, out var parsedTabId))
            {
                TabId = parsedTabId;
                logger.LogInformation("TabId from query string: {tabId}", TabId);
            }
        }

        // TODO P1 should be a well-defined typed object instead of a double-encoded JSON string. Could base64 encode it.
        // TODO P2 add try-catch
        // TODO P2 decide whether these values (RequestId, Type, and others) should come in page parameters, initialUriQuery, or database/service.
        if (QueryHelpers.ParseQuery(initialUriQuery).TryGetValue("message", out var outterMessage))
        {
            var decodedMsg = HttpUtility.UrlDecode(outterMessage);
            logger.LogInformation("Chrome URI query message decoded: {msg}", decodedMsg);
            var decodedMsg2 = HttpUtility.UrlDecode(decodedMsg);
            logger.LogInformation("Chrome URI query message decoded2: {msg}", decodedMsg2);

            if (!IsJsonValid(decodedMsg2))
            {
                logger.LogError("Chrome URI query Invalid JSON message: {msg}", decodedMsg2);
                return;
            }
            ;

            string jsonString = decodedMsg2.ToString(); // Convert StringValues to string

            // Parse the JSON string
            // TODO P2 write exception handling around the following
            JsonDocument jsonDocument = JsonDocument.Parse(jsonString);
            JsonElement payload = jsonDocument.RootElement.GetProperty("payload");
            PayloadJson = payload.ToString();
            HeadersDict = JsonSerializer.Deserialize<Dictionary<string, string>>(payload) ?? new Dictionary<string, string>();

            JsonElement requestId = jsonDocument.RootElement.GetProperty("requestId");
            RequestId = requestId.ToString();

            if (IsAutoSignSafeHeaders && HasSafeHttpRequestMethod)
            {
                // TODO P2: Move this logic into BackgroundWorker.cs, to avoid calling this page altogether.  Get identifier name from SelectedPrefix instead of fetching all identifiers
                // await SignRequest(RequestedSignInMode, RequestId, null, PayloadJson);

                // var message = new AppBwReplySignMessage(TabId, RequestId, Prefix);
                // await appBwMessagingService.SendToBackgroundWorkerAsync(message);


                // TODO P2 notify the user signing is happening, and close?
            }
            return;
        }
        else
        {
            logger.LogError("Could not find UriQuery content containing outter \"message\".");
            return;
        }
    }

        private async Task getInitialIdentifiers()
    {
        // _logger.LogWarning("GetInitialIdentifiers() ...");
        var res = await signifyClientService.GetIdentifiers();
        if (res?.IsSuccess == true && res.Value?.Aids is not null)
        {
            Identifiers = res.Value.Aids.OrderBy(a => a.Name).ToList();
        }
        else
        {
            throw new Exception("unexpected null identifiers");
        }
        // StateHasChanged(); // TODO needed?
        // _logger.LogWarning("GetInitialIdentifiers() done count: {c}", Identifiers?.Count());
    }

    //
    //
    //
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && signRequestButton is not null)
        {
            await signRequestButton.FocusAsync();
        }
    }

    //
    //
    //
    Uri? GetOriginUri()
    {
        try
        {
            var uri = new Uri(OriginStr);
            return uri;
        }
        catch (Exception ex)
        {
            logger.LogError("GetOriginUri: Error parsing OriginStr '{o}': {e}", OriginStr, ex);
            return null;
        }
    }

    //
    //
    //
    async Task SetIsDetailShown(bool isDetailShown)
    {
        IsDetailShown = isDetailShown;
        var prefsResult = await storageService.GetItem<Preferences>(StorageArea.Local);
        var prefs = prefsResult.IsSuccess && prefsResult.Value is not null ? prefsResult.Value : new Preferences();
        // TODO P3 ShowSignRequestDetail should be per website?, since not every site should be trusted the same
        Prefs = prefs with { ShowSignRequestDetail = isDetailShown };
        await storageService.SetItem<Preferences>(Prefs, StorageArea.Local);
        return;
    }

    //
    //
    //
    void InitializeOrOnNextPrefs(Preferences prefs)
    {
        AppActivePrefix = prefs.SelectedPrefix;
        this.StateHasChanged();
    }

    //
    //
    //
    async Task updateIsAutoSignSafeHeaders(bool isChecked)
    {
        // _logger.LogWarning("updateIsAutoSignHeaders: isChecked: {b} WebsiteConfig: {w}", isChecked, ThisWebsiteConfig);
        if (ThisWebsiteConfig is not null && ThisWebsiteConfig.IsAutoSignSafeHeaders != isChecked)
        {
            ThisWebsiteConfig = ThisWebsiteConfig with { IsAutoSignSafeHeaders = isChecked };
            await websiteConfigService.Update(ThisWebsiteConfig);
        }
        StateHasChanged();
    }

    //
    //
    //
    // TODO P2 DRY with similar method in WebsiteConfigDisplay
    async Task RefreshFromWebsiteConfig()
    {
        var originUri = GetOriginUri();
        if (originUri is null)
        {
            throw new Exception($"RefreshThisWebsiteConfig: origin must be set.");
        }

        var getOrCreateWebsiteRes = await websiteConfigService.GetOrCreateWebsiteConfig(originUri);
        if (getOrCreateWebsiteRes.IsFailed)
        {
            throw new Exception($"Error from websiteService {getOrCreateWebsiteRes.Errors}");
        }
        var (websiteConfig, isConfigNew) = getOrCreateWebsiteRes.Value;
        ThisWebsiteConfig = websiteConfig;

        if (isConfigNew)
        {
            var prefsResult = await storageService.GetItem<Preferences>(StorageArea.Local);
            WebsiteConfiguredPrefix = prefsResult.IsSuccess && prefsResult.Value is not null
                ? prefsResult.Value.SelectedPrefix
                : new Preferences().SelectedPrefix;
            ThisWebsiteConfig = ThisWebsiteConfig with { RememberedPrefixOrNothing = WebsiteConfiguredPrefix };
            await websiteConfigService.Update(ThisWebsiteConfig);
        }
        else
        {
            WebsiteConfiguredPrefix = ThisWebsiteConfig.RememberedPrefixOrNothing!;
        }
        StateHasChanged();
    }

    //
    //
    //
    // 
    async Task Cancel()
    {
        var message = new AppBwReplyCanceledMessage(TabId, OriginStr, RequestId, "User cancelled sign request");
        await appBwMessagingService.SendToBackgroundWorkerAsync(message);
        if (Layout is not null)
        {
            await Layout.ClosePopupAsync();
        }
        // unreachable
        return;
    }

    //
    //
    //
    public void Dispose()
    {
        // TODO P4 unsubscribe from services, observables
    }

    //
    //
    //
    // TODO P4 remove or create helper?
    static bool IsJsonValid(string jsonString)
    {
        try
        {
            // Attempt to parse the JSON string
            var jsonDocument = JsonDocument.Parse(jsonString);
            return true;
        }
        catch (JsonException ex)
        {
            // JSON parsing failed, likely due to improper escaping or formatting
            Console.WriteLine($"JSON Parsing Error: {ex.Message}");
            return false;
        }
    }

    //
    //
    //
    void ToggleExpand()
    {
        IsExpanded = !IsExpanded;
    }

    //
    //
    //
    private async Task ApproveRequestHandler()
    {
        var message = new AppBwReplySignMessage(TabId, OriginStr, RequestId, HeadersDict, WebsiteConfiguredPrefix, true);
        await appBwMessagingService.SendToBackgroundWorkerAsync(message);
        if (Layout is not null)
        {
            await Layout.ClosePopupAsync();
        }
        // unreachable
       return;
    }
    
    //
    //
    //
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" || e.Code == "NumpadEnter")
        {
            await ApproveRequestHandler();
        }
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    <MudStack Class="bt-main">
        <div class="bt-main-inside-scroll">
            <MudText Typo="Typo.h6">Request to Sign HTTP Request Headers</MudText>
            <MudText class="mt-6" Typo="Typo.body1">
                The website <b>@AuthorityStr</b> is requesting KERI Auth, with your approval,
                to cryptographically sign HTTP Request Headers with the key material of the identifier you selected for this site when you signed in to it.
                The resulting signature and other headers will then allow the server for the requested url to validate and authorize the request.
            </MudText>

            <MudText><b>Signing Identifier</b></MudText>
            <MudStack Row Class="pl-1" Style="align-items:center;">
                <MudIcon Icon=@Helper.Identicon.MakeIdenticon(WebsiteConfiguredPrefix) ViewBox="0 0 100 100" Style="border-style:solid; border-color:black; border-width:2px; border-radius:50%; width:35px; height:35px; overflow:hidden; margin-top: 3px;" />
                <MudText>@WebsiteConfiguredAlias</MudText>
            </MudStack>

            @if (IsInitialized && HeadersDict is not null && HeadersDict.Any()) // prevent distracting progressive loading
            {
                <MudStack Row>
                <MudCheckBox Label="Show Input Headers" Value="IsDetailShown" ValueChanged="async (bool b) => await SetIsDetailShown(b)" Style="padding-left:0;"></MudCheckBox>
                </MudStack>
                @if (IsDetailShown)
                {
                    <MudPaper>
                        <table class="non-responsive-table">
                            <thead style="text-align:left;">
                                <tr>
                                    <th class="content-width-col">Key</th>
                                    <th class="remaining-width-col">Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var item in HeadersDict)
                                {
                                    <tr>
                                        <td class="content-width-col">@item.Key</td>
                                        <td class="remaining-width-col">@item.Value</td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </MudPaper>
                }
                <!-- The following mayb be display:none; -->
                <MudCheckBox Label="Auto-sign Http Request Headers that have no side effects" Value="IsAutoSignSafeHeaders" ValueChanged="async (bool b) => await updateIsAutoSignSafeHeaders(b)" Style="padding-left:0; height: 28px;" />
            }
        </div>
    </MudStack>
    <MudStack Row="true" class="bt-button-tray">
        <MudSpacer />
        <MudButton StartIcon="@Icons.Material.Filled.Cancel" Variant="Variant.Filled" Color="Color.Tertiary" @onclick="Cancel">Reject</MudButton>
        <MudButton @ref="signRequestButton"
                   StartIcon="@Icons.Material.Filled.Login"
                   Variant="Variant.Filled"
                   Color="Color.Primary"
                   OnClick="ApproveRequestHandler"
                   @onkeydown="HandleKeyDown">
            Approve & Sign
        </MudButton>
    </MudStack>
</div>

<style>
    .mud-select .mud-select-input .mud-input-slot {
        height: auto;
    }

    .selected-item {
        border-left: 4px solid blue;
    }

    .content-width-col {
        width: 1%;
        white-space: nowrap;
    }

    .remaining-width-col {
        word-break: break-all;
        text-overflow: unset;
        word-wrap: anywhere;
        width: auto;
        white-space: unset !important;
    }

    .non-responsive-table {
        table-layout: fixed;
        border-collapse: collapse;
        text-align: left;
        vertical-align: baseline;
    }

        .non-responsive-table th,
        .non-responsive-table td {
            border: 1px solid #ddd;
            padding: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            vertical-align: baseline;
        }

        .non-responsive-table th {
            font-weight: bold;
        }
</style>
