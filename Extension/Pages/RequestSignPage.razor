@page "/RequestSign.html/{encodedOrigin}"
@layout Layouts.DialogLayout

@using System.Linq
@using System.Text.Json
@using Extension.Helper
@using Extension.Models
@using Extension.Models.AppBwMessages
@using Extension.Components
@using Extension.Pages
@using Extension.Services
@using Extension.Services.SignifyService
@using Extension.Services.SignifyService.Models
@using static Extension.AppConfig
@using System.Diagnostics
@using Microsoft.AspNetCore.WebUtilities
@using MudBlazor
@using FluentResults
@using System.Web
@using System.Text.Json.Serialization
@using System;
@using System.Collections.Generic;
@using JsBind.Net
@using WebExtensions.Net

@implements IDisposable

@inject IStorageService storageService
@inject IStateService stateService
@inject NavigationManager navManager
@using static Extension.Helper.PreviousPage
@inject ILogger<RequestSignPage> logger
@inject ISignifyClientService signifyClientService
@inject IDialogService dialogService
@inject ISnackbar snackbar
@inject IWebsiteConfigService websiteConfigService
@inject IStorageService storageService
@inject IPreferencesService preferencesService
@inject IExtensionEnvironmentService extensionEnvironmentService
@inject IAppBwMessagingService appBwMessagingService
@inject IJSRuntime jsRuntime
@inject IJSRuntime js
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject ISnackbar snackbar

@code {
    [Parameter]
    public string encodedOrigin { get; set; } = "";

    // fields
    private MudButton? signRequestButton;
    static readonly HashSet<string> SafeMethods = new(StringComparer.OrdinalIgnoreCase)
    {
        "GET",
        "HEAD",
        "OPTIONS"
    };

    // properties
    string RequestId { get; set; } = "";
    int TabId { get; set; } = -1;
    string PayloadJson { get; set; } = "";
    Dictionary<string, string> HeadersDict { get; set; } = new();
    RecursiveDictionary? SelectedCredential;
    bool IsDetailShown { get; set; }
    bool IsInitialized { get; set; }
    bool IsExpanded { get; set; }
    string AppActivePrefix { get; set; } = string.Empty;
    enum SignInMode { Credential, Identifier, Prompt }
    Preferences? Prefs { get; set; }
    WebsiteConfig? ThisWebsiteConfig { get; set; }
    List<RecursiveDictionary> credentials = new();
    SignInMode RequestedSignInMode { get; set; } = SignInMode.Prompt;
    string SelectedPrefix { get; set; } = "unknown";

    // reactive properties
    string OriginStr => HttpUtility.UrlDecode(encodedOrigin).Trim().Trim('"');
    string AuthorityStr => (new Uri(OriginStr)).Authority;
    public bool HasSafeHttpRequestMethod => HeadersDict.Any(header =>
       string.Equals(header.Key, "method", StringComparison.OrdinalIgnoreCase) &&
       SafeMethods.Contains(header.Value));
    bool IsAutoSignIn => ThisWebsiteConfig?.IsAutoSignInCredential ?? false;
    bool IsAutoSignSafeHeaders => ThisWebsiteConfig?.IsAutoSignSafeHeaders ?? true;
    string ExpandIcon => IsExpanded ? Icons.Material.Filled.ExpandLess : Icons.Material.Filled.ExpandMore;

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation($"OnInitialized");
        await getCredentials();
        await RefreshFromWebsiteConfig();
        Prefs = await preferencesService.GetPreferences();
        IsDetailShown = Prefs.ShowSignRequestDetail;
        IsInitialized = true;
        return;
    }

    protected override async Task OnParametersSetAsync()
    {
        logger.LogInformation($"OnParametersSetAsync");
        InitializeOrOnNextPrefs(await preferencesService.GetPreferences());

        logger.LogInformation("OnParametersSetAsync requestId {r}", RequestId);

        // TODO P2 instead use webExtensionsApi.Runtime.GetContexts
        // remove temporary code below for exploration.  Will be useful when requested to sign a specific request, such as issuing a credential
        var initialUriQuery = extensionEnvironmentService.InitialUriQuery;
        logger.LogInformation($"URI query: {initialUriQuery}");

        // Extract tabId from query string
        if (QueryHelpers.ParseQuery(initialUriQuery).TryGetValue("tabId", out var tabIdStr))
        {
            if (int.TryParse(tabIdStr, out var parsedTabId))
            {
                TabId = parsedTabId;
                logger.LogInformation("TabId from query string: {tabId}", TabId);
            }
        }

        // TODO P2 add try-catch
        // TODO P2 decide whether these values (RequestId, Type, and others) should come in page parameters, initialUriQuery, or database/service.
        if (QueryHelpers.ParseQuery(initialUriQuery).TryGetValue("message", out var outterMessage))
        {
            var decodedMsg = HttpUtility.UrlDecode(outterMessage);
            logger.LogInformation("Chrome URI query message decoded: {msg}", decodedMsg);
            var decodedMsg2 = HttpUtility.UrlDecode(decodedMsg);
            logger.LogInformation("Chrome URI query message decoded2: {msg}", decodedMsg2);

            if (!IsJsonValid(decodedMsg2))
            {
                logger.LogError("Chrome URI query Invalid JSON message: {msg}", decodedMsg2);
                return;
            };

            string jsonString = decodedMsg2.ToString(); // Convert StringValues to string

            // Parse the JSON string
            // TODO P2 write exception handling around the following
            JsonDocument jsonDocument = JsonDocument.Parse(jsonString);
            JsonElement payload = jsonDocument.RootElement.GetProperty("payload");
            PayloadJson = payload.ToString();
            HeadersDict = JsonSerializer.Deserialize<Dictionary<string, string>>(payload) ?? new Dictionary<string, string>();

            JsonElement requestId = jsonDocument.RootElement.GetProperty("requestId");
            RequestId = requestId.ToString();

            if (IsAutoSignSafeHeaders && HasSafeHttpRequestMethod)
            {
                // TODO P1: Get identifier name from SelectedPrefix instead of fetching all identifiers
                await SignRequest(RequestedSignInMode, RequestId, null, PayloadJson);
                // TODO P2 notify the user signing is happening, and close?
            }
            return;
        }
        else
        {
            logger.LogError("Could not find UriQuery content containing outter \"message\".");
            return;
        }
    }

    //
    //
    //
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && signRequestButton is not null)
        {
            await signRequestButton.FocusAsync();
        }
    }

    //
    //
    //
    Uri? GetOriginUri()
    {
        try
        {
            var uri = new Uri(OriginStr);
            return uri;
        }
        catch (Exception ex)
        {
            logger.LogError("GetOriginUri: Error parsing OriginStr '{o}': {e}", OriginStr, ex);
            return null;
        }
    }

    //
    //
    //
    async Task SetIsDetailShown(bool isDetailShown)
    {
        IsDetailShown = isDetailShown;
        Preferences prefs = await preferencesService.GetPreferences();
        Prefs = prefs with { ShowSignRequestDetail = isDetailShown };
        await preferencesService.SetPreferences(Prefs);
        return;
    }

    //
    //
    //
    void InitializeOrOnNextPrefs(Preferences prefs)
    {
        AppActivePrefix = prefs.SelectedPrefix;
        this.StateHasChanged();
    }

    //
    //
    //
    async Task getCredentials()
    {
        var res = await signifyClientService.GetCredentials();
        if (res.IsFailed || res.Value is null)
        {
            logger.LogError($"Error: {res.Errors}");
            return;
        }
        else
        {
            credentials = res.Value;
            Debug.Assert(credentials is not null);
            logger.LogInformation("Credentials: count {res}", credentials.Count);
        }
    }

    //
    //
    //
    async Task updateIsAutoSignSafeHeaders(bool isChecked)
    {
        // logger.LogWarning("updateIsAutoSignHeaders: isChecked: {b} WebsiteConfig: {w}", isChecked, ThisWebsiteConfig);
        if (ThisWebsiteConfig is not null && ThisWebsiteConfig.IsAutoSignSafeHeaders != isChecked)
        {
            ThisWebsiteConfig = ThisWebsiteConfig with { IsAutoSignSafeHeaders = isChecked };
            await websiteConfigService.Update(ThisWebsiteConfig);
        }
        StateHasChanged();
    }

    //
    //
    //
    // TODO P2 DRY with similar method in WebsiteConfigDisplay
    async Task RefreshFromWebsiteConfig()
    {
        var originUri = GetOriginUri();
        if (originUri is null)
        {
            throw new Exception($"RefreshThisWebsiteConfig: origin must be set.");
        }

        var getOrCreateWebsiteRes = await websiteConfigService.GetOrCreateWebsiteConfig(originUri);
        if (getOrCreateWebsiteRes.IsFailed)
        {
            throw new Exception($"Error from websiteService {getOrCreateWebsiteRes.Errors}");
        }
        var (websiteConfig, isConfigNew) = getOrCreateWebsiteRes.Value;
        ThisWebsiteConfig = websiteConfig;

        if (isConfigNew)
        {
            SelectedPrefix = (await preferencesService.GetPreferences()).SelectedPrefix;
            ThisWebsiteConfig = ThisWebsiteConfig with { RememberedPrefixOrNothing = SelectedPrefix };
            await websiteConfigService.Update(ThisWebsiteConfig);
        }
        else
        {
            SelectedPrefix = ThisWebsiteConfig.RememberedPrefixOrNothing!;
        }

        StateHasChanged();
    }

    //
    // SignRequest()
    //
    async Task SignRequest(SignInMode RequestedSignInMode, string requestId2, string? SelectedName, string payloadJson)
    {
        logger.LogInformation("SignRequest: payloadJson: {d}", payloadJson);

        ApiRequest? request = JsonSerializer.Deserialize<ApiRequest>(payloadJson);
        if (request is null)
        {
            logger.LogError("SignRequest: Error: {0}", "Invalid payloadJson");
            return;
        }
        logger.LogInformation("SignRequest: request: {d}", request.ToString());

        // TODO P1: SelectedName parameter is currently unused by BackgroundWorker and signify-ts.
        // Either use it for signing (if signify-ts requires the name/alias instead of prefix),
        // or remove it entirely if SelectedPrefix is sufficient for signing operations.
        // For now, accepting null since the field is not actually used downstream.

        // prepare to create and send approved sign request to ServiceWorker, which will get signed headers from signify-ts and then to content script
        if (SelectedName is null)
        {
            var msg = "SelectedName must not be null here";
            snackbar.Add(msg, Severity.Error);
            logger.LogError(msg);
            StateHasChanged(); // needed?
            // await Task.Delay(8000);
            return;
        }

        // adminUrl
        var connectConfigRes = await storageService.GetItem<KeriaConnectConfig>();
        if (connectConfigRes.IsFailed || connectConfigRes.Value is null)
        {
            var msg = "Config must not be null here";
            logger.LogError(msg);
            snackbar.Add(msg, Severity.Error);
            // await Task.Delay(8000); 
            return;
        }
        var adminUrl = connectConfigRes.Value.AdminUrl;

        // Retrieve cached passcode
        var webExtensionsApi = new WebExtensionsApi(jsRuntimeAdapter);
        var passcodeElement = await webExtensionsApi!.Storage.Session.Get("passcode");
        if (passcodeElement.TryGetProperty("passcode", out JsonElement passcodeElement2) && passcodeElement2.ValueKind == JsonValueKind.String)
        {
            var passcode = passcodeElement2.GetString();

            if (!string.IsNullOrEmpty(passcode) && passcode.Length == 21)
            {
                if (TabId <= 0)
                {
                    var msg = "Invalid tab ID";
                    snackbar.Add(msg, Severity.Error);
                    logger.LogError(msg);
                    return;
                }

                if (string.IsNullOrEmpty(adminUrl))
                {
                    var msg = "Admin URL must not be null";
                    snackbar.Add(msg, Severity.Error);
                    logger.LogError(msg);
                    return;
                }

                if (request.HeadersDict == null)
                {
                    var msg = "Headers dictionary must not be null";
                    snackbar.Add(msg, Severity.Error);
                    logger.LogError(msg);
                    return;
                }

                var approvedSignRequest = new Extension.Models.AppBwMessages.ApprovedSignRequest(
                    Passcode: passcode,
                    AdminUrl: adminUrl,
                    Origin: OriginStr,
                    Url: request.Url,
                    Method: request.Method,
                    Headers: request.HeadersDict,
                    IdentifierName: SelectedName!
                );
                var message = new AppBwReplySignMessage(TabId, requestId2, approvedSignRequest);
                await appBwMessagingService.SendToBackgroundWorkerAsync(message);
            }
            else
            {
                var msg = "Passcode must not be null here";
                snackbar.Add(msg, Severity.Error);
                logger.LogError(msg);
                // await Task.Delay(8000);
                return;
            }
        }
    }

    //
    //
    //
    async Task Cancel()
    {
        if (TabId <= 0)
        {
            logger.LogWarning("Cannot cancel - invalid tab ID");
            return;
        }

        var message = new AppBwReplyCanceledMessage(TabId, RequestId, "User cancelled sign request");
        await appBwMessagingService.SendToBackgroundWorkerAsync(message);
    }

    //
    //
    //
    public void Dispose()
    {
        // TODO P4 unsubscribe from services, observables
        ;
    }

    //
    //
    //
    // TODO P4 remove or create helper?
    static bool IsJsonValid(string jsonString)
    {
        try
        {
            // Attempt to parse the JSON string
            var jsonDocument = JsonDocument.Parse(jsonString);
            return true;
        }
        catch (JsonException ex)
        {
            // JSON parsing failed, likely due to improper escaping or formatting
            Console.WriteLine($"JSON Parsing Error: {ex.Message}");
            return false;
        }
    }

    //
    //
    //
    void ToggleExpand()
    {
        IsExpanded = !IsExpanded;
    }

    //
    //
    //
    void SelectCredential(RecursiveDictionary item)
    {
        if (SelectedCredential == item)
        {
            IsExpanded = false;
        }
        else
        {
            SelectedCredential = item;
            IsExpanded = false;
        }
    }

    //
    //
    //
    string GetCredentialItemClass(RecursiveDictionary item)
    {
        return item == SelectedCredential ? "selected-item" : String.Empty;
    }

    //
    //
    //
    private async Task SignRequestHandler()
    {
        // TODO P1: Get identifier name from SelectedPrefix instead of fetching all identifiers
        await SignRequest(RequestedSignInMode, RequestId, null, PayloadJson);
    }

    //
    //
    //
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" || e.Code == "NumpadEnter")
        {
            await SignRequestHandler();
        }
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    <MudStack Class="bt-main">
        <div class="bt-main-inside-scroll">
            <MudText Typo="Typo.h6">Request to Sign</MudText>
            <MudText Typo="Typo.body1"><em>@AuthorityStr</em></MudText>
            <MudText class="mt-6" Typo="Typo.body1">
                This website authority is requesting KERI Auth, with your approval, to cryptographically sign an HTTP Request Header, which will then allow it to validate the credential you used earlier to sign in, then authorize actions.<br />
            </MudText>
            @if (IsInitialized && HeadersDict is not null && HeadersDict.Any()) // prevent distracting progressive loading
            {
                <MudCheckBox Label="Show Details" Value="IsDetailShown" ValueChanged="async (bool b) => await SetIsDetailShown(b)"></MudCheckBox>
                @if (IsDetailShown)
                {
                    <MudPaper>
                        <table class="non-responsive-table">
                            <thead style="text-align:left;">
                                <tr>
                                    <th class="content-width-col">Key</th>
                                    <th class="remaining-width-col">Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var item in HeadersDict)
                                {
                                    <tr>
                                        <td class="content-width-col">@item.Key</td>
                                        <td class="remaining-width-col">@item.Value</td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </MudPaper>
                }
                <!-- The following is display:none; -->
                <MudCheckBox Label="Auto-sign Http Request Headers that have no side effects" style="display:none; height: 28px;" Value="IsAutoSignSafeHeaders" ValueChanged="async (bool b) => await updateIsAutoSignSafeHeaders(b)" />
            }
        </div>
    </MudStack>
    <MudStack Row="true" class="bt-button-tray">
        <MudSpacer />
        <MudButton StartIcon="@Icons.Material.Filled.Cancel" Variant="Variant.Filled" Color="Color.Tertiary" @onclick="Cancel">Cancel</MudButton>
        <MudButton @ref="signRequestButton"
                   StartIcon="@Icons.Material.Filled.Login"
                   Variant="Variant.Filled"
                   Color="Color.Primary"
                   OnClick="SignRequestHandler"
                   @onkeydown="HandleKeyDown">
            Sign Request
        </MudButton>
    </MudStack>
</div>

<style>
    .mud-select .mud-select-input .mud-input-slot {
        height: auto;
    }

    .selected-item {
        border-left: 4px solid blue;
    }

    .content-width-col {
        width: 1%;
        white-space: nowrap;
    }

    .remaining-width-col {
        word-break: break-all;
        text-overflow: unset;
        word-wrap: anywhere;
        width: auto;
        white-space: unset !important;
    }

    .non-responsive-table {
        table-layout: fixed;
        border-collapse: collapse;
        text-align: left;
        vertical-align: baseline;
    }

        .non-responsive-table th,
        .non-responsive-table td {
            border: 1px solid #ddd;
            padding: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            vertical-align: baseline;
        }

        .non-responsive-table th {
            font-weight: bold;
        }
</style>
