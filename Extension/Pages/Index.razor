@page "/index.html"
@page "/IndexPage.html"
@using Extension.Models.Storage
@using Extension.Services.Storage
@using Extension.Components

@* IndexPage provides NavManager instance and others *@
@inherits IndexPage
@layout MainLayout

@using Extension.Layouts
@using Microsoft.AspNetCore.Components.WebAssembly.Hosting
@using static System.Net.WebRequestMethods
@using WebExtensions.Net.Manifest

@inject AppCache appCache
@inject IStorageService storageService
@inject ILogger<IndexPage> logger
@inject HttpClient http
@inject NavigationManager navManager
@inject IJSRuntime js
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject ISignifyClientService signifyClientService
@inject ISnackbar snackbar

@* Intentionally empty visible content (except from inherited IndexPage), to reduce flickering on changing pages. Uncomment to debug

    <MudContainer id="@this.GetType().Name" Class="bt-body-page" Style="background-color:red;">
        <MudText>Index.razor</MudText>
        <MudPaper Style="width:100vw; height: 90vh; background-color:transparent; align-items:center; justify-content: center; display:flex;">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
        </MudPaper>
    </MudContainer>
*@

@implements IDisposable
@code {
    // private bool IsLoading { get; set; } = true;
    private WebExtensionsApi? webExtensionsApi;
    // string? initialUriQuery;
    private static readonly KeriaConnectConfig defaultKeriaConnectConfig = new KeriaConnectConfig(AppConfig.LocalhostKeriaConnectAlias, AppConfig.LocalhostKeriaAdminUrl, AppConfig.LocalhostKeriaBootUrl, 0);
    // private KeriaConnectConfig? keriaConnectConfig;
    const string termsUrlPath = "content/terms.html";
    const string privacyUrlPath = "content/privacy.html";

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        // Subscribe to AppCache changes - will trigger NavigateIfNeeded when state updates
        await this.SubscribeToAppCache(appCache, HandleAppCacheChanged);

        // IsLoading = true;
        logger.LogInformation($"OnInitializedAsync Index.razor");

        webExtensionsApi = new WebExtensionsApi(jsRuntimeAdapter);
        // logger.LogInformation("OnInitializedAsync contexts: {c}", await webExtensionsApi.Runtime.GetContexts(new ContextFilter()));

        // Get and handle OnboardState
        var onboardState = appCache.MyOnboardState;

        // Get version info from Manifest file
        // TODO P2 Refactor some of this and similar in Mainlayout into App, and pass into Layouts or Pages needing this as parameters
        var manifestJsonElement = WebExtensions.Runtime.GetManifest();

        var CurrentVersion = "";
        if (manifestJsonElement.TryGetProperty("version", out JsonElement versionElement) && versionElement.ValueKind == JsonValueKind.String)
        {
            CurrentVersion = versionElement.ToString();
        }

        // TODO P2 Move some of this into Program or App, so it is not calculated often.
        // compute hashes of latest terms and privacy
        var termsMarkup = new MarkupString(await http.GetStringAsync(termsUrlPath));
        var privacyMarkup = new MarkupString(await http.GetStringAsync(privacyUrlPath));
        int termsHash = GetNumberFromHash.HashInt(termsMarkup.Value);
        int privacyHash = GetNumberFromHash.HashInt(privacyMarkup.Value);
        if (termsHash != AppConfig.ExpectedTermsHash)
        {
            logger.LogError($"termsHash {termsHash} does not match expected {AppConfig.ExpectedTermsHash}");
        }
        if (privacyHash != AppConfig.ExpectedPrivacyHash)
        {
            logger.LogError($"privacyHash {privacyHash} does not match expected {AppConfig.ExpectedPrivacyHash}");
        }

        // TODO P2: Determine whether there was an update e.g. via a push from Chrome Web Store. See BackgroundWorker.ts
        // for how the following is placed into storage
        // bool isUpdated = false;
        var updateDetailsRes = await storageService.GetItem<UpdateDetails>();
        if (updateDetailsRes.IsSuccess && updateDetailsRes.Value is not null)
        {
            // isUpdated = true;
        }

        // TODO P0
        await HandleAppCacheChanged();
        // logger.LogInformation($"OnInitializedAsync done");
    }


    /*
    protected override async Task OnParametersSetAsync()
    {
        }
    */

    /*
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            logger.LogInformation("OnAfterRenderAsync firstRender");
        }
    */

   // NavigateIfNeeded navigates to newUrl only if not already on that page. In a browser refresh, this may be a build-generated copy of index.html versus the routed path
   void NavigateIfNeeded(string newUrl)
    {
        // logger.LogWarning("navManager.Uri: {u}", navManager.Uri);
        if (navManager.Uri.Contains(newUrl))
        {
            logger.LogWarning("Already on page {p}, so not navigating.");
            return;
        }
        navManager.NavigateTo(newUrl);
        return;
    }

    // NavigateIfNeeded checks AppCache state and navigates to appropriate page if needed, assuring the app is always configured, initialized, unlocked, authenticated, connected, etc. in the necessary order
    async Task HandleAppCacheChanged()
    {
        logger.LogInformation("HandleAppCacheChanged");
        // logger.LogInformation("{x}", a.MyPreferences);
        // logger.LogInformation("{x}", a.MyOnboardState);
        // logger.LogInformation("{x}", a.MyKeriaConnectConfig);
        // logger.LogInformation("{x}", a.MyKeriaConnectionInfo);
        // logger.LogInformation("{x}", a.MyPasscodeModel);
        // logger.LogInformation("{x}", a.MySessionExpiration);

        if (!appCache.MyOnboardState.IsWelcomed)
        {
            NavigateIfNeeded(RouteToWelcome);
            return;
        }
        if (!appCache.IsInstallAcknowledged)
        {
            NavigateIfNeeded(RouteToNewRelease);
            return;
        }
        if (!appCache.IsTosAgreed)
        {
            NavigateIfNeeded(RouteToTerms);
            return;
        }
        if (!appCache.IsPrivacyAgreed)
        {
            NavigateIfNeeded(RouteToPrivacy);
            return;
        }
        // Passing above conditions must equate to IsProductOnboarded
        if (!appCache.IsProductOnboarded)
        {
            logger.LogError("HandleAppCacheChanged: Not ProductOnboarded");
            return;
        }
        if (!appCache.IsConfigured)
        {
            NavigateIfNeeded(RouteToConfigure);
            return;
        }
        // Passing the above conditions must equate to IsInitialized
        if (!appCache.IsInitialized)
        {
            logger.LogError("HandleAppCacheChanged: Not Initialized");
            return;
        }
        if (!appCache.IsUnlocked)
        {
            NavigateIfNeeded(RouteToUnlock);
            return;
        }
        if (!appCache.IsAuthenticated)
        {
            logger.LogError("HandleAppCacheChanged: Not Authenticated");
            return;
        }
        if (!appCache.IsIdentifierFetched)
        {
            NavigateIfNeeded(RouteToConnecting);
            return;
        }
        // Passing the above conditions must equate to IsConnectedToKeria
        if (!appCache.IsConnectedToKeria)
        {
            logger.LogError("HandleAppCacheChanged: Not ConnectedToKeria");
            return;
        }
        // TODO P1 should navigate here to Dashboard or important to leave other current page as is?  Check also for popup and sidepanel context
        logger.LogInformation("HandleAppCacheChanged: No re-route conditions detected.");
        NavigateIfNeeded(RouteToDashboard);
    }

    public void Dispose() {
        this.UnsubscribeFromAppCache();
        GC.SuppressFinalize(this);
    }
}
