@page "/index.html"
@page "/"
@using Extension.Models.Storage
@using Extension.Services.Storage


@inherits IndexPage
@layout MainLayout

@using Extension.Layouts
@using Microsoft.AspNetCore.Components.WebAssembly.Hosting
@using static System.Net.WebRequestMethods
@using WebExtensions.Net.Manifest

@inject AppCache a

@inject IPreferencesService preferencesService
@inject IStorageService storageService
@inject IStateService stateService
@inject IExtensionEnvironmentService extensionEnvironmentService
@inject ILogger<IndexPage> logger
@inject HttpClient http
@inject NavigationManager navManager
@inject IJSRuntime js
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject ISignifyClientService signifyClientService
@inject ISnackbar snackbar

    <MudContainer id="@this.GetType().Name" Class="bt-body-page" Style="background-color:red;">
        <MudText>Index.razor</MudText>
        <MudPaper Style="width:100vw; height: 90vh; background-color:transparent; align-items:center; justify-content: center; display:flex;">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
        </MudPaper>
    </MudContainer>

@code {
    // private bool IsLoading { get; set; } = true;
    private WebExtensionsApi? webExtensionsApi;
    // string? initialUriQuery;
    private static readonly KeriaConnectConfig defaultKeriaConnectConfig = new KeriaConnectConfig(AppConfig.LocalhostKeriaConnectAlias, AppConfig.LocalhostKeriaAdminUrl, AppConfig.LocalhostKeriaBootUrl, 0);
    // private KeriaConnectConfig? keriaConnectConfig;
    const string termsUrlPath = "content/terms.html";
    const string privacyUrlPath = "content/privacy.html";

    protected override async Task OnInitializedAsync()
    {
        // IsLoading = true;
        logger.LogInformation($"OnInitializedAsync");

        webExtensionsApi = new WebExtensionsApi(jsRuntimeAdapter);
        // logger.LogInformation("OnInitializedAsync contexts: {c}", await webExtensionsApi.Runtime.GetContexts(new ContextFilter()));

        // Get and handle OnboardState
        var res = await storageService.GetItem<OnboardState>();
        // logger.LogInformation("OnboardStateRes: {r}", res.Value);
        OnboardState? onboardState;
        if (res.IsFailed || res.Value is null)
        {
            onboardState = new OnboardState();
            await storageService.SetItem<OnboardState>(onboardState);
        }
        else
        {
            onboardState = res.Value;
        }

        // Get version info from Manifest file
        // TODO P2 Refactor some of this and similar in Mainlayout into App, and pass into Layouts or Pages needing this as parameters
        var manifestJsonElement = WebExtensions.Runtime.GetManifest();

        var CurrentVersion = "";
        if (manifestJsonElement.TryGetProperty("version", out JsonElement versionElement) && versionElement.ValueKind == JsonValueKind.String)
        {
            CurrentVersion = versionElement.ToString();
        }

        // TODO P2 Move some of this into Program or App, so it is not calculated often.
        // compute hashes of latest terms and privacy
        var termsMarkup = new MarkupString(await http.GetStringAsync(termsUrlPath));
        var privacyMarkup = new MarkupString(await http.GetStringAsync(privacyUrlPath));
        int termsHash = GetNumberFromHash.HashInt(termsMarkup.Value);
        int privacyHash = GetNumberFromHash.HashInt(privacyMarkup.Value);
        if (termsHash != AppConfig.ExpectedTermsHash)
        {
            logger.LogError($"termsHash {termsHash} does not match expected {AppConfig.ExpectedTermsHash}");
        }
        if (privacyHash != AppConfig.ExpectedPrivacyHash)
        {
            logger.LogError($"privacyHash {privacyHash} does not match expected {AppConfig.ExpectedPrivacyHash}");
        }

        // Determine whether there was an update e.g. via a push from Chrome Web Store. See BackgroundWorker.ts
        // for how the following is placed into storage
        // bool isUpdated = false;
        var updateDetailsRes = await storageService.GetItem<UpdateDetails>();
        if (updateDetailsRes.IsSuccess && updateDetailsRes.Value is not null)
        {
            // isUpdated = true;
        }

        /*
        // Handle (re-)onboarding conditions if needed
        if (!onboardState.ValidateOnboardingStatus().IsSuccess ||
        isUpdated ||
        onboardState.InstallVersionAcknowledged != CurrentVersion ||
        onboardState.TosAgreedHash != termsHash ||
        onboardState.PrivacyAgreedHash != privacyHash)
        {
            if (!onboardState.IsWelcomed)
            {
                navManager.NavigateTo(RouteToWelcome);
                return;
                }

            if (onboardState.InstallVersionAcknowledged != CurrentVersion || isUpdated)
            {
                navManager.NavigateTo(RouteToNewRelease);
                return;
                }

            if (onboardState.TosAgreedHash != termsHash)
            {
                navManager.NavigateTo(RouteToTerms);
                return;
                }

            if (onboardState.PrivacyAgreedHash != privacyHash)
            {
                navManager.NavigateTo(RouteToPrivacy);
                return;
                }
            }

        // More onboarding if needed...
        // Get KERIA configuration and if needed route to page for user to configure it
        var configRes = await storageService.GetItem<KeriaConnectConfig>();
        if (configRes.IsFailed || configRes.Value is null)
        {
            keriaConnectConfig = defaultKeriaConnectConfig;
            await storageService.SetItem<KeriaConnectConfig>(keriaConnectConfig);
            }
        else
        {
            keriaConnectConfig = configRes.Value;
            }
        if (!keriaConnectConfig.ValidateConfiguration().IsSuccess)
        {
            navManager.NavigateTo(RouteToConfigure);
            return;
            }

        // Now, route to appropriate page,
        // depending on the application state and initial URL query (depending on interaction with a tab page)
        var currentAppState = stateService.GetState();
        logger.LogInformation($"currentAppState: {currentAppState}");
        initialUriQuery = App.InitialUri?.Query ?? String.Empty;
        // _logger.LogInformation($"initialUriQuery: {initialUriQuery}");
        var initialUriQuery2 = HttpUtility.UrlDecode(initialUriQuery);
        logger.LogInformation($"initialUriQuery2: {initialUriQuery2}");
        _ = await HandleAppStateAsync(currentAppState, initialUriQuery2);
        */
                logger.LogWarning($"OnInitializedAsync NavigateIfNeeded");
        await NavigateIfNeeded();
        logger.LogInformation($"OnInitializedAsync done");
    }


    /*
    protected override async Task OnParametersSetAsync()
    {
        }
    */

    /*
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        }
    */

    // NavigateIfNeeded checks AppCache state and navigates to appropriate page if needed, assuring the app is always configured, initialized, unlocked, authenticated, connected, etc. in the necessary order
    async Task NavigateIfNeeded()
    {
        logger.LogWarning("NavigateIfNeeded: appCache:...");
        logger.LogInformation("{x}", a.MyPreferences);
        logger.LogInformation("{x}", a.MyOnboardState);
        logger.LogInformation("{x}", a.MyKeriaConnectConfig);
        logger.LogInformation("{x}", a.MyKeriaConnectionInfo);
        logger.LogInformation("{x}", a.MyPasscodeModel);
        logger.LogInformation("{x}", a.MySessionExpiration);

        if (!a.MyOnboardState.IsWelcomed)
        {
            navManager.NavigateTo(RouteToWelcome);
            return;
        }
        if (!a.IsInstallAcknowledged)
        {
            navManager.NavigateTo(RouteToNewRelease);
            return;
        }
        if (!a.IsTosAgreed)
        {
            navManager.NavigateTo(RouteToTerms);
            return;
        }
        if (!a.IsPrivacyAgreed)
        {
            navManager.NavigateTo(RouteToPrivacy);
            return;
        }
        // Passing above conditions must equate to IsProductOnboarded
        if (!a.IsProductOnboarded)
        {
            logger.LogError("NavigateIfNeeded: Not ProductOnboarded");
            return;
        }
        if (!a.IsConfigured)
        {
            navManager.NavigateTo(RouteToConfigure);
            return;
        }
        // Passing the above conditions must equate to IsInitialized
        if (!a.IsInitialized)
        {
            logger.LogError("NavigateIfNeeded: Not Initialized");
            return;
        }
        if (!a.IsUnlocked)
        {
            navManager.NavigateTo(RouteToUnlock);
            return;
        }
        if (!a.IsAuthenticated)
        {
            logger.LogError("NavigateIfNeeded: Not Authenticated");
            return;
        }
        if (!a.IsIdentifierFetched)
        {
            navManager.NavigateTo(RouteToConnecting);
            return;
        }
        // Passing the above conditions must equate to IsConnectedToKeria
        if (!a.IsConnectedToKeria)
        {
            logger.LogError("NavigateIfNeeded: Not ConnectedToKeria");
            return;
        }
        // TODO P1 should navigate here to Dashboard or important to leave other current page as is?  Check also for popup and sidepanel context
        logger.LogInformation("NavigateIfNeeded: No re-route conditions detected.");
        navManager.NavigateTo(RouteToDashboard);

    }
    
}
