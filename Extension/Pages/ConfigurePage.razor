@page "/Configure.html"
@using Extension.Models.Storage
@using Extension.Services.Storage

@inject IPreferencesService preferencesService
@inject IStorageService storageService
@inject IStateService stateService
@inject IExtensionEnvironmentService extensionEnvironmentService
@inject ILogger<ConfigurePage> logger
@inject HttpClient httpClient
@inject NavigationManager navManager
@inject IJSRuntime js
@inject ISignifyClientService signifyClientService
@inject ISnackbar snackbar
@inject IJsRuntimeAdapter jsRuntimeAdapter
@using FluentResults

@code {
        // TODO P2 restructure as a record?
    struct Preset
    {
        public string ProviderName { get; init; }
        public string AgentUrl { get; init; }
        public string BootUrl { get; init; }
        public Preset(string provider, string adminUrl, string bootUrl)
        {
            ProviderName = provider;
            AgentUrl = adminUrl;
            BootUrl = bootUrl;
        }
    }

    class UrlModel
    {
        // TODO P2 add setters that validate these values are a URL.  If not equal to the selected preset, set the preset to "Custom"
        [Required]
        [Url(ErrorMessage = "Enter KERIA Agent Admin URL")]
        public string AdminUrl { get; set; } = presetAgents[0].AgentUrl;

        // TODO P2 see potential password needed for the boot endpoint: https://github.com/WebOfTrust/keria/issues/327
        public string? BootUrl { get; set; } = presetAgents[0].BootUrl;
    }

    // TODO P3 DRY with UnlockView
    class PasscodeFormModel
    {
        [Required]
        [StringLength(21, ErrorMessage = "Passcode must be 21 characters long", MinimumLength = 21)]
        [DataType(DataType.Password)]
        public string Passcode { get; set; } = "";
    }

    // fields
    KeriaConnectConfig defaultKeriaConnectConfig => new KeriaConnectConfig(defaultPreset.ProviderName, defaultPreset.AgentUrl, defaultPreset.BootUrl, 0);
    static readonly OperationDisplay ops1CheckLiveness = new OperationDisplay("Checking KERI Agent Service liveness", "Estalished KERIA connection");
    static readonly OperationDisplay ops2CheckHealth = new OperationDisplay("Checking KERI Agent Service health", "Confirmed healthy connection");
    static readonly OperationDisplay ops3Connect = new OperationDisplay("Connecting", "Connected");
    static readonly OperationDisplay ops4ListAids = new OperationDisplay("Retrieving your identifiers", "Retrieved identifiers");
    static readonly OperationDisplay ops5CreatePersonalAid = new OperationDisplay("Creating personal identifier", "Created new identifier");
    static List<Preset> presetAgents = new List<Preset>
    {
        new Preset("localhost", AppConfig.LocalhostKeriaAdminUrl, AppConfig.LocalhostKeriaBootUrl),
        new Preset("GLEIF Testnet", "https://keria.testnet.gleif.org:3901", "https://keria.testnet.gleif.org:3903"),
        new Preset("Custom", "", "")
    };
    WebExtensionsApi? webExtensionsApi;
    Preset _presetChoice = presetAgents[0];
    UrlModel urlModel = new UrlModel()
    {
        AdminUrl = presetAgents[0].AgentUrl,
        BootUrl = presetAgents[0].BootUrl,
    };
    PasscodeFormModel configuredPasscodeModel = new PasscodeFormModel();
    private MudButton? nextButton;

    // properties
    KeriaConnectConfig? KeriaConnectConfig { get; set; }
    static string InitialAlias { get; set; } = "";
    string RandomPasscode { get; set; } = "";
    bool IsPasscodeCopyConfirmed { get; set; }
    bool IsUsingExistingPasscode { get; set; } = true;
    bool IsProcessing { get; set; }
    bool IsConnected { get; set; }
    Preset PresetChoice
    {
        get
        {
            return _presetChoice;
        }
        set
        {
            _presetChoice = value;
            urlModel.AdminUrl = value.AgentUrl;
            urlModel.BootUrl = value.BootUrl;
        }
    }

    // reactive properties
    Preset defaultPreset => presetAgents[0];
    bool IsValidAdminURL =>
        !string.IsNullOrWhiteSpace(urlModel.AdminUrl) &&
        Uri.IsWellFormedUriString(urlModel.AdminUrl, UriKind.Absolute);
    bool IsValidBootURL =>
        !string.IsNullOrWhiteSpace(urlModel.BootUrl) &&
        Uri.IsWellFormedUriString(urlModel.BootUrl, UriKind.Absolute);
    bool IsValidNewInfo =>
        IsValidAdminURL
        && !string.IsNullOrWhiteSpace(configuredPasscodeModel.Passcode)
        && configuredPasscodeModel.Passcode.Length == 21
        && (IsUsingExistingPasscode
            || IsValidBootURL
                && (!string.IsNullOrEmpty(InitialAlias)
                && RandomPasscode == configuredPasscodeModel.Passcode
                && IsPasscodeCopyConfirmed)
        );
    bool IsKeriaConfigured => (KeriaConnectConfig is not null) && KeriaConnectConfig.ValidateConfiguration().IsSuccess;
    string BootUrlLabel => IsUsingExistingPasscode ? "Boot URL (optional if you already have account)" : "Boot URL";


    protected override async Task OnInitializedAsync()
    {
        webExtensionsApi = new WebExtensionsApi(jsRuntimeAdapter);
    }

    async Task SetIsNewAccount(bool isNewAccount)
    {
        IsUsingExistingPasscode = !isNewAccount;
        RandomPasscode = RandomStringGenerator.GenerateRandomString(21);
        // clear in case radio is toggled after passcode is copied, entered
        configuredPasscodeModel.Passcode = "";
        IsPasscodeCopyConfirmed = false;
        await ResetOps();
        await js.InvokeVoidAsync("navigator.clipboard.writeText", RandomPasscode);
    }

    async Task ResetOps()
    {
        IsProcessing = false;
        ops1CheckLiveness.Reset();
        ops2CheckHealth.Reset();
        ops3Connect.Reset();
        ops4ListAids.Reset();
        ops5CreatePersonalAid.Reset();
        StateHasChanged();
    }

    async Task<Result<KeriaConnectionInfo>> ConnectToKeria()
    {
        await ResetOps();
        logger.LogInformation("ConnectToKeria");
        IsProcessing = true;

        if (!(IsValidNewInfo || IsKeriaConfigured))
        {
            throw new Exception("ConnectToKeria: preconditions not met");
        }

        if (IsValidBootURL)
        {
            // check if BootUrl is reachable.
            ops1CheckLiveness.SetIsRunning();
            StateHasChanged();

            // TODO P2 avoid if BootUrl is not a URL
            var baseUri = new Uri(urlModel.BootUrl!);
            // TODO P2 would be better to check the KERI port (or a non-Boot URL), which means this needs to be configured.
            var healthUri = new Uri(baseUri, "health");
            var healthUriBuilder = new UriBuilder(healthUri);

            var postResult = await signifyClientService.HealthCheck(healthUriBuilder.Uri);
            if (!postResult.IsSuccess)
            {
                const string message = "KERIA service is not reachable";
                // _logger.LogWarning($"{message} at {healthUriBuilder.Uri}.");
                ops1CheckLiveness.SetCompletedWithError(message);
                return Result.Fail<KeriaConnectionInfo>(new ConnectionError(urlModel.AdminUrl, message));
            }
            ops1CheckLiveness.SetCompletedWithoutErrors();
            StateHasChanged();

            // check if KERIA is reporting as healthy
            ops2CheckHealth.SetIsRunning();
            StateHasChanged();
            // TODO P3 move this into service or helper code
            // TODO P2 should not run this if BootUrl is not a URL
            var httpClientService2 = new HttpClientService(new HttpClient());
            var postResult2 = await httpClientService2.GetJsonAsync<String>(healthUriBuilder.Uri.ToString());
            if (!postResult2.IsSuccess || postResult2.Value.StatusCode != System.Net.HttpStatusCode.OK)
            {
                ops2CheckHealth.SetCompletedWithError(postResult2.Reasons.First().Message);
                StateHasChanged();
                return Result.Fail<KeriaConnectionInfo>(new ConnectionError(urlModel.AdminUrl, postResult2.Reasons.First().Message));
            }
            else
            {
                ops2CheckHealth.SetCompletedWithoutErrors();
            }
            StateHasChanged();
            await Task.Delay(100);
        }

        // Create a new KERIA client, and on success cache the passcode
        ops3Connect.SetIsRunning();
        StateHasChanged();
        await Task.Delay(100);
        logger.LogInformation("Connecting to KERIA at {url}...", urlModel.AdminUrl);
        var clientRes = await signifyClientService.Connect($"{urlModel.AdminUrl}", configuredPasscodeModel.Passcode, $"{urlModel.BootUrl}", !IsUsingExistingPasscode);
        if (clientRes.IsFailed)
        {
            ops3Connect.SetCompletedWithError(clientRes.Reasons.First().Message);
            StateHasChanged();
            return Result.Fail<KeriaConnectionInfo>(new ConnectionError(urlModel.AdminUrl, clientRes.Reasons.First().Message));
        }
        ops3Connect.SetCompletedWithoutErrors();

        // Store passcode and session expiry time in session storage
        // TODO P3 DRY with Unlock.razor.  CreateAuthorizedNewSession()?
        {
            // Store passcode in session storage
            var storeResult = await storageService.SetItem(
                new PasscodeModel { Passcode = configuredPasscodeModel.Passcode },
                StorageArea.Session
            );
            if (storeResult.IsFailed)
            {
                logger.LogError("Failed to store passcode: {Errors}", string.Join(", ", storeResult.Errors));
                return Result.Fail<KeriaConnectionInfo>(new StorageError("Failed to store passcode in session storage"));
            }
            // store the SessionExpiry time
            var sessionExpiry = DateTime.UtcNow.AddMinutes(App.Prefs.InactivityTimeoutMinutes);
            var storeExpiryResult = await storageService.SetItem<SessionExpiration>(
                new SessionExpiration { SessionExpirationUtc = sessionExpiry },
                StorageArea.Session
            );
            if (storeExpiryResult.IsFailed)
            {
                logger.LogError("Failed to store session expiry: {Errors}", string.Join(", ", storeExpiryResult.Errors));
                return Result.Fail<KeriaConnectionInfo>(new StorageError("Failed to store session expiry in session storage"));
            }
        }

        int passcodeHash = GetNumberFromHash.HashInt(configuredPasscodeModel.Passcode);
        KeriaConnectConfig = new KeriaConnectConfig(_presetChoice.ProviderName, urlModel.AdminUrl, urlModel.BootUrl, passcodeHash, clientRes.Value.Agent!.I, clientRes.Value.Controller!.State!.I);
        // KeriaConnectConfig will be stored by caller of ConnectToKeria()
        StateHasChanged();
        await Task.Delay(100);

        // GetIdentifiers
        ops4ListAids.SetIsRunning();
        StateHasChanged();
        await Task.Delay(100);
        var identifiersRes = await signifyClientService.GetIdentifiers();
        if (identifiersRes.IsFailed)
        {
            ops4ListAids.SetCompletedWithError(identifiersRes.Reasons.First().Message);
            StateHasChanged();
            return Result.Fail<KeriaConnectionInfo>(identifiersRes.Errors);
        }
        var identifiers = identifiersRes.Value;
        ops4ListAids.SetCompletedWithoutErrors();
        StateHasChanged();
        await Task.Delay(100);


        // If there are no Identifiers, create one
        if (identifiers.Aids.Count == 0)
        {
            ops5CreatePersonalAid.SetIsRunning();
            StateHasChanged();
            var aidRes = await signifyClientService.RunCreateAid(InitialAlias);
            if (aidRes.IsFailed)
            {
                ops5CreatePersonalAid.SetCompletedWithError(aidRes.Reasons.First().Message);
                StateHasChanged();
                return Result.Fail<KeriaConnectionInfo>(aidRes.Errors);
            }
            ops5CreatePersonalAid.SetCompletedWithoutErrors();

            // set the selected aid in MyPreferences, so it shows up in the AppBar identicon
            // using JsonDocument doc = JsonDocument.Parse(aidRes.Value);
            string? prefix = aidRes.Value; // doc.RootElement.GetProperty("prefix").GetString();
            if (prefix is not null)
            {
                await preferencesService.SetPreferences(App.Prefs with { SelectedPrefix = prefix });    
            }
        }
        else
        {
            // Set default Prefix
            await preferencesService.SetPreferences(App.Prefs with { SelectedPrefix = identifiers.Aids.First().Prefix });
        }
        // _logger.LogWarning("ConnectToKeria 3");
        if (nextButton is not null)
            await nextButton.FocusAsync();
        // _logger.LogWarning("ConnectToKeria 4");
        return Result.Ok(new KeriaConnectionInfo() {
                Config = KeriaConnectConfig!,
                SessionExpirationUtc = DateTime.UtcNow.AddMinutes(App.Prefs.InactivityTimeoutMinutes), // min
                IdentifiersList = [identifiers],
                AgentPrefix = clientRes.Value.Agent!.I,
            // ControllerPrefix = clientRes.Value.Controller!.State!.I,
            });
}

    async Task StoreHashAndConnect()
    {
        logger.LogInformation("StoreHashAndConnect...");
        // Since user has confirmed the passcode, we can now hash it and store it once the connection is successful
        IsProcessing = true;
        StateHasChanged();
        var connectionResult = await ConnectToKeria();
        // _logger.LogWarning("tmp finished ConnectoToKeria");
        if (connectionResult.IsSuccess)
        {
            IsConnected = true;
            var connectionInfo = connectionResult.Value;

            // TODO P1 Unlock should also do this caching of connection info in session storage. DRY
            var cacheConnectionResult = await storageService.SetItem<KeriaConnectionInfo>(connectionInfo, StorageArea.Session);
            if (cacheConnectionResult.IsFailed)
            {
                logger.LogError("Failed to cache connection info in session storage");
                logger.LogError(cacheConnectionResult.Reasons.First().Message);
                snackbar.Add("Failed to cache connection info in session storage", Severity.Error);
                return;
            }

            KeriaConnectConfig = connectionInfo.Config;
            var storeConfigResult = await storageService.SetItem<KeriaConnectConfig>(connectionInfo.Config);
            if (storeConfigResult.IsFailed)
            {
                logger.LogError("Failed to store connection details");
                logger.LogError(storeConfigResult.Reasons.First().Message);
                snackbar.Add("Failed to store connection configuration", Severity.Error);
                return;
            }
            var configureResult = await stateService.Configure();
            if (configureResult.IsFailed)
            {
                logger.LogError("Failed to configure state: {error}", configureResult.Errors.FirstOrDefault()?.Message);
                snackbar.Add("Failed to configure application state", Severity.Error);
                return;
            }
            var authResult = await stateService.Authenticate(true);
            if (authResult.IsFailed)
            {
                logger.LogError("Failed to authenticate: {error}", authResult.Errors.FirstOrDefault()?.Message);
                snackbar.Add("Failed to authenticate", Severity.Error);
                return;
            }
            logger.LogInformation("StoreHashAndConnect succeeded");
            StateHasChanged();
            return;
        }
        else
        {
            IsConnected = false;
            var error = connectionResult.Errors[0];
            var errorMsg = $"Failed to connect: {error?.Message ?? "Unknown error"}";
            logger.LogWarning(errorMsg);
            snackbar.Add(errorMsg, Severity.Warning);
            return;
        }
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    <div class="d-flex gap-3 bt-main">
        <MudStack Style="min-width: 340px; width:100%; margin-right:16px;">
            <MudText Typo="Typo.h6">Configure KERI Agent</MudText>
            <MudStack>
                <MudText Typo="Typo.h6">Service</MudText>
                <MudSelect T="Preset" Label="Provider Preset" @bind-Value="@PresetChoice">
                    @foreach (var preset in presetAgents)
                    {
                        <MudSelectItem Value="@preset">@preset.ProviderName</MudSelectItem>
                    }
                </MudSelect>
                <MudTextField Label="Agent URL"
                              @bind-Value="@urlModel.AdminUrl"
                              For="@(() => urlModel.AdminUrl)"
                              Immediate="true" />
                <MudTextField Label="@BootUrlLabel"
                              Required="!IsUsingExistingPasscode"
                              @bind-Value="@urlModel.BootUrl"
                              For="@(() => urlModel.BootUrl)"
                              Immediate="true" />
                <MudText Typo="Typo.h6">Your Passcode</MudText>
                <MudRadioGroup T="Boolean" ValueChanged="async (bool v) => await SetIsNewAccount(v)">
                    <MudRadio Value="false">
                        Use existing
                    </MudRadio>
                    <MudRadio Value="true">
                        Create new
                    </MudRadio>
                </MudRadioGroup>
                @if (IsUsingExistingPasscode)
                {
                    <MudTextField Label="Your passcode"
                                  InputType="InputType.Password"
                                  @bind-Value="@configuredPasscodeModel.Passcode"
                                  For="@(() => configuredPasscodeModel.Passcode)"
                                  Immediate="true" />
                    <MudButton Variant="Variant.Filled" Style="width:fit-content;" OnClick="StoreHashAndConnect" Disabled="@(!IsValidNewInfo || IsKeriaConfigured)" Color="Color.Primary">Connect</MudButton>
                }
                else // create a new passcode
                {
                    <MudTextField Label="Generated random passcode"
                                  InputType="InputType.Password"
                                  @bind-Value="@RandomPasscode"
                                  ReadOnly="true"
                                  Immediate="true" />
                    // TODO P4 implmement Reveal and CopyToClipboard
                    <MudCheckBox @bind-Value="IsPasscodeCopyConfirmed" Style="overflow-wrap:break-word;">I have copied and stored this passcode in a secure place</MudCheckBox>
                    @if (IsPasscodeCopyConfirmed)
                    {
                        <MudTextField Label="Confirm your passcode"
                                      InputType="InputType.Password"
                                      @bind-Value="@configuredPasscodeModel.Passcode"
                                      For="@(() => configuredPasscodeModel.Passcode)"
                                      Immediate="true" />
                        @if (@configuredPasscodeModel.Passcode.Length != 21)
                        {
                            <MudText></MudText>
                        }
                        else if (@configuredPasscodeModel.Passcode != RandomPasscode)
                        {
                            <MudText Color="Color.Error">Passcode does not match</MudText>
                        }
                        else
                        {
                            <MudIcon Icon="@Icons.Material.Filled.Check" Color="Color.Success"></MudIcon>
                            <MudTextField Label="Alias for your initial identifier"
                                          InputType="InputType.Text"
                                          @bind-Value="@InitialAlias"
                                          spellcheck="false"
                                          Immediate="true"
                                          HelperText="@AppConfig.ExampleAlias" />
                            <MudButton Variant="Variant.Filled" Style="width:fit-content;" OnClick="StoreHashAndConnect" Disabled="@(!IsValidNewInfo || IsKeriaConfigured)" Color="Color.Primary"><MudText>Connect and Create Initial Identifier</MudText></MudButton>
                        }
                    }
                }
                @if (IsProcessing)
                {
                    <MudText Typo="Typo.h6">Connecting...</MudText>
                    <MudStack Class="mt-5">
                        @if (!IsUsingExistingPasscode)
                        {
                            <OperationDisplayComponent ops="@ops1CheckLiveness"></OperationDisplayComponent>
                            <OperationDisplayComponent ops="@ops2CheckHealth"></OperationDisplayComponent>
                        }
                        <OperationDisplayComponent ops="@ops3Connect"></OperationDisplayComponent>
                        <OperationDisplayComponent ops="@ops4ListAids"></OperationDisplayComponent>
                        @if (!IsUsingExistingPasscode)
                        {
                            <OperationDisplayComponent ops="@ops5CreatePersonalAid"></OperationDisplayComponent>
                        }
                    </MudStack>
                }
            </MudStack>
        </MudStack>
    </div>
    <MudStack Row="true" class="bt-button-tray">
        <!-- Intentionally no back button here -->
        <MudSpacer />
        <MudButton @ref="nextButton" Disabled="@(!IsKeriaConfigured)" Variant="Variant.Filled" Color="Color.Primary" OnClick="@(() => navManager.NavigateTo(RouteToIndex))" Class="justify-start" data-testid="next">Next</MudButton>
    </MudStack>
</div>
