@using Blazor.BrowserExtension
@using static KeriAuth.BrowserExtension.AppConfig
@using KeriAuth.BrowserExtension
@using KeriAuth.BrowserExtension.Helper
@using KeriAuth.BrowserExtension.UI
@using KeriAuth.BrowserExtension.Services
@using KeriAuth.BrowserExtension.UI.Layouts
@using KeriAuth.BrowserExtension.Models
@using MudBlazor
@using System.Runtime.InteropServices.JavaScript;
@using KeriAuth.BrowserExtension.Services.SignifyService
@inject IExtensionEnvironmentService extensionEnvironmentService
@inject NavigationManager navManager
@inject IJSRuntime jsRuntime
@inject ILogger<App> logger
@inject IPreferencesService preferencesService
@inject IStorageService storageService
@inject IStateService stateService
@inject IAppSwMessagingService appSwMessagingService

<Router AppAssembly="@typeof(App).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)" />
    </Found>
    <NotFound>
        <PageTitle>Loading application assembly...</PageTitle>
        <LayoutView>
            <h1>Page not found</h1>
            <p role="alert">Sorry, there's nothing at this address.</p>
        </LayoutView>
    </NotFound>
</Router>

@code {
    public static bool IsDarkTheme { get; set; }

    // private readonly DotNetObjectReference<App>? _dotNetObjectRef;

    // public void Dispose()
    // {
    //     _dotNetObjectRef?.Dispose();
    // }

    private static IStateService? staticStateService;
    private static NavigationManager? staticNavManager;

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation($"OnInitializedAsync");
        await base.OnInitializedAsync();

        // TODO P1 hack. Instead, create a StaticHelper static class that has injected methods
        staticStateService = stateService;
        staticNavManager = navManager;

        //         _dotNetObjectRef = DotNetObjectReference.Create(this);

        // Initialize services as needed
        var uri = navManager.ToAbsoluteUri(navManager.Uri);
        var contexts = await UIHelper.GetChromeContexts();
        logger.LogInformation($"Chrome Contexts: {contexts}");
        extensionEnvironmentService.Initialize(uri, "unknown");
        await storageService.Initialize();
        await stateService.Initialize();
        preferencesService.Initialize();

        // Subscribe to and handle messages from service worker via messaging service
        appSwMessagingService.Subscribe<string>((message) =>
        {
            logger.LogInformation("App from SW/MessagingService: {m}", message);
        });

        // Initialize messaging with service worker
        await appSwMessagingService.Initialize(uri.Authority);

        // TODO P0 should this subscribeToUserInteractions move elsewhere?
        // protected override async Task OnAfterRenderAsync(bool firstRender)
        // {
        //     if (firstRender)
        //     {
        // Subscribe to user interaction events
        await jsRuntime.InvokeVoidAsync("subscribeToUserInteractions");
        //     }
        // }

        await jsRuntime.InvokeVoidAsync("registerLockListener");

        //
        var result = await jsRuntime.InvokeAsync<Dictionary<string, object>>("chrome.storage.session.get", "passcode");
        if (result.ContainsKey("passcode"))
        {
            // Password exists, app is unlocked
            logger.LogWarning("passcode exists");
        }
        else
        {
            // Password does not exist, app is locked
            logger.LogWarning("passcode does not exists. Locked");
        }
    }
}

@code {
    [JSInvokableAttribute("LockApp")]
    public static async Task LockApp()
    {
        await staticStateService!.TimeOut();
        staticNavManager!.NavigateTo(RouteToStart);
        // Other side-effects will be reactive. See IObserver<StateService>
        return;
    }
}