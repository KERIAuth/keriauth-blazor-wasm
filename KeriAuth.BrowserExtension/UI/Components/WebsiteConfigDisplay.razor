@using KeriAuth.BrowserExtension.Models
@using KeriAuth.BrowserExtension.Helper
@using KeriAuth.BrowserExtension.Services
@using KeriAuth.BrowserExtension.Services.SignifyService
@using System.Text.Json;
@using System.Diagnostics;
@using KeriAuth.BrowserExtension.Helper.DictionaryConverters
@using static KeriAuth.BrowserExtension.Helper.Identicon
@using static KeriAuth.BrowserExtension.Helper.PreviousPage
@using MudBlazor
@using Newtonsoft.Json;

@inject ILogger<WebsiteConfigDisplay> logger
@inject IWebsiteConfigService websiteConfigService
@inject IStateService stateService
@inject ISignifyClientService signifyClientService
@inject IdentifiersService identifiersService
@inject IPreferencesService preferencesService
@inject IStorageService storageService
@inject IDialogService dialogService
@inject ISnackbar snackbar
@inject IExtensionEnvironmentService extensionEnvironmentService
@inject IAppSwMessagingService appSwMessagingService
@inject IJSRuntime jsRuntime
@inject NavigationManager navManager

@code {
    [Parameter] public required string? OriginStr { get; init; }
    [Parameter] public required bool IsCredentialShown { get; init; }
    [Parameter] public required bool IsOriginShown { get; init; }
    [Parameter] public EventCallback<(string? selectedPrefix, Dictionary<string, object>? selectedCredential)> ValueChanged { get; init; }

    // properties
    bool IsCredListExpanded { get; set; }
    List<IdentifierHeadline>? IdentifierHeadlines { get; set; }
    bool IsAutoSignInIdentifier { get; set; }
    string? SelectedPrefix { get; set; }
    WebsiteConfig? ThisWebsiteConfig { get; set; }
    List<Dictionary<string, object>>? CredentialsDict { get; set; }

    // reactive properties
    // TODO P2 optimize SelectedCredentialOrNothing expression to use FilteredCredentials
    Dictionary<string, object>? SelectedCredentialOrNothing => (SelectedCredSaidOrNothing is null || CredentialsDict is null) ? null : filterCredentials(CredentialsDict, [("sad.d", SelectedCredSaidOrNothing)])?.FirstOrDefault();
    string? SelectedCredSaidOrNothing => (ThisWebsiteConfig is null) ? null : ThisWebsiteConfig.RememberedCredSaidOrNothing;
    List<Dictionary<string, object>> FilteredCredentials => (CredentialsDict is null || SelectedPrefix is null) ? new List<Dictionary<string, object>>() : filterCredentials(CredentialsDict, [("sad.a.i", SelectedPrefix)]);
    string ExpandIcon => IsCredListExpanded ? Icons.Material.Filled.ExpandLess : Icons.Material.Filled.ExpandMore;
    bool IsAutoSign => ThisWebsiteConfig?.IsAutoSignHeaders ?? false;
    public Uri? OriginUri => OriginStr is null ? null : TryCreateUri(OriginStr);

    protected override async Task OnInitializedAsync()
    {
        // await base.OnInitializedAsync();
        logger.LogInformation("OnInitializedAsync");
        // Initial render prerequisites here
        await GetInitialIdentifierHeadlines();
        await getCredentials();
        await Task.Delay(100); // allow cycles for reactive properties to update
        await SendValueToParent(); // allows parent to enable or disable Sign In button, for example
        logger.LogInformation("OnInitializedAsync done 1");
    }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        logger.LogInformation("OnParametersSetAsync");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        logger.LogInformation("OnAfterRenderAsync");
        if (firstRender)
        {
            if (OriginUri is not null)
            {
                await RefreshFromWebsiteConfig(OriginUri);
            }
        }
    }

    private Uri? TryCreateUri(string origin)
    {
        try
        {
            return new Uri(origin);
        }
        catch (Exception ex)
        {
            logger.LogError("Error parsing OriginStr '{OriginStr}': {Error}", origin, ex);
            return null;
        }
    }

    /*
    * Send data back to host of this component, such as the RequestSignInPage or RequestSignPage.
    */
    async Task SendValueToParent()
    {
        logger.LogInformation($"SendValueToParent prefix: {SelectedPrefix} | SelectedCredential {SelectedCredentialOrNothing is not null}");

        if (ValueChanged.HasDelegate)
        {
            await ValueChanged.InvokeAsync((SelectedPrefix, SelectedCredentialOrNothing));
        }
        else
        {
            logger.LogWarning("SendValueToParent has no ValueChagned delegate");
        }
        StateHasChanged(); // needed?
    }

    async Task RefreshFromWebsiteConfig(Uri? originUri)
    {
        if (originUri is null)
        {
            ThisWebsiteConfig = null;
            SelectedPrefix = null;
        }
        else
        {
            try
            {
                var getOrCreateWebsiteRes = await websiteConfigService.GetOrCreateWebsiteConfig(originUri);
                if (getOrCreateWebsiteRes.IsFailed)
                {
                    throw new Exception($"Error from websiteService {getOrCreateWebsiteRes.Errors}");
                }
                var (newWebsite, isConfigNew) = getOrCreateWebsiteRes.Value;
                ThisWebsiteConfig = newWebsite;

                if (isConfigNew)
                {
                    SelectedPrefix = (await preferencesService.GetPreferences()).SelectedPrefix;
                    ThisWebsiteConfig = ThisWebsiteConfig with { RememberedPrefixOrNothing = SelectedPrefix };
                    await UpdateWebsiteConfigAndParent(ThisWebsiteConfig);
                }
                else
                {
                    SelectedPrefix = ThisWebsiteConfig.RememberedPrefixOrNothing!;
                }
            }
            catch
            {
                throw new Exception("could not RefreshFromWebsiteConfig");
            }
        }
        // StateHasChanged();
        // Update reactive properties dependant on above
        // await Task.Delay(1); // precaution, to let reactive properties recalc for the next call?
        // send relevant values to parent (e.g. a page for SignIn or website config)
        // TODO P0 remove this:
        // await SendValueToParent();
    }

    private async Task GetInitialIdentifierHeadlines()
    {
        logger.LogWarning("GetInitialIdentifierHeadlines() ...");
        var res = await identifiersService.GetIdentifierHeadlines();
        if (res?.IsSuccess == true && res.Value is not null)
        {
            IdentifierHeadlines = res.Value.OrderBy(a => a.Alias).ToList();
        }
        else
        {
            throw new Exception("unexpected null identifier Headlines");
        }
        StateHasChanged();
        logger.LogWarning("GetInitialIdentifierHeadlines() done count: {c}", IdentifierHeadlines?.Count());
    }

    // TODO P2 DRY move this filterCredentials to a helper
    // TODO P1 Incorporate this use into the Credentials display to (checkbox) Show selected Identifier only, default true
    List<Dictionary<string, object>> filterCredentials(List<Dictionary<string, object>> credentialDictList, List<(string filterPath, string match)> filters)
    {
        if (!filters.Any())
        {
            throw new Exception("filterCredentials must have at least one filter string");
        }
        List<Dictionary<string, object>> filteredCredentials = new();
        foreach (var credDict in credentialDictList)
        {
            foreach (var filter in filters)
            {
                // if (filters.All(filter => DictionaryConverter.GetValueByPath(credDict, filter.filterPath)?.Value as string == filter.match))
                // if (DictionaryConverter.GetValueByPath(credDict, filter.filterPath)?.Value as string == filter.match)
                // {
                //     filteredCredentials.Add(credDict);
                //     break;
                // }

                // include filtered value if any of the filters match (versus all)
                var value = DictionaryConverter.GetValueByPath(credDict, filter.filterPath)?.Value as string;
                if (value != null && value == filter.match)
                {
                    filteredCredentials.Add(credDict);
                    break;
                }
            }
        }
        // logger.LogWarning("filteredCredentials: count: {c} ", filteredCredentials.Count);
        return filteredCredentials;
    }

    async Task updateSelectedPrefix(string prefix)
    {
        logger.LogInformation("updateSelectedPrefix set prefix to ", prefix);
        IsCredListExpanded = false;

        if (ThisWebsiteConfig is null)
        {
            throw new Exception($"updateSelectedPrefix: ThisWebsiteConfig should not be null here.");
        }
        // when changing the prefix, any prior selection of RememberedCred will not be relevant
        // IsAutoSign = false;
        var newWebsiteConfig = ThisWebsiteConfig with
            {
                RememberedPrefixOrNothing = prefix,
                RememberedCredSaidOrNothing = null,
                IsAutoSignInCredential = IsAutoSign,
                IsAutoSignInIdentifier = false
            };
        newWebsiteConfig.Validate();
        await UpdateWebsiteConfigAndParent(newWebsiteConfig);

        if (OriginUri is not null)
        {
            await RefreshFromWebsiteConfig(OriginUri);
            await SendValueToParent(); // may not be necessary here. test by changing Prefix to see if Sign In button goes disabled
        }

    }

    async Task updateSelectedCredential(Dictionary<string, object>? newSelectedCredential)
    {
        logger.LogWarning("updateSelectedCredential...");
        if (newSelectedCredential is null || !newSelectedCredential.Any())
        {
            logger.LogError($"updateSelectedCredential: credential should not be null or empty here.");
            return;
        }
        if (ThisWebsiteConfig is null)
        {
            logger.LogError("updateSelectedCredential: ThisWebsiteConfig should not be null here.");
            return;
        }
        if (newSelectedCredential is null || !newSelectedCredential.Any())
        {
            logger.LogError("unexpected null newSelectedCredential");
            return;
        }

        var rememberedCredSaidOrNothing = DictionaryConverter.GetValueByPath(newSelectedCredential, "sad.d")?.Value?.ToString() ?? null;
        if (rememberedCredSaidOrNothing is null)
        {
            string json = JsonConvert.SerializeObject(newSelectedCredential, Formatting.Indented);
            logger.LogInformation("updateSelectedCredential set to ~ ", json);
            logger.LogError($"updateSelectedCredential: Could not find SAID of credential");
            return;
        }
        logger.LogWarning("updateSelectedCredential credSaid: ", rememberedCredSaidOrNothing);

        var newWebsiteConfig = ThisWebsiteConfig with
            {
                RememberedCredSaidOrNothing = rememberedCredSaidOrNothing,
                RememberedPrefixOrNothing = SelectedPrefix,
                IsAutoSignHeaders = IsAutoSign,
                IsAutoSignInCredential = IsAutoSign,
                IsAutoSignInIdentifier = IsAutoSign // intentional, since selected cred implies identifier
            };
        newWebsiteConfig.Validate();

        await UpdateWebsiteConfigAndParent(newWebsiteConfig);

        IsCredListExpanded = false;
        // why is any of the following needed?
        if (OriginUri is not null)
        {
            await RefreshFromWebsiteConfig(OriginUri);
            await Task.Delay(100); // needed? allow time for reactive properties to update
            await SendValueToParent(); // needed?
        }
        return;
    }

    async Task getCredentials()
    {
        var res = await signifyClientService.GetCredentials();
        if (res.IsFailed || res.Value is null)
        {
            logger.LogError($"Error: {res.Errors}");
            return;
        }
        else
        {
            CredentialsDict = res.Value as List<Dictionary<string, object>>;
        }
    }

    async Task updateIsAutoSign(bool isChecked)
    {
        // IsAutoSign = isChecked;
        logger.LogInformation("updateIsAutoSignInCred isChecked: {b} WebsiteConfig: {w}", isChecked, ThisWebsiteConfig);
        if (ThisWebsiteConfig is not null && ThisWebsiteConfig.IsAutoSignHeaders != isChecked)
        {
            ThisWebsiteConfig = ThisWebsiteConfig with { IsAutoSignHeaders = isChecked };
            await UpdateWebsiteConfigAndParent(ThisWebsiteConfig);
        }
        StateHasChanged(); // needed?
    }

    string GetCredentialItemClass(Dictionary<string, object> item)
    {
        return item == SelectedCredentialOrNothing ? "selected-item pa-1 ml-1 mr-1" : "pa-1 ml-2 mr-1";
    }

    string GetIdentifierItemClass(string prefix)
    {
        return prefix == SelectedPrefix ? "selected-item" : String.Empty;
    }

    async Task UpdateWebsiteConfigAndParent( WebsiteConfig wc)
    {
        // TODO P2 evaluate results
        _ = await websiteConfigService.Update(wc);
        await Task.Delay(100); // allow reactive properties time to evaluate
        await SendValueToParent();
    }
}

<div id="@this.GetType().Name" class="bt-body-page">
    @if (IsOriginShown)
    {
        <MudText Typo="Typo.body1"><em>@OriginStr</em></MudText>
    }
    <!-- Select Identifier -->
    @if (IdentifierHeadlines is not null && IdentifierHeadlines.Any())  // this causes loading all at once versus rolling
    {
        <MudStack Class="gap-0">
            <MudText Class="mt-4" Typo="Typo.h6">Identifier</MudText>
            <MudStack Class="ml-0" Style="gap:0;">
                <MudSelect T="string" Value="@SelectedPrefix" ValueChanged="async (string v) => await updateSelectedPrefix(v)">
                    @foreach (var identifierHeadline in IdentifierHeadlines)
                    {
                        <MudSelectItem Value="@identifierHeadline.Prefix" Class="@GetIdentifierItemClass(identifierHeadline.Prefix)">
                            <MudStack Row Style="align-items:center;">
                                <MudIcon Icon=@identifierHeadline.Identicon ViewBox="0 0 100 100" Style="border-style:solid; border-color:black; border-width:2px; border-radius:50%; width:35px; height:35px; overflow:hidden; margin-top: 3px;" />
                                <div class="bt-sad-2" style="display:contents;">
                                    <MudText Typo="Typo.subtitle2" Color="Color.Primary">@identifierHeadline.Alias</MudText>
                                </div>
                            </MudStack>
                        </MudSelectItem>
                    }
                </MudSelect>
            </MudStack>
        </MudStack>
    }
    @if (IsCredentialShown && CredentialsDict is not null && CredentialsDict.Any()) // so this section appears all at once versus progressively
    {
        <!-- Select Credential --->
        <MudStack Class="gap-0">
            <MudText Class="mt-4" Typo="Typo.h6">Credential</MudText>
            <MudStack Class="ml-0" Style="gap:0;">
                <MudPaper Class="pa-0 mr-0">
                    <!-- Display Selected Credential -->
                    @if (!IsCredListExpanded)
                    {
                        <MudPaper Class="d-flex align-items-center" @onclick="() => IsCredListExpanded = !IsCredListExpanded">
                            @if (SelectedCredentialOrNothing is null)
                            {
                                <div style="width:100%; align-content:center;">
                                    <MudText Class="ml-3">Select</MudText>
                                </div>
                            }
                            else
                            {
                                <CredentialDisplay credential="@SelectedCredentialOrNothing" displayDetail="@CredentialDisplay.CredentialDisplayDetail.MinimalWithoutIssuee" />
                            }
                            <MudSpacer />
                            <MudIconButton Style="padding: 0;" Icon="@ExpandIcon" OnClick="() => IsCredListExpanded = !IsCredListExpanded" />
                        </MudPaper>
                    }
                    else
                    {
                        if (FilteredCredentials is not null && FilteredCredentials.Any())
                        {
                            <MudList Dense="true" T="Dictionary<string, object>">
                                @foreach (Dictionary<string, object> credential in FilteredCredentials)
                                {
                                    <MudListItem OnClick="async () => await updateSelectedCredential(credential)" Class="@GetCredentialItemClass(credential)">
                                        <CredentialDisplay credential="@credential" />
                                    </MudListItem>
                                }
                            </MudList>
                        }
                        else
                        {
                            <MudText>No credentials issued to this identifier.</MudText>
                        }
                    }
                </MudPaper>
                <MudCheckBox Label="Automatically sign Http Request Headers" Disabled="@(SelectedCredentialOrNothing is null)" style="height: 28px;" Value="@IsAutoSign" ValueChanged="async (bool b) => await updateIsAutoSign(b)" />
            </MudStack>
        </MudStack>
    }
</div>

<style>
    .mud-select .mud-select-input .mud-input-slot {
        height: auto;
    }

    .selected-item {
        border-left: 4px solid blue;
    }
</style>