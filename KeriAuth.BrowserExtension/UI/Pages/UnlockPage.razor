@page "/Unlock"
@layout Layouts.MainLayout

@using KeriAuth.BrowserExtension.Helper
@using KeriAuth.BrowserExtension.Models
@using KeriAuth.BrowserExtension.Services
@using KeriAuth.BrowserExtension
@using KeriAuth.BrowserExtension.UI.Components
@using KeriAuth.BrowserExtension.Services.SignifyService
@using KeriAuth.BrowserExtension.Services.SignifyService.Models
@using static KeriAuth.BrowserExtension.Helper.PreviousPage
@using static KeriAuth.BrowserExtension.AppConfig;
@using static KeriAuth.BrowserExtension.Helper.UIHelper;
@using static KeriAuth.BrowserExtension.Services.SignifyService.SignifyServiceConfig
@using FluentResults
@using JsBind.Net
@using JsBind.Net.Configurations
@using System.Diagnostics;
@using System.Text.Json;
@using System.Text.Json.Nodes
@using Blazor.BrowserExtension
@using WebExtensions.Net
@using WebExtensions.Net.Runtime
@using Microsoft.AspNetCore.Components.WebAssembly.Hosting
@using JsonSerializer = System.Text.Json.JsonSerializer
@using static System.Net.WebRequestMethods
@using System.ComponentModel.DataAnnotations
@using System.Linq
@using System.Text
@using System.Security.Cryptography

@inject IPreferencesService preferencesService
@inject IStorageService storageService
@inject IStateService stateService
@inject IExtensionEnvironmentService extensionEnvironmentService
@inject ILogger<UnlockPage> logger
@inject HttpClient http
@inject NavigationManager navManager
@inject IJSRuntime js
@inject ISignifyClientService signifyClientService
@inject ISnackbar snackbar
@inject IWebExtensionsApi webExtensionsApi

<div id="@this.GetType().Name" class="bt-body-page">
    <div class="d-flex gap-3 bt-main" style="justify-content:center;">
        <MudStack Class="d-flex justify-center pa-0" Style="text-align:center;">
            <MudImage Style="align-self:center;" Fluid="true" Width="190" Class="mx-11" Src="/images/humans_1.png"></MudImage>
            <MudText Typo="Typo.h5">
                <span style="font-weight:bold; font-variant: small-caps;">KeriAuth</span>
            </MudText>
            <MudText Style="font-style:italic">autonomously authentic</MudText>
            @if (!ShouldUseAuthenticator)
            {
                <MudForm @ref="form" @bind-IsValid="@isValid" @bind-Errors="@errors" Style="height: 80px;">
                    <MudTextField Label="Passcode"
                                  @ref="passcodeField"
                                  OnKeyDown="@HandleKeyDown"
                                  InputType="InputType.Password"
                                  @bind-Value="@unlockPasscodeModel.Passcode"
                                  HelperText="&nbsp;"
                                  ErrorText="&nbsp;"
                                  For="@(() => unlockPasscodeModel.Passcode)"
                                  Immediate="true"
                                  @onfocus="SelectAllText" />
                </MudForm>

                @if (CanUseAuthenticator)
                {
                    <MudButton Variant="Variant.Text" Style="text-transform:none" Color="Color.Secondary" OnClick="() => SetWantToUseAuthenticator(true)">
                        Or, use an authenticator
                    </MudButton>
                }

                <!-- lengh test below is to avoid a minor UI issue of the Unlock button temporarily enabling while entering initial characters -->
                <MudButton Disabled="@(!isValid || unlockPasscodeModel.Passcode.Length < 2)" Class="mt-0" Variant="Variant.Filled" Color="Color.Primary" OnClick="async () => await OpenWallet()">Unlock</MudButton>
            }
            else
            {
                // TODO P2 could automatically start authentication
                <MudText>
                    @NumberAuthenticatorsLabel registered with this browser profile and KERI Auth. Press Unlock to authenticate with one of them.
                </MudText>
                <MudButton Class="mt-0" Variant="Variant.Filled" Color="Color.Primary" OnClick="async () => await OpenWallet()">Unlock</MudButton>
                <MudButton Variant="Variant.Text" Style="text-transform:none" Color="Color.Secondary" OnClick="() => SetWantToUseAuthenticator(false)">
                    Or, use your passcode
                </MudButton>
            }
            <MudText Style="color: var(--mud-palette-action-disabled);"><span style="font-variant: small-caps; font-size:larger;">KeriAuth</span> locks after @AppConfig.IdleTimeoutMins minutes of inactivity</MudText>
        </MudStack>
    </div>
    <MudStack Row="true" class="bt-button-tray">
    </MudStack>
</div>

@code {
    // fields
    private bool isValid;
    MudForm? form;
    private string[] errors = { };
    private PasscodeModel unlockPasscodeModel = new PasscodeModel();
    private MudTextField<string>? passcodeField;
    private string openWalletError = string.Empty;
    private KeriaConnectConfig? keriaConnectConfig;

    // properties
    RegisteredAuthenticators RAS { get; set; } = new RegisteredAuthenticators();
    bool WantsToUseAuthenticator { get; set; } = true; // TODO P2 should remember setting this on the chrome.storage.local, since this desire may be different from machine to machine

    // reactive properties
    string NumberAuthenticatorsLabel => RAS.Authenticators.Count switch
    {
        0 => "No authenticators are",
        1 => "1 authenticator is",
        _ => $"{RAS.Authenticators.Count} authenticators are"
    };
    bool CanUseAuthenticator => RAS.Authenticators.Any();
    bool ShouldUseAuthenticator => CanUseAuthenticator && WantsToUseAuthenticator;

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation("OnInitializedAsync");

        // Get the KeriaConnectConfig
        var res = await storageService.GetItem<KeriaConnectConfig>();
        if (res.IsFailed || res.Value is null)
        {
            throw new Exception("Failed to get KeriaConnectConfig");
        }
        keriaConnectConfig = res.Value;

        // Although we should already be unauthenticated, ensure we are, e.g. in case of a refresh or navigating back
        if (stateService.GetState() != IStateService.States.Unauthenticated)
        {
            await stateService.Unauthenticate();
        }

        // check if there are already registeredAuthenticators
        var jsonRAs = await webExtensionsApi!.Storage.Sync.Get("registeredAuthenticators");
        if (jsonRAs.TryGetProperty("authenticators", out JsonElement registeredAuthenticators)
            && registeredAuthenticators.ValueKind == JsonValueKind.Object)
        {
            logger.LogInformation("OnInitializedAsync found and parsed registeredAuthenticators {r}", registeredAuthenticators);
            RAS = registeredAuthenticators.Deserialize<RegisteredAuthenticators>() ?? RAS;
            StateHasChanged();
            if (ShouldUseAuthenticator)
            {
                // assume the user will want to use a registered if available
                WantsToUseAuthenticator = true;
            }
        } else
        {
            logger.LogInformation("OnInitializedAsync did not find registeredAuthenticators");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (!ShouldUseAuthenticator)
            {
                await passcodeField!.FocusAsync();
            }
        }
    }

    async Task SetWantToUseAuthenticator(bool b)
    {
        WantsToUseAuthenticator = b;
    }

    private async Task SelectAllText()
    {
        await Task.Delay(1); // minor delay to ensure the focus event completes
        if (passcodeField is not null)
            await passcodeField.SelectAsync();
    }

    private async Task HandleKeyDown(KeyboardEventArgs args)
    {
        if (args.CtrlKey && args.Key == "`")
        {
            await OpenWalletWithPasscode("Ap31Xt-FGcNXpkxmBYMQn"); // TODO P2 remove example password for testing
        }
        if (args.Key == "Enter")
        {
            await OpenWallet();
        }
    }

    private async Task OpenWallet()
    {
        if (unlockPasscodeModel.Passcode is not null)
            await OpenWalletWithPasscode(unlockPasscodeModel.Passcode);
    }

    // TODO P3 DRY with ConfigureView
    private class PasscodeModel
    {
        [Required]
        [StringLength(21, ErrorMessage = "Passcode must be 21 characters", MinimumLength = 21)]
        [DataType(DataType.Password)]
        public string Passcode { get; set; } = "";
    }

    private async Task OpenWalletWithPasscode(string password)
    {
        var currentState = stateService.GetState();
        if (currentState != IStateService.States.Unauthenticated)
        {
            // TODO P3: This should not happen. Log and handle better
            logger.LogWarning($"Unexpected AppState {currentState}");
            await stateService.Initialize();
            await stateService.Configure();
        }

        openWalletError = String.Empty;

        if (string.IsNullOrEmpty(password) || password.Length != 21)
        {
            snackbar.Add("Invalid passcode. Should be 21 characters.", Severity.Error);
            return;
        }
        if (keriaConnectConfig is null
            || !keriaConnectConfig.IsConfigured()
            || keriaConnectConfig.AdminUrl is null)
        {
            throw new InvalidOperationException("KeriaConnectConfig not configured");
        }

        if (GetNumberFromHash.HashInt(password) == keriaConnectConfig.PasscodeHash)
        {
            await webExtensionsApi.Storage.Session.Set(new { passcode = password });
            await webExtensionsApi.Runtime.SendMessage(new { action = "resetInactivityTimer" });
            await stateService.Authenticate(false);
            // logger.LogWarning("returned from Authenticate. pausing...");
            var connectRes = await signifyClientService.Connect(keriaConnectConfig.AdminUrl, password, keriaConnectConfig.BootUrl, false);
            if (connectRes is null || connectRes.IsFailed)
            {
                openWalletError = "Could not connect to KERI Agent";
                snackbar.Add(openWalletError, Severity.Error);
                logger.LogError(openWalletError);
            }
            else
            {
                logger.LogInformation("Connected to KERI Agent");
                await stateService.ConfirmConnected();
            }
            // Stop showing spinner
            navManager.NavigateTo(RouteToIndex);
            return;
        }
        else
        {
            openWalletError = "KERI Auth was not configured with this passcode on this browser profile.";
            snackbar.Add(openWalletError, Severity.Error);
            await passcodeField!.SelectAsync();
            return;
        }
    }
}