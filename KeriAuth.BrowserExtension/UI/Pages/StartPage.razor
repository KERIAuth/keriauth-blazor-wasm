@page "/Start"

@using KeriAuth.BrowserExtension.Helper
@using KeriAuth.BrowserExtension.Models
@using KeriAuth.BrowserExtension.Services
@using KeriAuth.BrowserExtension
@using KeriAuth.BrowserExtension.UI.Components
@using KeriAuth.BrowserExtension.Services.SignifyService
@using KeriAuth.BrowserExtension.Services.SignifyService.Models
@using static KeriAuth.BrowserExtension.Helper.PreviousPage
@using static KeriAuth.BrowserExtension.AppConfig;
@using static KeriAuth.BrowserExtension.Helper.UIHelper;
@using static KeriAuth.BrowserExtension.Services.SignifyService.SignifyServiceConfig
@using FluentResults
@using JsBind.Net
@using JsBind.Net.Configurations
@using System.Diagnostics;
@using System.Text.Json;
@using System.Text.Json.Nodes
@using Blazor.BrowserExtension
@using Microsoft.AspNetCore.WebUtilities
@using System.Web
@using WebExtensions.Net
@using WebExtensions.Net.Runtime
@using Microsoft.AspNetCore.Components.WebAssembly.Hosting
@using JsonSerializer = System.Text.Json.JsonSerializer
@using static System.Net.WebRequestMethods;
@using System.ComponentModel.DataAnnotations
@using System.Linq;
@using System.Text;
@using System.Security.Cryptography;

@inject IPreferencesService preferencesService
@inject IStorageService storageService
@inject IStateService stateService
@inject IExtensionEnvironmentService extensionEnvironmentService
@inject ILogger<StartPage> logger
@inject HttpClient http
@inject NavigationManager navManager
@inject IJSRuntime js
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject ISignifyClientService signifyClientService
@inject ISnackbar snackbar

<!--
<MudContainer id="@this.GetType().Name" Class="bt-body-page">
    <MudPaper Class="d-flex justify-content-center align-items-center full-page" Style="width:100%; height:100%">
        <MudProgressCircular Color="Color.Success" Size="MudBlazor.Size.Medium" />
    </MudPaper>
</MudContainer>
-->
@code {
    // TODO P2 Fold this StartPage into IndexPage, since IndexPage is always called but is currently not useful.

    private WebExtensionsApi? webExtensionsApi;
    string? initialUriQuery;
    private static readonly KeriaConnectConfig defaultKeriaConnectConfig = new KeriaConnectConfig(AppConfig.DefaultKeriaConnectAlias, AppConfig.DefaultKeriaAdminUrl, AppConfig.DefaultKeriaBootUrl, 0);
    private KeriaConnectConfig? keriaConnectConfig;

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation($"OnInitializedAsync");
        // await base.OnInitializedAsync();




        // Get the initialUriQuery
        initialUriQuery = extensionEnvironmentService.InitialUriQuery;

        
        
        webExtensionsApi = new WebExtensionsApi(jsRuntimeAdapter);
        // TODO P2 Alternate way to get initialUriQuery, but the following doesn't return what is expected?
        /*
        var extensionContexts = await webExtensionsApi.Runtime.GetContexts(new ContextFilter());
        var extensionContext = extensionContexts.FirstOrDefault();
        if (extensionContext is null)
        {
            logger.LogWarning($"No extension context?");
        }
        else
        {
            logger.LogInformation("extensionContext: origin: {e} context: {c}", extensionContext.DocumentOrigin, extensionContext.ToString());
            string documentUrl = extensionContext!.DocumentUrl;
            if (string.IsNullOrEmpty(documentUrl))
            {
                logger.LogWarning($"No documentUrl?");
            }
            else
            {
                Uri uri = new Uri(documentUrl);
                if (uri is null)
                {
                    logger.LogWarning($"No extension Uri?");
                }
                else
                {
                    initialUriQuery = uri.OriginalString;
                    // initialUriQuery = extensionEnvironmentService.InitialUriQuery;
                    logger.LogInformation($"Chrome URI query: {initialUriQuery}");
                }
            }
        }
        */

        // Get the onboardState from storage then route to the appropriate onboarding views if needed
        var res = await storageService.GetItem<OnboardState>();
        logger.LogInformation("OnboardStateRes: {r}", res.Value);
        OnboardState? onboardState;
        if (res.IsFailed || res.Value is null)
        {
            onboardState = new OnboardState();
            await storageService.SetItem<OnboardState>(onboardState);
        }
        else
        {
            onboardState = res.Value;
        }

        // Onboard if needed
        if (!onboardState.IsInstallOnboarded())
        {
            if (!onboardState.HasAcknowledgedInstall)
            {
                navManager.NavigateTo(RouteToWelcome);
                return;
            }

            if (!onboardState.HasAcknowledgedNewVersion)
            {
                navManager.NavigateTo(RouteToNewRelease);
                return;
            }

            if (onboardState.PrivacyAgreedHash != AppConfig.PrivacyHash || onboardState.TosAgreedHash != AppConfig.PrivacyHash)
            {
                navManager.NavigateTo(RouteToTerms);
                return;
            }
        }

        // Now that we know install is onboarded, get the configState from storage and route to ConfigureView if needed
        var res2 = await storageService.GetItem<KeriaConnectConfig>();
        if (res2.IsFailed || res2.Value is null)
        {
            keriaConnectConfig = defaultKeriaConnectConfig;
            await storageService.SetItem<KeriaConnectConfig>(keriaConnectConfig);
        }
        else
        {
            keriaConnectConfig = res2.Value;
        }
        if (!keriaConnectConfig.IsConfigured())
        {
            navManager.NavigateTo(RouteToConfigure);
            return;
        }

        // Now that we know the KERIA connection is configured, get the current AppState and route to the appropriate page
        var currentAppState = stateService.GetState();
        logger.LogInformation($"currentAppState: {currentAppState}");
        logger.LogInformation($"Chrome URI query: {initialUriQuery}");
        var initialUriQuery2 = HttpUtility.UrlDecode(initialUriQuery);
        logger.LogInformation($"Chrome URI query decoded: {initialUriQuery2}");

        // If the query is percent-encoded multiple times, consider decoding it in a loop until it doesn't change:
        /*
        string decodedQuery = initialUriQuery;
    string lastDecodedQuery;
    do
    {
    lastDecodedQuery = decodedQuery;
    decodedQuery = HttpUtility.UrlDecode(decodedQuery);
    } while (decodedQuery != lastDecodedQuery);
         */


        await HandleAppStateAsync(currentAppState, initialUriQuery2);
    }


    protected override async Task OnParametersSetAsync()
    {
        logger.LogInformation("OnParametersSetAsync");

        var initialUriQuery2 = HttpUtility.UrlDecode(initialUriQuery);
        logger.LogInformation($"Chrome URI query decoded: {initialUriQuery2}");

        // TODO P1 Process query parameters if needed
        // ...

        await base.OnParametersSetAsync();
    }

    /*
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
    }
    */

    async Task HandleAppStateAsync(IStateService.States currentAppState, string? initialUriQuery2)
    {
        logger.LogWarning("HandleAppStateAsync: currentAppState {a} and query {q}", currentAppState.ToString(), initialUriQuery2);
        switch (currentAppState)
        {
            case IStateService.States.Unconfigured:
                // get the app into a known state
                await stateService.Configure();
                navManager.NavigateTo(RouteToUnlock);
                return;

            case IStateService.States.Unauthenticated:
                // Check if there is a recently CachedPasscode, and if so, use it
                var passcodeElement = await webExtensionsApi!.Storage.Session.Get("passcode");
                if (passcodeElement.TryGetProperty("passcode", out JsonElement passcodeElement2) && passcodeElement2.ValueKind == JsonValueKind.String)
                {
                    var passcode = passcodeElement2.GetString();
                    // logger.LogWarning("passcode is {1}", passcode);

                    if (!string.IsNullOrEmpty(passcode) && passcode.Length == 21)
                    {
                        logger.LogWarning("attempting to Authenticate with cached passcode...");
                        await webExtensionsApi.Runtime.SendMessage(new { action = "resetInactivityTimer" });

                        // TODO P2 refactor this section onto the ConnectingPage?  RouteToConnecting, so the extension without a KERIA connection might still be useful
                        string? adminUrl = keriaConnectConfig?.AdminUrl;
                        if (keriaConnectConfig is null || adminUrl is null)
                        {
                            throw new Exception("KeriaConnectConfig or its AdminUrl is null");
                        }
                        var isConnectedRes = await signifyClientService.Connect(adminUrl, passcode, keriaConnectConfig.BootUrl, false);
                        if (isConnectedRes is null || isConnectedRes.IsFailed || !isConnectedRes.Value)
                        {
                            // could not connect to KERI Agent Service
                            logger.LogWarning("connection failed? so removing CachedPasscode");
                            await webExtensionsApi.Storage.Session.Remove("passcode");
                            var openWalletError = "Could not connect to KERI Agent";
                            // TODO P2 check if snackbar host is still in each of the layouts
                            snackbar.Add(openWalletError, Severity.Error);
                            logger.LogError("Error connecting to KERI Agent Service: {w}", openWalletError);
                            var currentAppState4 = stateService.GetState();
                            await HandleAppStateAsync(currentAppState4, initialUriQuery2);
                            return;
                        }
                        else
                        {
                            await stateService.Authenticate(false);
                            logger.LogInformation("Connected to KERI Agent Service");
                            await stateService.ConfirmConnected();
                            var currentAppState3 = stateService.GetState();
                            await HandleAppStateAsync(currentAppState3, initialUriQuery2);
                            return;
                        }
                    }
                    else
                    {
                        logger.LogWarning("Invalid passcode was cached. Clearing.");
                        await App.LockApp();
                        // Note, the above will reactively cause a NavigateTo page
                        return;
                    }
                }
                else
                {
                    logger.LogWarning("TMP 4 TMP");
                    navManager.NavigateTo(RouteToUnlock);
                    return;
                }

            case IStateService.States.AuthenticatedConnected:
                // TODO P2 Ugly parsing. Define and parse this into a Record, and/or base64 encode.
                if (QueryHelpers.ParseQuery(initialUriQuery2).TryGetValue("message", out var message))
                {
                    logger.LogInformation("Chrome URI query message decoded2: {m}", message.ToString());

                    if (QueryHelpers.ParseQuery(initialUriQuery2).TryGetValue("origin", out var encodedOrigin))
                    {
                        if (encodedOrigin.FirstOrDefault() is null)
                        {
                            logger.LogError("Encoded origin not found in decodedMsg: {dm}", initialUriQuery);
                        }
                        else
                        {
                            // logger.LogInformation("Origin page parameter escaped: {origin}", encodedOrigin);
                            var encodedOrigin2 = HttpUtility.UrlEncode(encodedOrigin.FirstOrDefault());
                            logger.LogInformation("Origin page parameter encoded: {origin}", encodedOrigin2);

                            // TODO P3 popupType should be an enum
                            if (QueryHelpers.ParseQuery(initialUriQuery2).TryGetValue("popupType", out var popupType))
                            {
                                logger.LogInformation("popupType: {p}", popupType.ToString());
                                switch (popupType.ToString())
                                {
                                    // TODO P3 popupTypes should be an enum
                                    case "SignRequest":
                                        navManager.NavigateTo(RouteToRequestSign + encodedOrigin2);
                                        return;
                                    case "SelectAuthorize":
                                        navManager.NavigateTo(RouteToRequestSignIn + encodedOrigin2);
                                        return;
                                    default:
                                        throw new Exception($"Unexpected popupType {popupType}");
                                }
                            }
                            else
                            {
                                logger.LogInformation("No popupType found in UriQuery");
                            }
                        }

                    }
                }
                else
                {
                    logger.LogError("Encoded origin not found in decodedMsg: {dm}", initialUriQuery2);
                }
                navManager.NavigateTo(RouteToHome);
                return;
            case IStateService.States.AuthenticatedDisconnected:
            // TODO P2 show progress connecting and handle issues
            // For now, just wait...
            case IStateService.States.Initializing:
                logger.LogInformation("waiting for initialization to complete...");
                await Task.Delay(100);
                var currentAppState2 = stateService.GetState();
                await HandleAppStateAsync(currentAppState2, initialUriQuery2);
                return;
            default:
                throw new Exception($"Unexpected AppState {currentAppState}");
        }
    }
}