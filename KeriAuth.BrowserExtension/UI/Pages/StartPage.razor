@page "/Start"

@using KeriAuth.BrowserExtension.Helper
@using KeriAuth.BrowserExtension.Models
@using KeriAuth.BrowserExtension.Services
@using KeriAuth.BrowserExtension
@using KeriAuth.BrowserExtension.UI.Components
@using KeriAuth.BrowserExtension.Services.SignifyService
@using KeriAuth.BrowserExtension.Services.SignifyService.Models
@using static KeriAuth.BrowserExtension.Helper.PreviousPage
@using static KeriAuth.BrowserExtension.AppConfig;
@using static KeriAuth.BrowserExtension.Helper.UIHelper;
@using static KeriAuth.BrowserExtension.Services.SignifyService.SignifyServiceConfig
@using FluentResults
@using JsBind.Net
@using JsBind.Net.Configurations
@using System.Diagnostics;
@using System.Text.Json;
@using System.Text.Json.Nodes
@using Blazor.BrowserExtension
@using Microsoft.AspNetCore.WebUtilities
@using System.Web
@using WebExtensions.Net
@using WebExtensions.Net.Runtime
@using Microsoft.AspNetCore.Components.WebAssembly.Hosting
@using JsonSerializer = System.Text.Json.JsonSerializer
@using static System.Net.WebRequestMethods;
@using System.ComponentModel.DataAnnotations
@using System.Linq;
@using System.Text;
@using System.Security.Cryptography;

@inject IPreferencesService preferencesService
@inject IStorageService storageService
@inject IStateService stateService
@inject IExtensionEnvironmentService extensionEnvironmentService
@inject ILogger<StartPage> logger
@inject HttpClient http
@inject NavigationManager navManager
@inject IJSRuntime js
@inject IJsRuntimeAdapter jsRuntimeAdapter
@inject ISignifyClientService signifyClientService
@inject ISnackbar snackbar

<div id="@this.GetType().Name" class="bt-body-page">
    <div class="d-flex gap-3 bt-main" style="justify-content:center;">
        Starting...
    </div>
</div>

@code {
    private WebExtensionsApi? webExtensionsApi;
    string? initialUriQuery;
    private static readonly KeriaConnectConfig defaultKeriaConnectConfig = new KeriaConnectConfig(AppConfig.DefaultKeriaConnectAlias, AppConfig.DefaultKeriaAdminUrl, AppConfig.DefaultKeriaBootUrl, 0);
    private KeriaConnectConfig? keriaConnectConfig;

    protected override async Task OnInitializedAsync()
    {
        logger.LogInformation($"OnInitializedAsync");
        await base.OnInitializedAsync();
        webExtensionsApi = new WebExtensionsApi(jsRuntimeAdapter);
        // See also OnParametersSetAsync for additional initialization occuring on every navigation to this view
        initialUriQuery = extensionEnvironmentService.InitialUriQuery;
    }

    protected override async Task OnParametersSetAsync()
    {
        logger.LogInformation("OnParametersSetAsync");
        logger.LogInformation($"OnParametersSetAsync: Chrome URI query: {initialUriQuery}");
        await base.OnParametersSetAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        logger.LogWarning("OnAfterRenderAsync");
        await base.OnAfterRenderAsync(firstRender);


        // Get the onboardState from storage then route to the appropriate onboarding views if needed
        var res = await storageService.GetItem<OnboardState>();
        logger.LogWarning("OnParametersSetAsync: OnboardStateRes: {r}", res);
        OnboardState? onboardState;
        if (res.IsFailed || res.Value is null)
        {
            onboardState = new OnboardState();
            await storageService.SetItem<OnboardState>(onboardState);
        }
        else
        {
            onboardState = res.Value;
        }


        // Onboard if needed
        if (!onboardState.IsInstallOnboarded())
        {
            if (!onboardState.HasAcknowledgedInstall)
            {
                navManager.NavigateTo(RouteToWelcome);
                return;
            }

            if (!onboardState.HasAcknowledgedNewVersion)
            {
                navManager.NavigateTo(RouteToNewRelease);
                return;
            }

            // TODO P3 check the actual current hashes in AppConfig and navigate to Terms if not equal

            if (onboardState.PrivacyAgreedHash != AppConfig.PrivacyHash || onboardState.TosAgreedHash != AppConfig.PrivacyHash)
            {
                navManager.NavigateTo(RouteToTerms);
                return;
            }
        }


        // Now that we know install is onboarded, get the configState from storage and route to ConfigureView if needed
        var res2 = await storageService.GetItem<KeriaConnectConfig>();
        if (res2.IsFailed || res2.Value is null)
        {
            keriaConnectConfig = defaultKeriaConnectConfig;
            await storageService.SetItem<KeriaConnectConfig>(keriaConnectConfig);
        }
        else
        {
            keriaConnectConfig = res2.Value;
        }
        if (!keriaConnectConfig.IsConfigured())
        {
            navManager.NavigateTo(RouteToConfigure);
            return;
        }

        // Now that we know the KERIA connection is configured, get the current AppState and route to the appropriate page
        var currentAppState = stateService.GetState();
        logger.LogInformation($"currentAppState: {currentAppState}");
        logger.LogInformation($"Chrome URI query: {initialUriQuery}");
        var initialUriQuery2 = HttpUtility.UrlDecode(HttpUtility.UrlDecode(HttpUtility.UrlDecode(initialUriQuery)));
        logger.LogInformation($"Chrome URI query decoded 2: {initialUriQuery2}");
        // TODO P1 figure out why StateHasChanged is needed here. Causing UI delays
        StateHasChanged();
        switch (currentAppState)
        {
            case IStateService.States.Unconfigured:
                // get the app into a known state
                await stateService.Configure();
                navManager.NavigateTo(RouteToUnlock);
                return;

            case IStateService.States.Unauthenticated:
                // Check if there is a recently CachedPasscode, and if so, use it
                var passcodeElement = await webExtensionsApi!.Storage.Session.Get("passcode");

                if (passcodeElement.TryGetProperty("passcode", out JsonElement passcodeElement2) && passcodeElement2.ValueKind == JsonValueKind.String)
                {
                    var passcode = passcodeElement2.GetString();
                    logger.LogWarning("passcode is {1}", passcode);

                    if (!string.IsNullOrEmpty(passcode) && passcode.Length == 21)
                    {
                        logger.LogWarning("attempting to Authenticate with cached passcode...");
                        await webExtensionsApi.Runtime.SendMessage(new { action = "resetInactivityTimer" });


                        // TODO P2 refactor this section into ConnectingPage?  RouteToConnecting, so the extension without a KERIA connection might still be useful
                        string adminUrl = keriaConnectConfig.AdminUrl!;
                        var isConnectedRes = await signifyClientService.Connect(adminUrl, passcode, keriaConnectConfig.BootUrl, false);
                        if (isConnectedRes is null || isConnectedRes.IsFailed || !isConnectedRes.Value)
                        {
                            // could not connect to KERI Agent Service
                            logger.LogWarning("connection failed? so removing CachedPasscode");
                            await webExtensionsApi.Storage.Session.Remove("passcode");
                            var openWalletError = "Could not connect to KERI Agent";
                            // TODO P2 check if snackbar host is still in each of the layouts
                            snackbar.Add(openWalletError, Severity.Error);
                            logger.LogError(openWalletError);
                            logger.LogWarning("TMP 1 TMP");
                            navManager.NavigateTo(RouteToStart);
                            return;
                        }
                        else
                        {
                            await stateService.Authenticate(false);
                            logger.LogInformation("Connected to KERI Agent");
                            await stateService.ConfirmConnected();
                            logger.LogWarning("TMP 2 TMP");
                            // TODO P0 tmp.  Which one?
                            StateHasChanged(); // navManager.NavigateTo(RouteToStart);
                            return;
                        }
                    }
                    else
                    {
                        logger.LogWarning("Invalid passcode was cached. Clearing.");
                        await App.LockApp(); // this will Route
                        return;
                    }
                }
                else
                {
                    logger.LogWarning("TMP 4 TMP");
                    navManager.NavigateTo(RouteToUnlock);
                    return;
                }

            case IStateService.States.AuthenticatedDisconnected:
                navManager.NavigateTo(RouteToConnecting);
                return;

            case IStateService.States.AuthenticatedConnected:
                // TODO P2 Ugly parsing. Define and parse this into a Record
                if (QueryHelpers.ParseQuery(initialUriQuery2).TryGetValue("message", out var message))
                {
                    logger.LogInformation("Chrome URI query message decoded2: {m}", message.ToString());

                    // TODO P3 "origin" should be an enum
                    if (QueryHelpers.ParseQuery(initialUriQuery2).TryGetValue("origin", out var encodedOrigin))
                    {
                        if (encodedOrigin.FirstOrDefault() is null)
                        {
                            logger.LogError("Encoded origin not found in decodedMsg: {dm}", initialUriQuery);
                        }
                        else
                        {
                            // logger.LogInformation("OnParametersSetAsync: Origin page parameter escaped: {origin}", encodedOrigin);
                            var encodedOrigin2 = HttpUtility.UrlEncode(encodedOrigin.FirstOrDefault());
                            logger.LogInformation("Origin page parameter encoded: {origin}", encodedOrigin2);

                            // TODO P3 popupType should be an enum
                            if (QueryHelpers.ParseQuery(initialUriQuery2).TryGetValue("popupType", out var popupType))
                            {
                                logger.LogInformation("popupType: {p}", popupType.ToString());
                                switch (popupType.ToString())
                                {
                                    // TODO P3 popupTypes should be an enum
                                    case "SignRequest":
                                        navManager.NavigateTo(RouteToRequestSign + encodedOrigin2);
                                        return;
                                    case "SelectAuthorize":
                                        navManager.NavigateTo(RouteToRequestSignIn + encodedOrigin2);
                                        return;
                                    default:
                                        throw new Exception($"Unexpected popupType {popupType}");
                                }
                            }
                        }

                    }
                }
                else
                {
                    logger.LogError("Encoded origin not found in decodedMsg: {dm}", initialUriQuery2);
                }
                navManager.NavigateTo(RouteToHome);
                return;
            case IStateService.States.Initializing:
                logger.LogInformation("waiting for initialization to complete...");
                // TODO P0 Hack for timing issue here.  Need to be reactive to the state changing after Initializing?
                // await Task.Delay(1500);
                // navManager.NavigateTo(RouteToStart);
                // StateHasChanged();
                return;
            default:
                throw new Exception($"Unexpected AppState {currentAppState}");
        }
    }
}