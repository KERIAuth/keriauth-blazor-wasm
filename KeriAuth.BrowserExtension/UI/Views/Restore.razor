@page "/Restore"
@using KeriAuth.BrowserExtension
@using KeriAuth.BrowserExtension.Services
@using KeriAuth.BrowserExtension.Models
@using Microsoft.AspNetCore.Components
@using System.Text.Json
@using System.Diagnostics;
@using System.Text;
@using System.Text.Json.Serialization;
@using static KeriAuth.BrowserExtension.AppConfig;
@inject NavigationManager navManager
// inject IWalletService walletService
@inject IStateService stateService
@inject IStorageService storageService
@inject IJSRuntime js
@inject ILogger<Restore> Logger
@using static KeriAuth.BrowserExtension.Helper.PreviousPage

<div id="Restore" class="bt-body-page">
    <div class="d-flex gap-3 bt-main">
        <div class="bt-main-inside-scroll">
            <MudText Typo="Typo.h6">Restore Wallet</MudText>
            <MudText Typo="Typo.body1"></MudText>
            <MudForm @ref="form" @bind-IsValid="@success" @bind-Errors="@errors">
                <MudTextField T="string"
                              Lines="9"
                              Immediate="true"
                              Required @ref="json" InputType="InputType.Text"
                              Validation="@(new Func<string, string?>(ParseContent))"
                              Label="Paste backup content here">
                </MudTextField>
            </MudForm>
        </div>
    </div>
    <MudStack Row="true" class="bt-button-tray">
        <MudIconButton Icon="@Icons.Material.Filled.ArrowBackIosNew" Variant="Variant.Text" OnClick='@( async () => await GoBack(js) )' Class="justify-start" />
        <MudSpacer />
        <MudButton Disabled="@(!success)" OnClick="async () => await RestoreWallet()" Color="Color.Primary" Variant="Variant.Filled">Restore</MudButton>
    </MudStack>

</div>

@code {
    MudForm? form;
    string[] errors = { };
    MudTextField<string>? json;
    bool success;

    private string? ParseContent(string arg)
    {
        if (!string.IsNullOrEmpty(arg))
        {
            try
            {
                var _ = JsonSerializer.Deserialize<Backup>(arg);
                return null;
            }
            catch (Exception)
            {
                return "Unable to deserialize Wallet";
            }
        }
        else
        {
            return "Paste valid json";
        }
    }

    private static Dictionary<string, Type> typeLookup = new()
    {
        { "WALLETENCRYPTED", typeof(WalletEncrypted) },
        { "PREFERENCES", typeof(Preferences) },
        // { "CHATMESSAGES", typeof(Models.ChatService.ChatMessages) },
        // { "CONTACTS", typeof(Models.ContactService.Contacts) },
        // { "CREDENTIALS", typeof(Models.MediatorService.IssueCredentials.Credentials) },
        // { "MEDIATORCONTACTS", typeof(Models.MediatorService.MediatorContacts) },
        // { "PEERDIDSECRETS", typeof(PeerDidSecrets) },
        // { "PRESENTATIONREQUESTS", typeof(Models.MediatorService.Presentations.PresentationRequests) },
        // { "CREDENTIALOFFERS", typeof(Models.MediatorService.IssueCredentials.CredentialOffers) },
        // { "VERIFICATIONREQUESTS", typeof(Models.MediatorService.Presentations.VerificationRequests) },
        // { "PROBLEMREPORTS", typeof(Models.MediatorService.ProblemReports) },
    };

    // TODO P2 this code should move into storageService or a BackupAndRestoreService.
    private async Task RestoreWallet()
    {
        try
        {
            Debug.Assert(json is not null);
            Debug.Assert(json.Value is not null);
            var jsonDocument = JsonDocument.Parse(json.Value);
            var rootElement = jsonDocument.RootElement;
            Logger.LogInformation($"Found {rootElement.ValueKind}");
            if (rootElement.ValueKind != JsonValueKind.Object)
            {
                throw new Exception("Expected object");
            };

            // convert to a dictionary, so we can modify if needed
            var rootElementDictionary = rootElement.EnumerateObject().ToDictionary(x => x.Name, x => x.Value);

            var rootElementDictionaryCopy = rootElementDictionary;
            foreach (var keyValuePair in rootElementDictionaryCopy)
            {
                var key = keyValuePair.Key;
                var value = keyValuePair.Value;
                Logger.LogInformation($"Found {key}");

                // Any special handling for properties that need to be updated?

                switch (key.ToUpperInvariant())
                {
                    case "BACKUP":
                        var backup = JsonSerializer.Deserialize<BackupVersion>(value.GetRawText());
                        Debug.Assert(backup is not null);
                        Logger.LogInformation($"Backup details: {backup.VersionName} {backup.Version} {backup.DateTime}");
                        // remove this so it isn't restored
                        rootElementDictionary.Remove(key);
                        break;
                    case "APPSTATE":
                    case "WALLETLOGIN":
                        Logger.LogInformation($"Found and ignoring {key}");
                        rootElementDictionary.Remove(key);
                        break;
                    default:
                        // nothing special to do
                        break;
                }
            }




            var options = new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = false,
                    Converters = {
                        new JsonStringEnumConverter(JsonNamingPolicy.CamelCase),
                        // new IDataJsonConverter()
                    }
                };

            // convert back to a json element
            string jsonString = JsonSerializer.Serialize(rootElementDictionary);
            using JsonDocument jsonDocument2 = JsonDocument.Parse(jsonString);
            await storageService.Clear();
            foreach (var property in jsonDocument2.RootElement.EnumerateObject())
            {
                Logger.LogInformation($"Restoring {property.Name}");
                // TODO P2 DRY this up.  Instantiating the classes here is a code smell.
                var key = property.Name.ToUpperInvariant();
                var value = property.Value.GetRawText();
                switch (key)
                {
                    case "WALLETENCRYPTED":
                        var walletEncrypted = JsonSerializer.Deserialize<WalletEncrypted>(value, options);
                        if (walletEncrypted is not null)
                        {
                            await storageService.SetItem(walletEncrypted);
                        }
                        break;
                    case "PREFERENCES":
                        var preferences = JsonSerializer.Deserialize<Preferences>(value, options);
                        if (preferences is not null)
                        {
                            await storageService.SetItem(preferences);
                        }
                        break;
                    default:
                        throw new Exception($"Unexpected property key {key}");
                }
            }

            await stateService.Unauthenticate();
            await storageService.RemoveItem<AppState>();
            await storageService.RemoveItem<WalletLogin>();
            navManager.NavigateTo(RouteToStart);
            return;
        }

        catch (Exception ex)
        {
            // TODO P4 prevent handle null exceptions above, bad JSON, etc.
            throw ex;
        }
    }
 }

