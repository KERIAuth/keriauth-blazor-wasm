# Blazor WASM Startup Flows in KERI Auth Browser Extension

This document explains how the Blazor WebAssembly runtime initializes in different contexts within the browser extension architecture.

## Overview

The KERI Auth browser extension uses **Blazor.BrowserExtension** to run Blazor WASM in two distinct runtime contexts:

1. **BackgroundWorker Context** - Service worker running in background
2. **App Context** - UI running in popup, tab, or sidepanel

**CRITICAL: These are SEPARATE Blazor WASM runtime instances** with separate `IJSRuntime` instances, separate DI containers, and separate service state.

---

## Flow 1: BackgroundWorker Context (Service Worker)

### Trigger
Chrome loads the extension and starts the service worker defined in `manifest.json`:

```json
"background": {
  "service_worker": "content/BackgroundWorker.js",
  "type": "module"
}
```

### Startup Sequence

```
manifest.json
  ↓
content/BackgroundWorker.js (generated by Blazor.BrowserExtension.Build)
  ↓ imports BackgroundWorkerRunner.js
  ↓
BackgroundWorkerRunner.js (from Blazor.BrowserExtension)
  ↓ loads .NET runtime
  ↓ calls app.ts beforeStart() hook
  ↓
app.ts beforeStart(mode='Background')
  ↓ Detects mode === 'Background'
  ↓ ✅ Loads BackgroundWorker modules:
  ↓   - import('./scripts/esbuild/signifyClient.js')
  ↓   - import('./scripts/es6/storageHelper.js')
  ↓   - import('./scripts/es6/PermissionsHelper.js')
  ↓   - import('./scripts/es6/PortMessageHelper.js')
  ↓   - import('./scripts/es6/SwAppInterop.js')
  ↓ ✅ Modules cached in BackgroundWorker's runtime
  ↓ Sets up browser event listeners (chrome.action.onClicked, etc.)
  ↓ Returns control
  ↓
dotnet.js → blazor.webassembly.js
  ↓ initializes WASM runtime
  ↓
Program.cs (Main entry point)
  ↓ builder.UseBrowserExtension() detects Mode = Background
  ↓ builder.RootComponents.AddBackgroundWorker<BackgroundWorker>()
  ↓ registers services (AddSingleton, etc.)
  ↓ var host = builder.Build()
  ↓ Logs: "JavaScript modules pre-loaded by app.ts beforeStart hook"
  ↓
await host.RunAsync()
  ↓
BackgroundWorker.Main() method is invoked
  ↓ ✅ Modules already loaded and cached
  ↓ Registers browser event listeners via WebExtensions API
  ↓
BackgroundWorker is now running (with modules ready)
```

### What Gets Loaded

**In BackgroundWorker's IJSRuntime:**
- ✅ .NET runtime (dotnet.js)
- ✅ Blazor WASM framework (blazor.webassembly.js)
- ✅ JsBind.Net library
- ✅ WebExtensions.Net bindings
- ✅ app.ts (executed via beforeStart/afterStarted hooks)
- ✅ **ES6 JavaScript modules loaded by app.ts beforeStart()**
- ✅ **SignifyClientBinding fully functional**

**Files Loaded:**
- `content/BackgroundWorker.js` - Entry point (ES module)
- `content/Blazor.BrowserExtension/BackgroundWorkerRunner.js` - WASM bootstrapper
- `framework/dotnet.js` - .NET runtime
- `framework/blazor.webassembly.js` - Blazor framework
- `app.js` - Application hooks (beforeStart/afterStarted)
- `content/JsBind.Net/JsBind.Net.lib.module.js` - JsBind.Net library

**Loaded by app.ts beforeStart() in BackgroundWorker Context:**
- ✅ `scripts/esbuild/signifyClient.js` (SignifyClientBinding)
- ✅ `scripts/es6/storageHelper.js` (StorageService)
- ✅ `scripts/es6/PermissionsHelper.js` (Permission checks)
- ✅ `scripts/es6/PortMessageHelper.js` (Port messaging)
- ✅ `scripts/es6/SwAppInterop.js` (Service Worker/App communication)
- ❌ `scripts/es6/webauthnCredentialWithPRF.js` (Not needed in BackgroundWorker)

---

## Flow 2: App Context (Popup/Tab/Sidepanel)

### Trigger
User clicks extension icon, or extension opens a tab/sidepanel:

```typescript
// app.ts - beforeStart hook
chrome.action.onClicked.addListener(async (tab: chrome.tabs.Tab) => {
  // ... permission handling ...
  // Opens popup via index.html
});
```

Or directly navigating to `index.html?environment=popup` (or `tab`, `sidepanel`).

### Startup Sequence

```
index.html
  ↓ <script src="framework/blazor.webassembly.js"></script>
  ↓
blazor.webassembly.js
  ↓ loads .NET runtime
  ↓ calls app.ts hooks
  ↓
app.ts beforeStart(mode='Standard'/'Debug')
  ↓ Detects mode === 'Standard' or 'Debug'
  ↓ ✅ Loads App modules:
  ↓   - import('./scripts/esbuild/signifyClient.js')
  ↓   - import('./scripts/es6/storageHelper.js')
  ↓   - import('./scripts/es6/PermissionsHelper.js')
  ↓   - import('./scripts/es6/PortMessageHelper.js')
  ↓   - import('./scripts/es6/SwAppInterop.js')
  ↓   - import('./scripts/es6/webauthnCredentialWithPRF.js')
  ↓ ✅ Modules cached in App's runtime
  ↓ Returns control
  ↓
dotnet.js → WASM runtime initialization
  ↓
Program.cs (Main entry point)
  ↓ builder.UseBrowserExtension() detects Mode = Standard/Debug/Popup
  ↓ builder.Services.AddMudServices()
  ↓ builder.RootComponents.Add<App>("#app")
  ↓ builder.RootComponents.Add<HeadOutlet>("head::after")
  ↓ registers services (AddSingleton, etc.)
  ↓ var host = builder.Build()
  ↓ Logs: "JavaScript modules pre-loaded by app.ts beforeStart hook"
  ↓
await host.RunAsync()
  ↓
App.razor OnInitializedAsync() is invoked
  ↓ await extensionEnvironmentService.Initialize()
  ↓ await storageService.Initialize()
  ↓ await stateService.Initialize()
  ↓ await preferencesService.Initialize()
  ↓ ✅ All services can use modules (already cached)
  ↓ await appBwMessagingService.Initialize()
  ↓   ↓ Establishes port connection to BackgroundWorker
  ↓
App UI is rendered and interactive
```

### What Gets Loaded

**In App's IJSRuntime:**
- ✅ .NET runtime (dotnet.js)
- ✅ Blazor WASM framework (blazor.webassembly.js)
- ✅ MudBlazor UI components
- ✅ JsBind.Net library
- ✅ WebExtensions.Net bindings
- ✅ app.ts (executed via beforeStart/afterStarted hooks)
- ✅ **All ES6 JavaScript modules loaded by app.ts beforeStart()**
- ✅ **SignifyClientBinding fully functional**

**Files Loaded:**
- `index.html` - Entry point
- `framework/dotnet.js` - .NET runtime
- `framework/blazor.webassembly.js` - Blazor framework
- `app.js` - Application hooks
- `content/MudBlazor/MudBlazor.min.js` - UI library

**Loaded by app.ts beforeStart() in App Context:**
- ✅ `scripts/esbuild/signifyClient.js` (SignifyClientBinding)
- ✅ `scripts/es6/storageHelper.js` (StorageService)
- ✅ `scripts/es6/PermissionsHelper.js` (Permission checks)
- ✅ `scripts/es6/PortMessageHelper.js` (Port messaging)
- ✅ `scripts/es6/SwAppInterop.js` (AppBwMessagingService)
- ✅ `scripts/es6/webauthnCredentialWithPRF.js` (WebauthnService)

---

## Key Differences Between Contexts

| Aspect | BackgroundWorker Context | App Context |
|--------|-------------------------|-------------|
| **Entry Point** | `content/BackgroundWorker.js` (ES module) | `index.html` (HTML page) |
| **Blazor Component** | `BackgroundWorker.cs` (`Main()` method) | `App.razor` (`OnInitializedAsync()`) |
| **UI Framework** | None (headless) | MudBlazor |
| **Module Loading** | ✅ **SOLVED** - app.ts beforeStart() | ✅ **SOLVED** - app.ts beforeStart() |
| **IJSRuntime** | Separate instance #1 | Separate instance #2 |
| **DI Container** | Separate container #1 | Separate container #2 |
| **Service State** | Singleton state isolated to BW | Singleton state isolated to App |
| **Purpose** | Background processing, message routing | User interface, user interaction |

---

## ✅ SOLUTION IMPLEMENTED: Module Loading via app.ts beforeStart() Hook

### The Solution

JavaScript ES modules are now loaded by **`app.ts beforeStart()` hook** BEFORE Blazor starts, separately in each runtime context.

**Key Implementation:**

1. **app.ts beforeStart() is async** - Can await dynamic imports
2. **Runs separately in each context** - BackgroundWorker and App each get their own module cache
3. **Fail-fast** - If modules fail to load, Blazor startup is prevented
4. **Uses browser's native module system** - Modules cached automatically

**Code (app.ts):**

```typescript
export async function beforeStart(
    options: WebAssemblyStartOptions,
    extensions: Record<string, unknown>,
    blazorBrowserExtension: BrowserExtensionInstance
): Promise<void> {
    const mode = blazorBrowserExtension.BrowserExtension.Mode;

    if (mode === 'Background') {
        // Load BackgroundWorker modules
        await Promise.all([
            import('./scripts/esbuild/signifyClient.js'),
            import('./scripts/es6/storageHelper.js'),
            // ... other modules
        ]);
    } else if (mode === 'Standard' || mode === 'Debug') {
        // Load App modules (includes WebAuthn)
        await Promise.all([
            import('./scripts/esbuild/signifyClient.js'),
            import('./scripts/es6/webauthnCredentialWithPRF.js'),
            // ... other modules
        ]);
    }
}
```

### Why This Works

1. **beforeStart() executes in each runtime** - Both BackgroundWorker and App call it separately
2. **Modules load before C# starts** - No race conditions
3. **Browser caches modules** - C# imports are instant (from cache)
4. **Fail-fast on error** - Throwing in beforeStart() prevents Blazor startup

### C# Service Pattern (No Changes Required)

Services continue to use standard module import - now instant from cache:

```csharp
public class SignifyClientService {
    public async Task DoSomethingAsync() {
        // Import from browser cache (instant - already loaded by app.ts)
        var module = await _jsRuntime.InvokeAsync<IJSObjectReference>(
            "import", "./scripts/esbuild/signifyClient.js"
        );
        await module.InvokeVoidAsync("someMethod");
    }
}
```

### Benefits Over Previous Approaches

| Aspect | Old (JsModuleLoader in Program.cs) | New (app.ts beforeStart) |
|--------|-------------------------------------|--------------------------|
| **Context awareness** | ❌ Runs in one context only | ✅ Runs separately in each |
| **Timing** | ❌ After Blazor starts | ✅ Before Blazor starts |
| **Fail-fast** | ⚠️ Logs errors | ✅ Prevents startup |
| **Race conditions** | ❌ Possible | ✅ None |
| **Code complexity** | ❌ C# service + DI | ✅ Simple TypeScript |
| **Native caching** | ⚠️ Manual tracking | ✅ Browser handles it |

### Issues This Solves

**Before (BROKEN):**

```text
Web Page → Content Script → BackgroundWorker.HandleSignRequestAsync()
  ↓
await _signifyClientBinding.GetAIDs()
  ↓
❌ ERROR: "Could not find 'getAIDs' ('getAIDs' was undefined)"
```

**After (FIXED):**

```text
Web Page → Content Script → BackgroundWorker.HandleSignRequestAsync()
  ↓
await _signifyClientBinding.GetAIDs()
  ↓
✅ SUCCESS: Module loaded by app.ts beforeStart(), cached in BackgroundWorker's runtime
```

---

## ~~Solution Required~~ (DEPRECATED - SOLUTION IMPLEMENTED)

~~The following options were considered but NOT implemented. The solution above (app.ts beforeStart) was chosen instead.~~

### ~~Option A: Load Modules in BackgroundWorker.Main()~~ (NOT USED)
- Violates fail-fast principle
- Multiple services might race to load the same module
- Error detection happens late, during actual usage

### Option D: Defer BackgroundWorker Message Handling Until Modules Load

Queue incoming messages until module loading completes:

```csharp
private bool _modulesReady = false;
private readonly ConcurrentQueue<PendingMessage> _messageQueue = new();

public override void Main() {
    // Start module loading in background
    Task.Run(async () => {
        await LoadModulesAsync();
        _modulesReady = true;
        ProcessQueuedMessages();
    });

    // Register listeners that queue messages if modules not ready
    // ...
}
```

---

## Recommended Solution

**Hybrid Approach:**

1. **In Program.cs:** Only load modules in App context (current behavior)
2. **In BackgroundWorker.Main():** Start async module loading task with completion tracking
3. **In message handlers:** Check module readiness, queue or reject messages if not ready
4. **Use timeout:** Fail startup if modules don't load within 10 seconds

This provides fail-fast behavior while handling the async initialization challenge.

---

## app.ts Hooks Clarification

### beforeStart Hook
- **When:** Called BEFORE Blazor WASM runtime starts
- **Context:** Both BackgroundWorker and App contexts call this
- **Purpose:** Set up browser-level event listeners (chrome.action.onClicked, etc.)
- **Mode Detection:** Checks `blazorBrowserExtension.BrowserExtension.Mode`
  - `"Background"` → Sets up service worker event handlers
  - `"Standard"` / `"Debug"` → No special setup
- **Module Loading:** ❌ Does NOT load any JavaScript modules

### afterStarted Hook
- **When:** Called AFTER Blazor WASM runtime is fully initialized
- **Context:** Both BackgroundWorker and App contexts call this
- **Purpose:** Currently just logs "Blazor runtime ready"
- **Module Loading:** ❌ Does NOT load any JavaScript modules (despite what comments claim)

---

## Validation of User's Understanding

### User's Statement:
> "The manifest.json file has listeners including onStartup that may trigger its handler to load BackgroundWorker.js, which loads the .Net runtime, which loads Program.cs, which may utilize app.js, which then will load code compiled from BackgroundWorker.razor"

**Corrections:**

1. ✅ **Correct:** manifest.json defines service_worker as BackgroundWorker.js
2. ❌ **Incorrect:** onStartup is NOT in manifest.json - it's registered programmatically in BackgroundWorker.cs
3. ✅ **Correct:** BackgroundWorker.js loads .NET runtime
4. ✅ **Correct:** .NET runtime loads Program.cs
5. ✅ **Correct:** app.js (compiled from app.ts) hooks are called
6. ❌ **Terminology:** BackgroundWorker is a `.cs` file (C#), not `.razor` - it's a code-behind class, not a Blazor component

### User's Second Statement:
> "The action popup may trigger the event onAction that is handled by the BackgroundWorker.razor code, which triggers index.html to load, loading the .Net runtime, which loads Program.cs, which may utilize app.js, which then will load code compiled from App.razor."

**Corrections:**

1. ❌ **Incorrect:** Popup loading does NOT go through BackgroundWorker's code
2. ✅ **Correct:** Popup opening loads index.html directly
3. ✅ **Correct:** index.html loads .NET runtime via blazor.webassembly.js
4. ✅ **Correct:** Program.cs runs and detects Mode = Standard/Popup
5. ✅ **Correct:** app.js hooks are called
6. ✅ **Correct:** App.razor component is loaded and initialized
7. ❌ **Missing:** Popup and BackgroundWorker are SEPARATE runtimes that communicate via messaging

---

## Summary

The KERI Auth extension has **two independent Blazor WASM runtime instances**:

1. **BackgroundWorker Runtime** - Currently broken for module-dependent operations
2. **App Runtime** - Works correctly with all modules loaded

The critical issue is that `JsModuleLoader.LoadAllModulesAsync()` in `Program.cs` only affects whichever runtime context it executes in, and BackgroundWorker needs its own module loading implementation.

**Next Steps:**
1. Implement module loading in BackgroundWorker.Main() or equivalent lifecycle hook
2. Update misleading comments in BackgroundWorker.cs and app.ts
3. Refactor services to use IJsModuleLoader consistently (Issue #3)
4. Test that BackgroundWorker can successfully handle messages requiring SignifyClientBinding
