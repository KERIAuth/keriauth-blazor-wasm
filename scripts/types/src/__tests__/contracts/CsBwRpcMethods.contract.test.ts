/**
 * Contract tests for CSâ†’BW RPC methods.
 * These tests validate that TypeScript types match C# serialization.
 *
 * Fixtures are generated by Extension.Tests/Contracts/MessageContractFixtureGenerator.cs
 * Run `dotnet test --filter "GenerateAllFixtures"` to regenerate fixtures.
 */

import { describe, it, expect } from 'vitest';
import { readFileSync } from 'fs';
import { join } from 'path';
import {
    CsBwRpcMethods,
    isCsBwRpcMethod,
    BwCsMessageTypes,
    isBwCsMessageType
} from '../../CsBwRpcMethods.js';

// Path to C# generated fixtures
const FIXTURES_DIR = join(__dirname, '..', '..', '..', '..', '..', 'Extension.Tests', 'Contracts', 'Fixtures');

/**
 * Helper to load a JSON fixture file
 */
function loadFixture<T>(filename: string): T {
    const path = join(FIXTURES_DIR, filename);
    const content = readFileSync(path, 'utf-8');
    return JSON.parse(content) as T;
}

describe('CsBwRpcMethods Contract Tests', () => {
    describe('method constants match C# CsBwMessageTypes', () => {
        it('should match all method values from C# fixture', () => {
            // Load the fixture generated by C#
            const csharpMethods = loadFixture<Record<string, string>>('CsBwMethodTypes.json');

            // Verify each TypeScript constant matches the C# value
            expect(CsBwRpcMethods.Authorize).toBe(csharpMethods.Authorize);
            expect(CsBwRpcMethods.SelectAuthorizeAid).toBe(csharpMethods.SelectAuthorizeAid);
            expect(CsBwRpcMethods.SelectAuthorizeCredential).toBe(csharpMethods.SelectAuthorizeCredential);
            expect(CsBwRpcMethods.SignData).toBe(csharpMethods.SignData);
            expect(CsBwRpcMethods.SignRequest).toBe(csharpMethods.SignRequest);
            expect(CsBwRpcMethods.CreateDataAttestation).toBe(csharpMethods.CreateDataAttestation);
            expect(CsBwRpcMethods.GetCredential).toBe(csharpMethods.GetCredential);
            expect(CsBwRpcMethods.ConfigureVendor).toBe(csharpMethods.ConfigureVendor);
            expect(CsBwRpcMethods.SignifyExtension).toBe(csharpMethods.SignifyExtension);
            expect(CsBwRpcMethods.SignifyExtensionClient).toBe(csharpMethods.SignifyExtensionClient);
            expect(CsBwRpcMethods.GetSessionInfo).toBe(csharpMethods.GetSessionInfo);
            expect(CsBwRpcMethods.ClearSession).toBe(csharpMethods.ClearSession);
            expect(CsBwRpcMethods.Init).toBe(csharpMethods.Init);
        });

        it('should have the same number of methods as C#', () => {
            const csharpMethods = loadFixture<Record<string, string>>('CsBwMethodTypes.json');
            const tsMethodCount = Object.keys(CsBwRpcMethods).length;
            const csharpMethodCount = Object.keys(csharpMethods).length;

            expect(tsMethodCount).toBe(csharpMethodCount);
        });
    });

    describe('isCsBwRpcMethod type guard', () => {
        it('should return true for all C# fixture values', () => {
            const csharpMethods = loadFixture<Record<string, string>>('CsBwMethodTypes.json');

            for (const [key, value] of Object.entries(csharpMethods)) {
                expect(isCsBwRpcMethod(value)).toBe(true);
            }
        });

        it('should return false for invalid methods', () => {
            expect(isCsBwRpcMethod('/invalid/method')).toBe(false);
            expect(isCsBwRpcMethod('')).toBe(false);
            expect(isCsBwRpcMethod('AUTHORIZE')).toBe(false); // case sensitive
        });
    });
});

describe('BwCsMessageTypes Contract Tests', () => {
    describe('message type constants match C# BwCsMessageTypes', () => {
        it('should match all message type values from C# fixture', () => {
            const csharpTypes = loadFixture<Record<string, string>>('BwCsMessageTypes.json');

            expect(BwCsMessageTypes.Ready).toBe(csharpTypes.Ready);
            expect(BwCsMessageTypes.Reply).toBe(csharpTypes.Reply);
            expect(BwCsMessageTypes.ReplyCanceled).toBe(csharpTypes.ReplyCanceled);
            expect(BwCsMessageTypes.ReplyCredential).toBe(csharpTypes.ReplyCredential);
            expect(BwCsMessageTypes.FromBackgroundWorker).toBe(csharpTypes.FromBackgroundWorker);
            expect(BwCsMessageTypes.AppClosed).toBe(csharpTypes.AppClosed);
        });

        it('should have the same number of types as C#', () => {
            const csharpTypes = loadFixture<Record<string, string>>('BwCsMessageTypes.json');
            const tsTypeCount = Object.keys(BwCsMessageTypes).length;
            const csharpTypeCount = Object.keys(csharpTypes).length;

            expect(tsTypeCount).toBe(csharpTypeCount);
        });
    });

    describe('isBwCsMessageType type guard', () => {
        it('should return true for all C# fixture values', () => {
            const csharpTypes = loadFixture<Record<string, string>>('BwCsMessageTypes.json');

            for (const [key, value] of Object.entries(csharpTypes)) {
                expect(isBwCsMessageType(value)).toBe(true);
            }
        });

        it('should return false for invalid types', () => {
            expect(isBwCsMessageType('/invalid/type')).toBe(false);
            expect(isBwCsMessageType('')).toBe(false);
            expect(isBwCsMessageType('READY')).toBe(false); // case sensitive
        });
    });
});
