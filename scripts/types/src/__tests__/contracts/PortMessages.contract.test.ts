/**
 * Contract tests for Port message types.
 * These tests validate that TypeScript types match C# serialization.
 *
 * Fixtures are generated by Extension.Tests/Contracts/MessageContractFixtureGenerator.cs
 * Run `dotnet test --filter "GenerateAllFixtures"` to regenerate fixtures.
 */

import { describe, it, expect } from 'vitest';
import { readFileSync } from 'fs';
import { join } from 'path';
import {
    PortMessageTypes,
    type HelloMessage,
    type ReadyMessage,
    type AttachTabMessage,
    type DetachTabMessage,
    type ErrorMessage,
    type RpcRequest,
    type RpcResponse,
    isHelloMessage,
    isReadyMessage,
    isRpcRequest,
    isRpcResponse,
    isErrorMessage
} from '../../PortMessages.js';
import { CsBwPortMessageTypes } from '../../CsBwRpcMethods.js';

// Path to C# generated fixtures
const FIXTURES_DIR = join(__dirname, '..', '..', '..', '..', '..', 'Extension.Tests', 'Contracts', 'Fixtures');

/**
 * Helper to load a JSON fixture file
 */
function loadFixture<T>(filename: string): T {
    const path = join(FIXTURES_DIR, filename);
    const content = readFileSync(path, 'utf-8');
    return JSON.parse(content) as T;
}

describe('Port Message Contract Tests', () => {
    describe('HelloMessage', () => {
        it('should match C# serialization structure', () => {
            const fixture = loadFixture<HelloMessage>('PortMessage_Hello.json');

            // Verify discriminator
            expect(fixture.t).toBe(PortMessageTypes.Hello);
            expect(fixture.t).toBe('HELLO');

            // Verify type guard works
            expect(isHelloMessage(fixture)).toBe(true);

            // Verify required properties exist
            expect(fixture.context).toBeDefined();
            expect(fixture.instanceId).toBeDefined();
        });

        it('should have correct property types', () => {
            const fixture = loadFixture<HelloMessage>('PortMessage_Hello.json');

            expect(typeof fixture.t).toBe('string');
            expect(typeof fixture.context).toBe('string');
            expect(typeof fixture.instanceId).toBe('string');
            // Optional properties
            if (fixture.tabId !== undefined) {
                expect(typeof fixture.tabId).toBe('number');
            }
            if (fixture.frameId !== undefined) {
                expect(typeof fixture.frameId).toBe('number');
            }
        });
    });

    describe('ReadyMessage', () => {
        it('should match C# serialization structure', () => {
            const fixture = loadFixture<ReadyMessage>('PortMessage_Ready.json');

            expect(fixture.t).toBe(PortMessageTypes.Ready);
            expect(fixture.t).toBe('READY');
            expect(isReadyMessage(fixture)).toBe(true);
            expect(fixture.portSessionId).toBeDefined();
        });
    });

    describe('AttachTabMessage', () => {
        it('should match C# serialization structure', () => {
            const fixture = loadFixture<AttachTabMessage>('PortMessage_AttachTab.json');

            expect(fixture.t).toBe(PortMessageTypes.AttachTab);
            expect(fixture.t).toBe('ATTACH_TAB');
            expect(fixture.tabId).toBeDefined();
            expect(typeof fixture.tabId).toBe('number');
        });
    });

    describe('DetachTabMessage', () => {
        it('should match C# serialization structure', () => {
            const fixture = loadFixture<DetachTabMessage>('PortMessage_DetachTab.json');

            expect(fixture.t).toBe(PortMessageTypes.DetachTab);
            expect(fixture.t).toBe('DETACH_TAB');
        });
    });

    describe('ErrorMessage', () => {
        it('should match C# serialization structure', () => {
            const fixture = loadFixture<ErrorMessage>('PortMessage_Error.json');

            expect(fixture.t).toBe(PortMessageTypes.Error);
            expect(fixture.t).toBe('ERROR');
            expect(isErrorMessage(fixture)).toBe(true);
            expect(fixture.code).toBeDefined();
            expect(fixture.message).toBeDefined();
        });
    });

    describe('RpcRequest', () => {
        it('should match C# serialization structure for Authorize', () => {
            const fixture = loadFixture<RpcRequest>('RpcRequest_Authorize.json');

            expect(fixture.t).toBe(PortMessageTypes.RpcRequest);
            expect(fixture.t).toBe('RPC_REQ');
            expect(isRpcRequest(fixture)).toBe(true);
            expect(fixture.portSessionId).toBeDefined();
            expect(fixture.id).toBeDefined();
            expect(fixture.method).toBe('/signify/authorize');
        });

        it('should match C# serialization structure for SignData', () => {
            const fixture = loadFixture<RpcRequest>('RpcRequest_SignData.json');

            expect(fixture.t).toBe('RPC_REQ');
            expect(fixture.method).toBe('/signify/sign-data');
            expect(fixture.params).toBeDefined();
            // Verify params structure
            const params = fixture.params as { message?: string; items?: string[] };
            expect(params.items).toBeDefined();
            expect(Array.isArray(params.items)).toBe(true);
        });

        it('should match C# serialization structure for SignRequest', () => {
            const fixture = loadFixture<RpcRequest>('RpcRequest_SignRequest.json');

            expect(fixture.method).toBe('/signify/sign-request');
            const params = fixture.params as { url?: string; method?: string; headers?: Record<string, string> };
            expect(params.url).toBeDefined();
            expect(params.method).toBeDefined();
        });

        it('should match C# serialization structure for CreateDataAttestation', () => {
            const fixture = loadFixture<RpcRequest>('RpcRequest_CreateDataAttestation.json');

            expect(fixture.method).toBe('/signify/credential/create/data-attestation');
            const params = fixture.params as { credData?: unknown; schemaSaid?: string };
            expect(params.credData).toBeDefined();
            expect(params.schemaSaid).toBeDefined();
        });

        it('should match C# serialization structure for SignifyExtension', () => {
            const fixture = loadFixture<RpcRequest>('RpcRequest_SignifyExtension.json');

            expect(fixture.method).toBe('signify-extension');
            // This request typically has no params
        });
    });

    describe('RpcResponse', () => {
        it('should match C# serialization structure for success', () => {
            const fixture = loadFixture<RpcResponse>('RpcResponse_AuthorizeSuccess.json');

            expect(fixture.t).toBe(PortMessageTypes.RpcResponse);
            expect(fixture.t).toBe('RPC_RES');
            expect(isRpcResponse(fixture)).toBe(true);
            expect(fixture.ok).toBe(true);
            expect(fixture.result).toBeDefined();
            expect(fixture.error).toBeUndefined();
        });

        it('should match C# serialization structure for error', () => {
            const fixture = loadFixture<RpcResponse>('RpcResponse_Error.json');

            expect(fixture.t).toBe('RPC_RES');
            expect(fixture.ok).toBe(false);
            expect(fixture.error).toBeDefined();
            expect(typeof fixture.error).toBe('string');
        });

        it('should match C# serialization structure for credential response', () => {
            const fixture = loadFixture<RpcResponse>('RpcResponse_CredentialSuccess.json');

            expect(fixture.ok).toBe(true);
            const result = fixture.result as { credential?: { raw?: unknown; cesr?: string } };
            expect(result.credential).toBeDefined();
            expect(result.credential?.raw).toBeDefined();
            expect(result.credential?.cesr).toBeDefined();
        });

        it('should match C# serialization structure for sign-data response', () => {
            const fixture = loadFixture<RpcResponse>('RpcResponse_SignDataSuccess.json');

            expect(fixture.ok).toBe(true);
            const result = fixture.result as { aid?: string; items?: Array<{ data: string; signature: string }> };
            expect(result.aid).toBeDefined();
            expect(result.items).toBeDefined();
            expect(Array.isArray(result.items)).toBe(true);
            if (result.items && result.items.length > 0) {
                const firstItem = result.items[0];
                if (firstItem) {
                    expect(firstItem.data).toBeDefined();
                    expect(firstItem.signature).toBeDefined();
                }
            }
        });

        it('should match C# serialization structure for extension ID response', () => {
            const fixture = loadFixture<RpcResponse>('RpcResponse_ExtensionId.json');

            expect(fixture.ok).toBe(true);
            const result = fixture.result as { extensionId?: string };
            expect(result.extensionId).toBeDefined();
            expect(typeof result.extensionId).toBe('string');
        });
    });
});

describe('PortMessageTypes constants', () => {
    it('should have all expected discriminator values', () => {
        expect(PortMessageTypes.Hello).toBe('HELLO');
        expect(PortMessageTypes.Ready).toBe('READY');
        expect(PortMessageTypes.AttachTab).toBe('ATTACH_TAB');
        expect(PortMessageTypes.DetachTab).toBe('DETACH_TAB');
        expect(PortMessageTypes.Event).toBe('EVENT');
        expect(PortMessageTypes.RpcRequest).toBe('RPC_REQ');
        expect(PortMessageTypes.RpcResponse).toBe('RPC_RES');
        expect(PortMessageTypes.Error).toBe('ERROR');
    });

    it('should match C# PortMessageTypes fixture', () => {
        const csharpTypes = loadFixture<Record<string, string>>('PortMessageTypes.json');

        expect(PortMessageTypes.Hello).toBe(csharpTypes.Hello);
        expect(PortMessageTypes.Ready).toBe(csharpTypes.Ready);
        expect(PortMessageTypes.AttachTab).toBe(csharpTypes.AttachTab);
        expect(PortMessageTypes.DetachTab).toBe(csharpTypes.DetachTab);
        expect(PortMessageTypes.Event).toBe(csharpTypes.Event);
        expect(PortMessageTypes.RpcRequest).toBe(csharpTypes.RpcRequest);
        expect(PortMessageTypes.RpcResponse).toBe(csharpTypes.RpcResponse);
        expect(PortMessageTypes.Error).toBe(csharpTypes.Error);
    });

    it('should have the same number of types as C#', () => {
        const csharpTypes = loadFixture<Record<string, string>>('PortMessageTypes.json');
        const tsTypeCount = Object.keys(PortMessageTypes).length;
        const csharpTypeCount = Object.keys(csharpTypes).length;

        expect(tsTypeCount).toBe(csharpTypeCount);
    });
});

describe('CsBwPortMessageTypes constants (directional discriminators)', () => {
    it('should have directional RPC discriminators for CSâ†’BW communication', () => {
        expect(CsBwPortMessageTypes.RpcRequest).toBe('CS_BW_RPC_REQ');
        expect(CsBwPortMessageTypes.RpcResponse).toBe('BW_CS_RPC_RES');
    });

    it('should match C# CsBwPortMessageTypes fixture', () => {
        const csharpTypes = loadFixture<Record<string, string>>('CsBwPortMessageTypes.json');

        expect(CsBwPortMessageTypes.RpcRequest).toBe(csharpTypes.RpcRequest);
        expect(CsBwPortMessageTypes.RpcResponse).toBe(csharpTypes.RpcResponse);
    });

    it('should have the same number of types as C#', () => {
        const csharpTypes = loadFixture<Record<string, string>>('CsBwPortMessageTypes.json');
        const tsTypeCount = Object.keys(CsBwPortMessageTypes).length;
        const csharpTypeCount = Object.keys(csharpTypes).length;

        expect(tsTypeCount).toBe(csharpTypeCount);
    });
});
